(this["webpackJsonp"] = this["webpackJsonp"] || []).push([["app-service"],[
/* 0 */
/*!********************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/main.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ 1);\nvar _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ 2));\n__webpack_require__(/*! uni-pages */ 6);\nvar _App = _interopRequireDefault(__webpack_require__(/*! ./App */ 192));\nvar _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 22));\n__webpack_require__(/*! ./uni.promisify.adaptor */ 195);\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n_vue.default.config.productionTip = false;\n_App.default.mpType = 'app';\nvar app = new _vue.default(_objectSpread({}, _App.default));\napp.$mount();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vbWFpbi5qcyJdLCJuYW1lcyI6WyJWdWUiLCJjb25maWciLCJwcm9kdWN0aW9uVGlwIiwiQXBwIiwibXBUeXBlIiwiYXBwIiwiJG1vdW50Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFBbUI7QUFHbkI7QUFDQTtBQUFnQztBQUFBO0FBQ2hDQSxZQUFHLENBQUNDLE1BQU0sQ0FBQ0MsYUFBYSxHQUFHLEtBQUs7QUFDaENDLFlBQUcsQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7QUFDbEIsSUFBTUMsR0FBRyxHQUFHLElBQUlMLFlBQUcsbUJBQ2RHLFlBQUcsRUFDTjtBQUNGRSxHQUFHLENBQUNDLE1BQU0sRUFBRSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICd1bmktcGFnZXMnO2ltcG9ydCBBcHAgZnJvbSAnLi9BcHAnXG5cblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgJy4vdW5pLnByb21pc2lmeS5hZGFwdG9yJ1xuVnVlLmNvbmZpZy5wcm9kdWN0aW9uVGlwID0gZmFsc2VcbkFwcC5tcFR5cGUgPSAnYXBwJ1xuY29uc3QgYXBwID0gbmV3IFZ1ZSh7XG4gIC4uLkFwcFxufSlcbmFwcC4kbW91bnQoKVxuXG5cblxuXG5cblxuXG5cblxuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 2 */
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ 3);
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 3 */
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ 4)["default"];
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ 5);
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 4 */
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(o) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 5 */
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ./typeof.js */ 4)["default"];
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 6 */
/*!***********************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/pages.json ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (typeof Promise !== 'undefined' && !Promise.prototype.finally) {
  Promise.prototype.finally = function (callback) {
    var promise = this.constructor;
    return this.then(function (value) {
      return promise.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      return promise.resolve(callback()).then(function () {
        throw reason;
      });
    });
  };
}
if (typeof uni !== 'undefined' && uni && uni.requireGlobal) {
  var global = uni.requireGlobal();
  ArrayBuffer = global.ArrayBuffer;
  Int8Array = global.Int8Array;
  Uint8Array = global.Uint8Array;
  Uint8ClampedArray = global.Uint8ClampedArray;
  Int16Array = global.Int16Array;
  Uint16Array = global.Uint16Array;
  Int32Array = global.Int32Array;
  Uint32Array = global.Uint32Array;
  Float32Array = global.Float32Array;
  Float64Array = global.Float64Array;
  BigInt64Array = global.BigInt64Array;
  BigUint64Array = global.BigUint64Array;
}
if (uni.restoreGlobal) {
  uni.restoreGlobal(weex, plus, setTimeout, clearTimeout, setInterval, clearInterval);
}
__definePage('pages/index/index', function () {
  return Vue.extend(__webpack_require__(/*! pages/index/index.vue?mpType=page */ 7).default);
});

/***/ }),
/* 7 */
/*!**********************************************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/pages/index/index.vue?mpType=page ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_vue_vue_type_template_id_2be84a3c_scoped_true_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.vue?vue&type=template&id=2be84a3c&scoped=true&mpType=page */ 8);\n/* harmony import */ var _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.vue?vue&type=script&lang=js&mpType=page */ 10);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js */ 32);\n\nvar renderjs\n\n\n\n\n/* normalize component */\n\nvar component = Object(_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _index_vue_vue_type_template_id_2be84a3c_scoped_true_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _index_vue_vue_type_template_id_2be84a3c_scoped_true_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  \"2be84a3c\",\n  null,\n  false,\n  _index_vue_vue_type_template_id_2be84a3c_scoped_true_mpType_page__WEBPACK_IMPORTED_MODULE_0__[\"components\"],\n  renderjs\n)\n\ncomponent.options.__file = \"pages/index/index.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBeUk7QUFDekk7QUFDb0U7QUFDTDs7O0FBRy9EO0FBQ3FLO0FBQ3JLLGdCQUFnQiwrS0FBVTtBQUMxQixFQUFFLHNGQUFNO0FBQ1IsRUFBRSx1R0FBTTtBQUNSLEVBQUUsZ0hBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkdBQVU7QUFDWjtBQUNBOztBQUVBO0FBQ2UsZ0YiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zLCByZWN5Y2xhYmxlUmVuZGVyLCBjb21wb25lbnRzIH0gZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTJiZTg0YTNjJnNjb3BlZD10cnVlJm1wVHlwZT1wYWdlXCJcbnZhciByZW5kZXJqc1xuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmbXBUeXBlPXBhZ2VcIlxuZXhwb3J0ICogZnJvbSBcIi4vaW5kZXgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJm1wVHlwZT1wYWdlXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXEBkY2xvdWRpb1xcXFx2dWUtY2xpLXBsdWdpbi11bmlcXFxccGFja2FnZXNcXFxcdnVlLWxvYWRlclxcXFxsaWJcXFxccnVudGltZVxcXFxjb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIyYmU4NGEzY1wiLFxuICBudWxsLFxuICBmYWxzZSxcbiAgY29tcG9uZW50cyxcbiAgcmVuZGVyanNcbilcblxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWdlcy9pbmRleC9pbmRleC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/*!****************************************************************************************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/pages/index/index.vue?vue&type=template&id=2be84a3c&scoped=true&mpType=page ***!
  \****************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_scoped_true_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--11-0!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./index.vue?vue&type=template&id=2be84a3c&scoped=true&mpType=page */ 9);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_scoped_true_mpType_page__WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_scoped_true_mpType_page__WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_scoped_true_mpType_page__WEBPACK_IMPORTED_MODULE_0__["recyclableRender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "components", function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_template_id_2be84a3c_scoped_true_mpType_page__WEBPACK_IMPORTED_MODULE_0__["components"]; });



/***/ }),
/* 9 */
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--11-0!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!I:/物联网参考demo-APP详细代码/最终APP程序/pages/index/index.vue?vue&type=template&id=2be84a3c&scoped=true&mpType=page ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return recyclableRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "components", function() { return components; });
var components
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: _vm._$s(0, "sc", "wrapper"), attrs: { _i: 0 } },
    [
      _c("div", { staticClass: _vm._$s(1, "sc", "body"), attrs: { _i: 1 } }, [
        _c(
          "div",
          { staticClass: _vm._$s(2, "sc", "data-header"), attrs: { _i: 2 } },
          [_c("span")]
        ),
        _c(
          "div",
          { staticClass: _vm._$s(4, "sc", "data-wrapper"), attrs: { _i: 4 } },
          [
            _c(
              "div",
              { staticClass: _vm._$s(5, "sc", "data-temp"), attrs: { _i: 5 } },
              [
                _c("img", {
                  staticClass: _vm._$s(6, "sc", "data-logo"),
                  attrs: { _i: 6 },
                }),
                _c(
                  "div",
                  {
                    staticClass: _vm._$s(7, "sc", "data-text"),
                    attrs: { _i: 7 },
                  },
                  [
                    _c("div", {
                      staticClass: _vm._$s(8, "sc", "data-title"),
                      attrs: { _i: 8 },
                    }),
                    _c(
                      "div",
                      {
                        staticClass: _vm._$s(9, "sc", "data-value"),
                        attrs: { _i: 9 },
                      },
                      [_vm._v(_vm._$s(9, "t0-0", _vm._s(_vm.temp)))]
                    ),
                  ]
                ),
              ]
            ),
            _c(
              "div",
              {
                staticClass: _vm._$s(10, "sc", "data-humi"),
                attrs: { _i: 10 },
              },
              [
                _c("img", {
                  staticClass: _vm._$s(11, "sc", "data-logo"),
                  attrs: { _i: 11 },
                }),
                _c(
                  "div",
                  {
                    staticClass: _vm._$s(12, "sc", "data-text"),
                    attrs: { _i: 12 },
                  },
                  [
                    _c("div", {
                      staticClass: _vm._$s(13, "sc", "data-title"),
                      attrs: { _i: 13 },
                    }),
                    _c(
                      "div",
                      {
                        staticClass: _vm._$s(14, "sc", "data-value"),
                        attrs: { _i: 14 },
                      },
                      [_vm._v(_vm._$s(14, "t0-0", _vm._s(_vm.humi)))]
                    ),
                  ]
                ),
              ]
            ),
          ]
        ),
        _c(
          "div",
          { staticClass: _vm._$s(15, "sc", "data-header"), attrs: { _i: 15 } },
          [_c("span")]
        ),
        _c(
          "div",
          { staticClass: _vm._$s(17, "sc", "data-wrapper"), attrs: { _i: 17 } },
          [
            _c(
              "div",
              {
                staticClass: _vm._$s(18, "sc", "control-led"),
                attrs: { _i: 18 },
              },
              [
                _c("img", {
                  staticClass: _vm._$s(19, "sc", "data-logo"),
                  attrs: { _i: 19 },
                }),
                _c(
                  "div",
                  {
                    staticClass: _vm._$s(20, "sc", "data-text"),
                    attrs: { _i: 20 },
                  },
                  [
                    _c("div", {
                      staticClass: _vm._$s(21, "sc", "data-title"),
                      attrs: { _i: 21 },
                    }),
                    _c(
                      "div",
                      {
                        staticClass: _vm._$s(22, "sc", "data-value"),
                        attrs: { _i: 22 },
                      },
                      [
                        _c("switch", {
                          staticClass: _vm._$s(23, "sc", "led-sw"),
                          attrs: {
                            checked: _vm._$s(23, "a-checked", _vm.led),
                            _i: 23,
                          },
                          on: { change: _vm.onLedChange },
                        }),
                      ]
                    ),
                  ]
                ),
              ]
            ),
            _c(
              "div",
              {
                staticClass: _vm._$s(24, "sc", "control-alarm"),
                attrs: { _i: 24 },
              },
              [
                _c("img", {
                  staticClass: _vm._$s(25, "sc", "data-logo"),
                  attrs: { _i: 25 },
                }),
                _c(
                  "div",
                  {
                    staticClass: _vm._$s(26, "sc", "data-text"),
                    attrs: { _i: 26 },
                  },
                  [
                    _c("div", {
                      staticClass: _vm._$s(27, "sc", "data-title"),
                      attrs: { _i: 27 },
                    }),
                    _c(
                      "div",
                      {
                        staticClass: _vm._$s(28, "sc", "data-value"),
                        attrs: { _i: 28 },
                      },
                      [
                        _c("switch", {
                          staticClass: _vm._$s(29, "sc", "alarm-sw"),
                          attrs: {
                            checked: _vm._$s(29, "a-checked", _vm.alarm),
                            _i: 29,
                          },
                          on: { change: _vm.onAlarmChange },
                        }),
                      ]
                    ),
                  ]
                ),
              ]
            ),
          ]
        ),
        _c(
          "div",
          { staticClass: _vm._$s(30, "sc", "data-header"), attrs: { _i: 30 } },
          [_c("span")]
        ),
        _c(
          "div",
          { staticClass: _vm._$s(32, "sc", "data-wrapper"), attrs: { _i: 32 } },
          [
            _c(
              "div",
              { staticClass: _vm._$s(33, "sc", "logsList"), attrs: { _i: 33 } },
              [
                _c(
                  "ul",
                  {
                    staticClass: _vm._$s(34, "sc", "container log-list"),
                    attrs: { _i: 34 },
                  },
                  _vm._l(
                    _vm._$s(35, "f", { forItems: _vm.logs.slice().reverse() }),
                    function (log, index, $20, $30) {
                      return _c(
                        "li",
                        {
                          key: _vm._$s(35, "f", { forIndex: $20, key: index }),
                          staticClass: _vm._$s("35-" + $30, "sc", "log-item"),
                          attrs: { _i: "35-" + $30 },
                        },
                        [
                          _c("card", {
                            style: _vm._$s("36-" + $30, "s", {
                              fontSize: "12px",
                              color: "#333",
                            }),
                            attrs: { text: log, _i: "36-" + $30 },
                          }),
                        ],
                        1
                      )
                    }
                  ),
                  0
                ),
              ]
            ),
          ]
        ),
      ]),
    ]
  )
}
var recyclableRender = false
var staticRenderFns = []
render._withStripped = true



/***/ }),
/* 10 */
/*!**********************************************************************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/pages/index/index.vue?vue&type=script&lang=js&mpType=page ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--7-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./index.vue?vue&type=script&lang=js&mpType=page */ 11);\n/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_index_vue_vue_type_script_lang_js_mpType_page__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJpQixDQUFnQiw4a0JBQUcsRUFBQyIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hRjpcXFxcSEJ1aWxkZXJYXFxcXHBsdWdpbnNcXFxcdW5pYXBwLWNsaVxcXFxub2RlX21vZHVsZXNcXFxcYmFiZWwtbG9hZGVyXFxcXGxpYlxcXFxpbmRleC5qcyFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHdlYnBhY2stcHJlcHJvY2Vzcy1sb2FkZXJcXFxcaW5kZXguanM/P3JlZi0tNy0xIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXEBkY2xvdWRpb1xcXFx2dWUtY2xpLXBsdWdpbi11bmlcXFxccGFja2FnZXNcXFxcd2VicGFjay11bmktYXBwLWxvYWRlclxcXFx1c2luZy1jb21wb25lbnRzLmpzIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXEBkY2xvdWRpb1xcXFx2dWUtY2xpLXBsdWdpbi11bmlcXFxccGFja2FnZXNcXFxcdnVlLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2luZGV4LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZtcFR5cGU9cGFnZVwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanMhRjpcXFxcSEJ1aWxkZXJYXFxcXHBsdWdpbnNcXFxcdW5pYXBwLWNsaVxcXFxub2RlX21vZHVsZXNcXFxcQGRjbG91ZGlvXFxcXHZ1ZS1jbGktcGx1Z2luLXVuaVxcXFxwYWNrYWdlc1xcXFx3ZWJwYWNrLXByZXByb2Nlc3MtbG9hZGVyXFxcXGluZGV4LmpzPz9yZWYtLTctMSFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHdlYnBhY2stdW5pLWFwcC1sb2FkZXJcXFxcdXNpbmctY29tcG9uZW50cy5qcyFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHZ1ZS1sb2FkZXJcXFxcbGliXFxcXGluZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9pbmRleC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmbXBUeXBlPXBhZ2VcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--7-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!I:/物联网参考demo-APP详细代码/最终APP程序/pages/index/index.vue?vue&type=script&lang=js&mpType=page ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__f__) {\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ 1);\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _mqtt = __webpack_require__(/*! @/mqtt.js */ 13);\nvar _card = _interopRequireDefault(__webpack_require__(/*! @/card */ 27));\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nvar _require = __webpack_require__(/*! @/key.js */ 33),\n  createCommonToken = _require.createCommonToken;\nvar _default = {\n  data: function data() {\n    return {\n      client: {},\n      temp: '1',\n      humi: '1',\n      led: true,\n      alarm: true,\n      logs: []\n    };\n  },\n  components: {\n    card: _card.default\n  },\n  onLoad: function onLoad() {\n    this.fetchDevData();\n  },\n  methods: {\n    getFormattedDate: function getFormattedDate() {\n      // 创建一个新的 Date 对象\n      var date = new Date();\n\n      // 获取年、月、日、小时和分钟\n      var year = date.getFullYear();\n      var month = (date.getMonth() + 1).toString().padStart(2, '0'); // 月份是从 0 开始的\n      var day = date.getDate().toString().padStart(2, '0');\n      var hours = date.getHours().toString().padStart(2, '0');\n      var minutes = date.getMinutes().toString().padStart(2, '0');\n      var seconds = date.getSeconds().toString().padStart(2, '0');\n\n      // 组合成 yyyy-mm-dd hh:mm 格式\n      return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \" \").concat(hours, \":\").concat(minutes, \":\").concat(seconds, \"  \");\n    },\n    fetchDevData: function fetchDevData() {\n      var _this = this;\n      _this.client = (0, _mqtt.connect)(\"ws://wf111287.ala.dedicated.aliyun.emqxcloud.cn:8083/mqtt\", {\n        clientId: \"wx\",\n        username: \"wx\",\n        password: \"123456\"\n      });\n      _this.logs.push(\"\".concat(_this.getFormattedDate(), \" \\u6210\\u529F\\u8FDE\\u63A5\\u8BBE\\u5907\"));\n      _this.client.on(\"connect\", function () {\n        __f__(\"log\", \"成功连接 mqtt 服务器\", \" at pages/index/index.vue:110\");\n        _this.client.subscribe(\"getData/3\", function (error) {\n          if (!error) {\n            __f__(\"log\", \"成功订阅设备数据上行到小程序topic\", \" at pages/index/index.vue:113\"), _this.logs.push(\"\".concat(_this.getFormattedDate(), \" \\u6210\\u529F\\u8BA2\\u9605\\u8BBE\\u5907\\u6570\\u636E\"));\n          }\n        });\n      });\n      _this.client.on(\"message\", function (topic, message) {\n        __f__(\"log\", '-----------------------------------------', \" at pages/index/index.vue:124\");\n        __f__(\"log\", '设备数据上行 topic:' + topic, \" at pages/index/index.vue:125\");\n        var sensorData = JSON.parse(message);\n        __f__(\"log\", sensorData, \" at pages/index/index.vue:128\");\n        __f__(\"log\", sensorData.Humi, \" at pages/index/index.vue:129\");\n        __f__(\"log\", sensorData.Temp, \" at pages/index/index.vue:130\");\n        __f__(\"log\", sensorData.Led, \" at pages/index/index.vue:131\");\n        //console.log(sensorData.Beep)\n\n        //获取数据 绑定数据\n        _this.temp = sensorData.Temp + \"℃\";\n        _this.humi = sensorData.Humi + \"%\";\n        _this.led = sensorData.Led == 1 ? true : false;\n        _this.logs.push(\"\".concat(_this.getFormattedDate(), \"  \\u8BBE\\u5907\\u6570\\u636E: { Temp: \").concat(_this.temp, \" , Humi: \").concat(_this.humi, \" , Led: \").concat(_this.led, \" }\"));\n        //_this.alarm = false\n      });\n    },\n    //TODO 报警器开关执行方法\n    onAlarmChange: function onAlarmChange(event) {\n      var _this = this;\n      var switchState = event.mp.detail.value;\n      __f__(\"log\", switchState, \" at pages/index/index.vue:147\");\n      if (switchState) {\n        __f__(\"log\", \"下发指令：开启报警\", \" at pages/index/index.vue:149\");\n        _this.client.publish('Operate/3', '{\"Beep\":1}', function (error) {\n          if (!error) {\n            __f__(\"log\", \"成功下发指令到设备端：开启报警\", \" at pages/index/index.vue:155\");\n            _this.logs.push(\"\".concat(_this.getFormattedDate(), \" \\u4E0B\\u53D1\\u6307\\u4EE4\\uFF1A\\u5F00\\u542F\\u62A5\\u8B66\"));\n          }\n        });\n      } else {\n        __f__(\"log\", \"下发指令：关闭报警\", \" at pages/index/index.vue:160\");\n        _this.client.publish('Operate/3', '{\"Beep\":0}', function (error) {\n          if (!error) {\n            __f__(\"log\", \"成功下发指令到设备端：关闭报警\", \" at pages/index/index.vue:166\");\n            _this.logs.push(\"\".concat(_this.getFormattedDate(), \" \\u4E0B\\u53D1\\u6307\\u4EE4\\uFF1A\\u5173\\u95ED\\u62A5\\u8B66\"));\n          }\n        });\n      }\n    },\n    // TODO LED开关执行方法\n    onLedChange: function onLedChange(event) {\n      var _this = this;\n      var switchState = event.mp.detail.value;\n      __f__(\"log\", switchState, \" at pages/index/index.vue:176\");\n      if (switchState) {\n        __f__(\"log\", \"下发指令：开灯\", \" at pages/index/index.vue:178\");\n        _this.client.publish('Operate/3', '{\"LED\":1}', function (error) {\n          if (!error) {\n            __f__(\"log\", \"成功下发指令到设备端：开灯\", \" at pages/index/index.vue:184\");\n            _this.logs.push(\"\".concat(_this.getFormattedDate(), \" \\u4E0B\\u53D1\\u6307\\u4EE4\\uFF1A\\u5F00\\u706F\"));\n          }\n        });\n      } else {\n        __f__(\"log\", \"下发指令：关灯\", \" at pages/index/index.vue:189\");\n        _this.client.publish('Operate/3', '{\"LED\":0}', function (error) {\n          if (!error) {\n            __f__(\"log\", \"成功下发指令到设备端：关灯\", \" at pages/index/index.vue:195\");\n            _this.logs.push(\"\".concat(_this.getFormattedDate(), \" \\u4E0B\\u53D1\\u6307\\u4EE4\\uFF1A\\u5173\\u706F\"));\n          }\n        });\n      }\n    }\n  }\n};\nexports.default = _default;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js */ 12)[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vcGFnZXMvaW5kZXgvaW5kZXgudnVlIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjcmVhdGVDb21tb25Ub2tlbiIsImRhdGEiLCJjbGllbnQiLCJ0ZW1wIiwiaHVtaSIsImxlZCIsImFsYXJtIiwibG9ncyIsImNvbXBvbmVudHMiLCJjYXJkIiwib25Mb2FkIiwiZmV0Y2hEZXZEYXRhIiwibWV0aG9kcyIsImdldEZvcm1hdHRlZERhdGUiLCJkYXRlIiwiRGF0ZSIsInllYXIiLCJnZXRGdWxsWWVhciIsIm1vbnRoIiwiZ2V0TW9udGgiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiZGF5IiwiZ2V0RGF0ZSIsImhvdXJzIiwiZ2V0SG91cnMiLCJtaW51dGVzIiwiZ2V0TWludXRlcyIsInNlY29uZHMiLCJnZXRTZWNvbmRzIiwiX3RoaXMiLCJjb25uZWN0IiwiY2xpZW50SWQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicHVzaCIsIm9uIiwic3Vic2NyaWJlIiwiZXJyb3IiLCJ0b3BpYyIsIm1lc3NhZ2UiLCJzZW5zb3JEYXRhIiwiSlNPTiIsInBhcnNlIiwiSHVtaSIsIlRlbXAiLCJMZWQiLCJvbkFsYXJtQ2hhbmdlIiwiZXZlbnQiLCJzd2l0Y2hTdGF0ZSIsIm1wIiwiZGV0YWlsIiwidmFsdWUiLCJwdWJsaXNoIiwib25MZWRDaGFuZ2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUE4REE7QUFDQTtBQS9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDO01BQ1A7SUFDSjtFQUNEO0FBQ0QsQ0FBQztBQUFBLDJCIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuaW1wb3J0IHsgY29ubmVjdCB9IGZyb20gJ0AvbXF0dC5qcydcbmltcG9ydCBjYXJkIGZyb20gJ0AvY2FyZCdcbmNvbnN0IHtcblx0Y3JlYXRlQ29tbW9uVG9rZW5cbn0gPSByZXF1aXJlKCdAL2tleS5qcycpXG5leHBvcnQgZGVmYXVsdCB7XG5cdGRhdGEoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNsaWVudDoge30sXG5cdFx0XHR0ZW1wOiAnMScsXG5cdFx0XHRodW1pOiAnMScsXG5cdFx0XHRsZWQ6IHRydWUsXG5cdFx0XHRhbGFybTogdHJ1ZSxcblx0XHRcdGxvZ3M6IFtdXG5cdFx0fVxuXHR9LFxuXHRjb21wb25lbnRzOiB7XG5cdCAgICBjYXJkXG5cdH0sXG5cdG9uTG9hZCgpIHtcblx0XHR0aGlzLmZldGNoRGV2RGF0YSgpO1xuXHR9LFxuXHRtZXRob2RzOiB7XG5cdFx0Z2V0Rm9ybWF0dGVkRGF0ZSgpIHtcblx0XHQgIC8vIOWIm+W7uuS4gOS4quaWsOeahCBEYXRlIOWvueixoVxuXHRcdCAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG5cdFx0XG5cdFx0ICAvLyDojrflj5blubTjgIHmnIjjgIHml6XjgIHlsI/ml7blkozliIbpkp9cblx0XHQgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0ICBjb25zdCBtb250aCA9IChkYXRlLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7IC8vIOaciOS7veaYr+S7jiAwIOW8gOWni+eahFxuXHRcdCAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuXHRcdCAgY29uc3QgaG91cnMgPSBkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpO1xuXHRcdCAgY29uc3QgbWludXRlcyA9IGRhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcblx0XHQgIGNvbnN0IHNlY29uZHMgPSBkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyk7XG5cdFx0ICBcblx0XHQgIC8vIOe7hOWQiOaIkCB5eXl5LW1tLWRkIGhoOm1tIOagvOW8j1xuXHRcdCAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fSAke2hvdXJzfToke21pbnV0ZXN9OiR7c2Vjb25kc30gIGA7XG5cdFx0fSxcblx0XHRmZXRjaERldkRhdGEoKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzXG5cdFx0XHRfdGhpcy5jbGllbnQgPSBjb25uZWN0KFwid3M6Ly93ZjExMTI4Ny5hbGEuZGVkaWNhdGVkLmFsaXl1bi5lbXF4Y2xvdWQuY246ODA4My9tcXR0XCIsIHtcblx0XHRcdCAgICAgICAgICAgIGNsaWVudElkOiBcInd4XCIsXG5cdFx0XHQgICAgICAgICAgICB1c2VybmFtZTogXCJ3eFwiLFxuXHRcdFx0ICAgICAgICAgICAgcGFzc3dvcmQ6IFwiMTIzNDU2XCJcblx0XHRcdCB9KTtcblx0XHRcdF90aGlzLmxvZ3MucHVzaChgJHtfdGhpcy5nZXRGb3JtYXR0ZWREYXRlKCl9IOaIkOWKn+i/nuaOpeiuvuWkh2ApO1xuXHRcdFx0X3RoaXMuY2xpZW50Lm9uKFwiY29ubmVjdFwiLGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgICAgICAgY29uc29sZS5sb2coXCLmiJDlip/ov57mjqUgbXF0dCDmnI3liqHlmahcIilcblx0XHRcdCAgICAgICAgX3RoaXMuY2xpZW50LnN1YnNjcmliZShcImdldERhdGEvM1wiLGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0ICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLmiJDlip/orqLpmIXorr7lpIfmlbDmja7kuIrooYzliLDlsI/nqIvluo90b3BpY1wiKSxcblx0XHRcdFx0XHRcdFx0XHRfdGhpcy5sb2dzLnB1c2goYCR7X3RoaXMuZ2V0Rm9ybWF0dGVkRGF0ZSgpfSDmiJDlip/orqLpmIXorr7lpIfmlbDmja5gKTtcblx0XHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0XHQgICAgICAgICAgICB9XG5cdFx0XHQgICAgICAgIClcblx0XHRcdCAgICB9XG5cdFx0XHQpXG5cdFx0XHRcblx0XHRcdF90aGlzLmNsaWVudC5vbihcblx0XHRcdCAgICBcIm1lc3NhZ2VcIixcblx0XHRcdCAgICBmdW5jdGlvbiAodG9waWMsIG1lc3NhZ2UpIHtcblx0XHRcdCAgICAgICAgY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJylcblx0XHRcdCAgICAgICAgY29uc29sZS5sb2coJ+iuvuWkh+aVsOaNruS4iuihjCB0b3BpYzonICsgdG9waWMpXG5cdFx0XHQgICAgICAgIHZhciBzZW5zb3JEYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlKVxuXHRcdFx0XHRcdFxuXHRcdFx0ICAgICAgICBjb25zb2xlLmxvZyhzZW5zb3JEYXRhKVxuXHRcdFx0ICAgICAgICBjb25zb2xlLmxvZyhzZW5zb3JEYXRhLkh1bWkpXG5cdFx0XHQgICAgICAgIGNvbnNvbGUubG9nKHNlbnNvckRhdGEuVGVtcClcblx0XHRcdCAgICAgICAgY29uc29sZS5sb2coc2Vuc29yRGF0YS5MZWQpXG5cdFx0XHQgICAgICAgIC8vY29uc29sZS5sb2coc2Vuc29yRGF0YS5CZWVwKVxuXHRcdFx0XG5cdFx0XHQgICAgICAgIC8v6I635Y+W5pWw5o2uIOe7keWumuaVsOaNrlxuXHRcdFx0ICAgICAgICBfdGhpcy50ZW1wID0gc2Vuc29yRGF0YS5UZW1wICsgXCLihINcIlxuXHRcdFx0ICAgICAgICBfdGhpcy5odW1pID0gc2Vuc29yRGF0YS5IdW1pICsgXCIlXCJcblx0XHRcdCAgICAgICAgX3RoaXMubGVkID0gc2Vuc29yRGF0YS5MZWQ9PTE/dHJ1ZTpmYWxzZVxuXHRcdFx0XHRcdF90aGlzLmxvZ3MucHVzaChgJHtfdGhpcy5nZXRGb3JtYXR0ZWREYXRlKCl9ICDorr7lpIfmlbDmja46IHsgVGVtcDogJHtfdGhpcy50ZW1wfSAsIEh1bWk6ICR7X3RoaXMuaHVtaX0gLCBMZWQ6ICR7X3RoaXMubGVkfSB9YCk7XG5cdFx0XHQgICAgICAgIC8vX3RoaXMuYWxhcm0gPSBmYWxzZVxuXHRcdFx0ICAgIH1cblx0XHRcdClcblx0XHR9LFxuXHRcdC8vVE9ETyDmiqXorablmajlvIDlhbPmiafooYzmlrnms5Vcblx0XHRvbkFsYXJtQ2hhbmdlKGV2ZW50KSB7XG5cdFx0ICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgIHZhciBzd2l0Y2hTdGF0ZSA9IGV2ZW50Lm1wLmRldGFpbC52YWx1ZVxuXHRcdCAgICBjb25zb2xlLmxvZyhzd2l0Y2hTdGF0ZSlcblx0XHQgICAgaWYgKHN3aXRjaFN0YXRlKSB7XG5cdFx0ICAgICAgICBjb25zb2xlLmxvZyhcIuS4i+WPkeaMh+S7pO+8muW8gOWQr+aKpeitplwiKVxuXHRcdCAgICAgICAgX3RoaXMuY2xpZW50LnB1Ymxpc2goXG5cdFx0ICAgICAgICAgICAgJ09wZXJhdGUvMycsXG5cdFx0ICAgICAgICAgICAgJ3tcIkJlZXBcIjoxfScsXG5cdFx0ICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5oiQ5Yqf5LiL5Y+R5oyH5Luk5Yiw6K6+5aSH56uv77ya5byA5ZCv5oql6K2mXCIpXG5cdFx0XHRcdFx0XHRcdF90aGlzLmxvZ3MucHVzaChgJHtfdGhpcy5nZXRGb3JtYXR0ZWREYXRlKCl9IOS4i+WPkeaMh+S7pO+8muW8gOWQr+aKpeitpmApO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfSlcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICAgIGNvbnNvbGUubG9nKFwi5LiL5Y+R5oyH5Luk77ya5YWz6Zet5oql6K2mXCIpXG5cdFx0ICAgICAgICBfdGhpcy5jbGllbnQucHVibGlzaChcblx0XHQgICAgICAgICAgICAnT3BlcmF0ZS8zJyxcblx0XHQgICAgICAgICAgICAne1wiQmVlcFwiOjB9Jyxcblx0XHQgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLmiJDlip/kuIvlj5HmjIfku6TliLDorr7lpIfnq6/vvJrlhbPpl63miqXoraZcIilcblx0XHRcdFx0XHRcdFx0X3RoaXMubG9ncy5wdXNoKGAke190aGlzLmdldEZvcm1hdHRlZERhdGUoKX0g5LiL5Y+R5oyH5Luk77ya5YWz6Zet5oql6K2mYCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9KVxuXHRcdCAgICB9XG5cdFx0fSxcblx0XHQvLyBUT0RPIExFROW8gOWFs+aJp+ihjOaWueazlVxuXHRcdG9uTGVkQ2hhbmdlKGV2ZW50KSB7XG5cdFx0ICAgIHZhciBfdGhpcyA9IHRoaXNcblx0XHQgICAgdmFyIHN3aXRjaFN0YXRlID0gZXZlbnQubXAuZGV0YWlsLnZhbHVlXG5cdFx0ICAgIGNvbnNvbGUubG9nKHN3aXRjaFN0YXRlKVxuXHRcdCAgICBpZiAoc3dpdGNoU3RhdGUpIHtcblx0XHQgICAgICAgIGNvbnNvbGUubG9nKFwi5LiL5Y+R5oyH5Luk77ya5byA54GvXCIpXG5cdFx0ICAgICAgICBfdGhpcy5jbGllbnQucHVibGlzaChcblx0XHQgICAgICAgICAgICAnT3BlcmF0ZS8zJyxcblx0XHQgICAgICAgICAgICAne1wiTEVEXCI6MX0nLFxuXHRcdCAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIuaIkOWKn+S4i+WPkeaMh+S7pOWIsOiuvuWkh+err++8muW8gOeBr1wiKVxuXHRcdFx0XHRcdFx0XHRfdGhpcy5sb2dzLnB1c2goYCR7X3RoaXMuZ2V0Rm9ybWF0dGVkRGF0ZSgpfSDkuIvlj5HmjIfku6TvvJrlvIDnga9gKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH0pXG5cdFx0ICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgICBjb25zb2xlLmxvZyhcIuS4i+WPkeaMh+S7pO+8muWFs+eBr1wiKVxuXHRcdCAgICAgICAgX3RoaXMuY2xpZW50LnB1Ymxpc2goXG5cdFx0ICAgICAgICAgICAgJ09wZXJhdGUvMycsXG5cdFx0ICAgICAgICAgICAgJ3tcIkxFRFwiOjB9Jyxcblx0XHQgICAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCLmiJDlip/kuIvlj5HmjIfku6TliLDorr7lpIfnq6/vvJrlhbPnga9cIilcblx0XHRcdFx0XHRcdFx0X3RoaXMubG9ncy5wdXNoKGAke190aGlzLmdldEZvcm1hdHRlZERhdGUoKX0g5LiL5Y+R5oyH5Luk77ya5YWz54GvYCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICB9KVxuXHRcdCAgICB9XG5cdFx0fVxuXHR9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/*!*********************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js ***!
  \*********************************************************************/
/*! exports provided: log, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return formatLog; });
function typof (v) {
  var s = Object.prototype.toString.call(v)
  return s.substring(8, s.length - 1)
}

function isDebugMode () {
  /* eslint-disable no-undef */
  return typeof __channelId__ === 'string' && __channelId__
}

function jsonStringifyReplacer (k, p) {
  switch (typof(p)) {
    case 'Function':
      return 'function() { [native code] }'
    default :
      return p
  }
}

function log (type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key]
  }
  console[type].apply(console, args)
}

function formatLog () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key]
  }
  var type = args.shift()
  if (isDebugMode()) {
    args.push(args.pop().replace('at ', 'uni-app:///'))
    return console[type].apply(console, args)
  }

  var msgs = args.map(function (v) {
    var type = Object.prototype.toString.call(v).toLowerCase()

    if (type === '[object object]' || type === '[object array]') {
      try {
        v = '---BEGIN:JSON---' + JSON.stringify(v, jsonStringifyReplacer) + '---END:JSON---'
      } catch (e) {
        v = type
      }
    } else {
      if (v === null) {
        v = '---NULL---'
      } else if (v === undefined) {
        v = '---UNDEFINED---'
      } else {
        var vType = typof(v).toUpperCase()

        if (vType === 'NUMBER' || vType === 'BOOLEAN') {
          v = '---BEGIN:' + vType + '---' + v + '---END:' + vType + '---'
        } else {
          v = String(v)
        }
      }
    }

    return v
  })
  var msg = ''

  if (msgs.length > 1) {
    var lastMsg = msgs.pop()
    msg = msgs.join('---COMMA---')

    if (lastMsg.indexOf(' at ') === 0) {
      msg += lastMsg
    } else {
      msg += '---COMMA---' + lastMsg
    }
  } else {
    msg = msgs[0]
  }

  console[type](msg)
}


/***/ }),
/* 13 */
/*!********************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/mqtt.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, wx, __f__) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;var _toConsumableArray = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ 23);\nvar _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ 4);\n(function (f) {\n  if (( false ? undefined : _typeof(exports)) === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var g; }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return require(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n        return n[i].exports;\n      }\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) {\n        o(t[i]);\n      }\n      return o;\n    }\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      (function (process, global) {\n        'use strict';\n\n        /**\n         * Module dependencies\n         */\n        var EventEmitter = require('events').EventEmitter;\n        var Store = require('./store');\n        var mqttPacket = require('mqtt-packet');\n        var Writable = require('readable-stream').Writable;\n        var inherits = require('inherits');\n        var reInterval = require('reinterval');\n        var validations = require('./validations');\n        var xtend = require('xtend');\n        var debug = require('debug')('mqttjs:client');\n        var setImmediate = global.setImmediate || function (callback) {\n          // works in node v0.8\n          process.nextTick(callback);\n        };\n        var defaultConnectOptions = {\n          keepalive: 60,\n          reschedulePings: true,\n          protocolId: 'MQTT',\n          protocolVersion: 4,\n          reconnectPeriod: 1000,\n          connectTimeout: 30 * 1000,\n          clean: true,\n          resubscribe: true\n        };\n        var socketErrors = ['ECONNREFUSED', 'EADDRINUSE', 'ECONNRESET', 'ENOTFOUND'];\n\n        // Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\n        var errors = {\n          0: '',\n          1: 'Unacceptable protocol version',\n          2: 'Identifier rejected',\n          3: 'Server unavailable',\n          4: 'Bad username or password',\n          5: 'Not authorized',\n          16: 'No matching subscribers',\n          17: 'No subscription existed',\n          128: 'Unspecified error',\n          129: 'Malformed Packet',\n          130: 'Protocol Error',\n          131: 'Implementation specific error',\n          132: 'Unsupported Protocol Version',\n          133: 'Client Identifier not valid',\n          134: 'Bad User Name or Password',\n          135: 'Not authorized',\n          136: 'Server unavailable',\n          137: 'Server busy',\n          138: 'Banned',\n          139: 'Server shutting down',\n          140: 'Bad authentication method',\n          141: 'Keep Alive timeout',\n          142: 'Session taken over',\n          143: 'Topic Filter invalid',\n          144: 'Topic Name invalid',\n          145: 'Packet identifier in use',\n          146: 'Packet Identifier not found',\n          147: 'Receive Maximum exceeded',\n          148: 'Topic Alias invalid',\n          149: 'Packet too large',\n          150: 'Message rate too high',\n          151: 'Quota exceeded',\n          152: 'Administrative action',\n          153: 'Payload format invalid',\n          154: 'Retain not supported',\n          155: 'QoS not supported',\n          156: 'Use another server',\n          157: 'Server moved',\n          158: 'Shared Subscriptions not supported',\n          159: 'Connection rate exceeded',\n          160: 'Maximum connect time',\n          161: 'Subscription Identifiers not supported',\n          162: 'Wildcard Subscriptions not supported'\n        };\n        function defaultId() {\n          return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n        }\n        function sendPacket(client, packet, cb) {\n          debug('sendPacket :: packet: %O', packet);\n          debug('sendPacket :: emitting `packetsend`');\n          client.emit('packetsend', packet);\n          debug('sendPacket :: writing to stream');\n          var result = mqttPacket.writeToStream(packet, client.stream, client.options);\n          debug('sendPacket :: writeToStream result %s', result);\n          if (!result && cb) {\n            debug('sendPacket :: handle events on `drain` once through callback.');\n            client.stream.once('drain', cb);\n          } else if (cb) {\n            debug('sendPacket :: invoking cb');\n            cb();\n          }\n        }\n        function flush(queue) {\n          if (queue) {\n            debug('flush: queue exists? %b', !!queue);\n            Object.keys(queue).forEach(function (messageId) {\n              if (typeof queue[messageId].cb === 'function') {\n                queue[messageId].cb(new Error('Connection closed'));\n                delete queue[messageId];\n              }\n            });\n          }\n        }\n        function flushVolatile(queue) {\n          if (queue) {\n            debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n            Object.keys(queue).forEach(function (messageId) {\n              if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n                queue[messageId].cb(new Error('Connection closed'));\n                delete queue[messageId];\n              }\n            });\n          }\n        }\n        function storeAndSend(client, packet, cb, cbStorePut) {\n          debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n          client.outgoingStore.put(packet, function storedPacket(err) {\n            if (err) {\n              return cb && cb(err);\n            }\n            cbStorePut();\n            sendPacket(client, packet, cb);\n          });\n        }\n        function nop(error) {\n          debug('nop ::', error);\n        }\n\n        /**\n         * MqttClient constructor\n         *\n         * @param {Stream} stream - stream\n         * @param {Object} [options] - connection options\n         * (see Connection#connect)\n         */\n        function MqttClient(streamBuilder, options) {\n          var k;\n          var that = this;\n          if (!(this instanceof MqttClient)) {\n            return new MqttClient(streamBuilder, options);\n          }\n          this.options = options || {};\n\n          // Defaults\n          for (k in defaultConnectOptions) {\n            if (typeof this.options[k] === 'undefined') {\n              this.options[k] = defaultConnectOptions[k];\n            } else {\n              this.options[k] = options[k];\n            }\n          }\n          debug('MqttClient :: options.protocol', options.protocol);\n          debug('MqttClient :: options.protocolVersion', options.protocolVersion);\n          debug('MqttClient :: options.username', options.username);\n          debug('MqttClient :: options.keepalive', options.keepalive);\n          debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n          debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n          this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n          debug('MqttClient :: clientId', this.options.clientId);\n          this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n            arguments[3](0);\n          };\n          this.streamBuilder = streamBuilder;\n\n          // Inflight message storages\n          this.outgoingStore = options.outgoingStore || new Store();\n          this.incomingStore = options.incomingStore || new Store();\n\n          // Should QoS zero messages be queued when the connection is broken?\n          this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero;\n\n          // map of subscribed topics to support reconnection\n          this._resubscribeTopics = {};\n\n          // map of a subscribe messageId and a topic\n          this.messageIdToTopic = {};\n\n          // Ping timer, setup in _setupPingTimer\n          this.pingTimer = null;\n          // Is the client connected?\n          this.connected = false;\n          // Are we disconnecting?\n          this.disconnecting = false;\n          // Packet queue\n          this.queue = [];\n          // connack timer\n          this.connackTimer = null;\n          // Reconnect timer\n          this.reconnectTimer = null;\n          // Is processing store?\n          this._storeProcessing = false;\n          // Packet Ids are put into the store during store processing\n          this._packetIdsDuringStoreProcessing = {};\n          /**\n           * MessageIDs starting with 1\n           * ensure that nextId is min. 1, see https://github.com/mqttjs/MQTT.js/issues/810\n           */\n          this.nextId = Math.max(1, Math.floor(Math.random() * 65535));\n\n          // Inflight callbacks\n          this.outgoing = {};\n\n          // True if connection is first time.\n          this._firstConnection = true;\n\n          // Send queued packets\n          this.on('connect', function () {\n            var queue = this.queue;\n            function deliver() {\n              var entry = queue.shift();\n              debug('deliver :: entry %o', entry);\n              var packet = null;\n              if (!entry) {\n                return;\n              }\n              packet = entry.packet;\n              debug('deliver :: call _sendPacket for %o', packet);\n              that._sendPacket(packet, function (err) {\n                if (entry.cb) {\n                  entry.cb(err);\n                }\n                deliver();\n              });\n            }\n            debug('connect :: sending queued packets');\n            deliver();\n          });\n          this.on('close', function () {\n            debug('close :: connected set to `false`');\n            this.connected = false;\n            debug('close :: clearing connackTimer');\n            clearTimeout(this.connackTimer);\n            debug('close :: clearing ping timer');\n            if (that.pingTimer !== null) {\n              that.pingTimer.clear();\n              that.pingTimer = null;\n            }\n            debug('close :: calling _setupReconnect');\n            this._setupReconnect();\n          });\n          EventEmitter.call(this);\n          debug('MqttClient :: setting up stream');\n          this._setupStream();\n        }\n        inherits(MqttClient, EventEmitter);\n\n        /**\n         * setup the event handlers in the inner stream.\n         *\n         * @api private\n         */\n        MqttClient.prototype._setupStream = function () {\n          var _this3 = this;\n          var connectPacket;\n          var that = this;\n          var writable = new Writable();\n          var parser = mqttPacket.parser(this.options);\n          var completeParse = null;\n          var packets = [];\n          debug('_setupStream :: calling method to clear reconnect');\n          this._clearReconnect();\n          debug('_setupStream :: using streamBuilder provided to client to create stream');\n          this.stream = this.streamBuilder(this);\n          parser.on('packet', function (packet) {\n            debug('parser :: on packet push to packets array.');\n            packets.push(packet);\n          });\n          function nextTickWork() {\n            if (packets.length) {\n              process.nextTick(work);\n            } else {\n              var done = completeParse;\n              completeParse = null;\n              done();\n            }\n          }\n          function work() {\n            debug('work :: getting next packet in queue');\n            var packet = packets.shift();\n            if (packet) {\n              debug('work :: packet pulled from queue');\n              that._handlePacket(packet, nextTickWork);\n            } else {\n              debug('work :: no packets in queue');\n              var done = completeParse;\n              completeParse = null;\n              debug('work :: done flag is %s', !!done);\n              if (done) done();\n            }\n          }\n          writable._write = function (buf, enc, done) {\n            completeParse = done;\n            debug('writable stream :: parsing buffer');\n            parser.parse(buf);\n            work();\n          };\n          function streamErrorHandler(error) {\n            debug('streamErrorHandler :: error', error.message);\n            if (socketErrors.includes(error.code)) {\n              // handle error\n              debug('streamErrorHandler :: emitting error');\n              that.emit('error', error);\n            } else {\n              nop(error);\n            }\n          }\n          debug('_setupStream :: pipe stream to writable stream');\n          this.stream.pipe(writable);\n\n          // Suppress connection errors\n          this.stream.on('error', streamErrorHandler);\n\n          // Echo stream close\n          this.stream.on('close', function () {\n            debug('(%s)stream :: on close', that.options.clientId);\n            flushVolatile(that.outgoing);\n            debug('stream: emit close to MqttClient');\n            that.emit('close');\n          });\n\n          // Send a connect packet\n          debug('_setupStream: sending packet `connect`');\n          connectPacket = Object.create(this.options);\n          connectPacket.cmd = 'connect';\n          // avoid message queue\n          sendPacket(this, connectPacket);\n\n          // Echo connection errors\n          parser.on('error', this.emit.bind(this, 'error'));\n\n          // auth\n          if (this.options.properties) {\n            if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n              that.end(function () {\n                return _this3.emit('error', new Error('Packet has no Authentication Method'));\n              });\n              return this;\n            }\n            if (this.options.properties.authenticationMethod && this.options.authPacket && _typeof(this.options.authPacket) === 'object') {\n              var authPacket = xtend({\n                cmd: 'auth',\n                reasonCode: 0\n              }, this.options.authPacket);\n              sendPacket(this, authPacket);\n            }\n          }\n\n          // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n          this.stream.setMaxListeners(1000);\n          clearTimeout(this.connackTimer);\n          this.connackTimer = setTimeout(function () {\n            debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n            that._cleanUp(true);\n          }, this.options.connectTimeout);\n        };\n        MqttClient.prototype._handlePacket = function (packet, done) {\n          var options = this.options;\n          if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n            this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n            this.end({\n              reasonCode: 149,\n              properties: {\n                reasonString: 'Maximum packet size was exceeded'\n              }\n            });\n            return this;\n          }\n          debug('_handlePacket :: emitting packetreceive');\n          this.emit('packetreceive', packet);\n          switch (packet.cmd) {\n            case 'publish':\n              this._handlePublish(packet, done);\n              break;\n            case 'puback':\n            case 'pubrec':\n            case 'pubcomp':\n            case 'suback':\n            case 'unsuback':\n              this._handleAck(packet);\n              done();\n              break;\n            case 'pubrel':\n              this._handlePubrel(packet, done);\n              break;\n            case 'connack':\n              this._handleConnack(packet);\n              done();\n              break;\n            case 'pingresp':\n              this._handlePingresp(packet);\n              done();\n              break;\n            case 'disconnect':\n              this._handleDisconnect(packet);\n              done();\n              break;\n            default:\n              // do nothing\n              // maybe we should do an error handling\n              // or just log it\n              break;\n          }\n        };\n        MqttClient.prototype._checkDisconnecting = function (callback) {\n          if (this.disconnecting) {\n            if (callback) {\n              callback(new Error('client disconnecting'));\n            } else {\n              this.emit('error', new Error('client disconnecting'));\n            }\n          }\n          return this.disconnecting;\n        };\n\n        /**\n         * publish - publish <message> to <topic>\n         *\n         * @param {String} topic - topic to publish to\n         * @param {String, Buffer} message - message to publish\n         * @param {Object} [opts] - publish options, includes:\n         *    {Number} qos - qos level to publish on\n         *    {Boolean} retain - whether or not to retain the message\n         *    {Boolean} dup - whether or not mark a message as duplicate\n         *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n         * @param {Function} [callback] - function(err){}\n         *    called when publish succeeds or fails\n         * @returns {MqttClient} this - for chaining\n         * @api public\n         *\n         * @example client.publish('topic', 'message');\n         * @example\n         *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n         * @example client.publish('topic', 'message', console.log);\n         */\n        MqttClient.prototype.publish = function (topic, message, opts, callback) {\n          debug('publish :: message `%s` to topic `%s`', message, topic);\n          var packet;\n          var options = this.options;\n\n          // .publish(topic, payload, cb);\n          if (typeof opts === 'function') {\n            callback = opts;\n            opts = null;\n          }\n\n          // default opts\n          var defaultOpts = {\n            qos: 0,\n            retain: false,\n            dup: false\n          };\n          opts = xtend(defaultOpts, opts);\n          if (this._checkDisconnecting(callback)) {\n            return this;\n          }\n          packet = {\n            cmd: 'publish',\n            topic: topic,\n            payload: message,\n            qos: opts.qos,\n            retain: opts.retain,\n            messageId: this._nextId(),\n            dup: opts.dup\n          };\n          if (options.protocolVersion === 5) {\n            packet.properties = opts.properties;\n            if (!options.properties && packet.properties && packet.properties.topicAlias || opts.properties && options.properties && (opts.properties.topicAlias && options.properties.topicAliasMaximum && opts.properties.topicAlias > options.properties.topicAliasMaximum || !options.properties.topicAliasMaximum && opts.properties.topicAlias)) {\n              /*\n              if we are don`t setup topic alias or\n              topic alias maximum less than topic alias or\n              server don`t give topic alias maximum,\n              we are removing topic alias from packet\n              */\n              delete packet.properties.topicAlias;\n            }\n          }\n          debug('publish :: qos', opts.qos);\n          switch (opts.qos) {\n            case 1:\n            case 2:\n              // Add to callbacks\n              this.outgoing[packet.messageId] = {\n                volatile: false,\n                cb: callback || nop\n              };\n              if (this._storeProcessing) {\n                debug('_storeProcessing enabled');\n                this._packetIdsDuringStoreProcessing[packet.messageId] = false;\n                this._storePacket(packet, undefined, opts.cbStorePut);\n              } else {\n                debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n                this._sendPacket(packet, undefined, opts.cbStorePut);\n              }\n              break;\n            default:\n              if (this._storeProcessing) {\n                debug('_storeProcessing enabled');\n                this._storePacket(packet, callback, opts.cbStorePut);\n              } else {\n                debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n                this._sendPacket(packet, callback, opts.cbStorePut);\n              }\n              break;\n          }\n          return this;\n        };\n\n        /**\n         * subscribe - subscribe to <topic>\n         *\n         * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n         * @param {Object} [opts] - optional subscription options, includes:\n         *    {Number} qos - subscribe qos level\n         * @param {Function} [callback] - function(err, granted){} where:\n         *    {Error} err - subscription error (none at the moment!)\n         *    {Array} granted - array of {topic: 't', qos: 0}\n         * @returns {MqttClient} this - for chaining\n         * @api public\n         * @example client.subscribe('topic');\n         * @example client.subscribe('topic', {qos: 1});\n         * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n         * @example client.subscribe('topic', console.log);\n         */\n        MqttClient.prototype.subscribe = function () {\n          var packet;\n          var args = new Array(arguments.length);\n          for (var i = 0; i < arguments.length; i++) {\n            args[i] = arguments[i];\n          }\n          var subs = [];\n          var obj = args.shift();\n          var resubscribe = obj.resubscribe;\n          var callback = args.pop() || nop;\n          var opts = args.pop();\n          var invalidTopic;\n          var that = this;\n          var version = this.options.protocolVersion;\n          delete obj.resubscribe;\n          if (typeof obj === 'string') {\n            obj = [obj];\n          }\n          if (typeof callback !== 'function') {\n            opts = callback;\n            callback = nop;\n          }\n          invalidTopic = validations.validateTopics(obj);\n          if (invalidTopic !== null) {\n            setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n            return this;\n          }\n          if (this._checkDisconnecting(callback)) {\n            debug('subscribe: discconecting true');\n            return this;\n          }\n          var defaultOpts = {\n            qos: 0\n          };\n          if (version === 5) {\n            defaultOpts.nl = false;\n            defaultOpts.rap = false;\n            defaultOpts.rh = 0;\n          }\n          opts = xtend(defaultOpts, opts);\n          if (Array.isArray(obj)) {\n            obj.forEach(function (topic) {\n              debug('subscribe: array topic %s', topic);\n              if (!that._resubscribeTopics.hasOwnProperty(topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n                var currentOpts = {\n                  topic: topic,\n                  qos: opts.qos\n                };\n                if (version === 5) {\n                  currentOpts.nl = opts.nl;\n                  currentOpts.rap = opts.rap;\n                  currentOpts.rh = opts.rh;\n                  currentOpts.properties = opts.properties;\n                }\n                debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n                subs.push(currentOpts);\n              }\n            });\n          } else {\n            Object.keys(obj).forEach(function (k) {\n              debug('subscribe: object topic %s', k);\n              if (!that._resubscribeTopics.hasOwnProperty(k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n                var currentOpts = {\n                  topic: k,\n                  qos: obj[k].qos\n                };\n                if (version === 5) {\n                  currentOpts.nl = obj[k].nl;\n                  currentOpts.rap = obj[k].rap;\n                  currentOpts.rh = obj[k].rh;\n                  currentOpts.properties = opts.properties;\n                }\n                debug('subscribe: pushing `%s` to subs list', currentOpts);\n                subs.push(currentOpts);\n              }\n            });\n          }\n          packet = {\n            cmd: 'subscribe',\n            subscriptions: subs,\n            qos: 1,\n            retain: false,\n            dup: false,\n            messageId: this._nextId()\n          };\n          if (opts.properties) {\n            packet.properties = opts.properties;\n          }\n          if (!subs.length) {\n            callback(null, []);\n            return;\n          }\n\n          // subscriptions to resubscribe to in case of disconnect\n          if (this.options.resubscribe) {\n            debug('subscribe :: resubscribe true');\n            var topics = [];\n            subs.forEach(function (sub) {\n              if (that.options.reconnectPeriod > 0) {\n                var topic = {\n                  qos: sub.qos\n                };\n                if (version === 5) {\n                  topic.nl = sub.nl || false;\n                  topic.rap = sub.rap || false;\n                  topic.rh = sub.rh || 0;\n                  topic.properties = sub.properties;\n                }\n                that._resubscribeTopics[sub.topic] = topic;\n                topics.push(sub.topic);\n              }\n            });\n            that.messageIdToTopic[packet.messageId] = topics;\n          }\n          this.outgoing[packet.messageId] = {\n            volatile: true,\n            cb: function cb(err, packet) {\n              if (!err) {\n                var granted = packet.granted;\n                for (var i = 0; i < granted.length; i += 1) {\n                  subs[i].qos = granted[i];\n                }\n              }\n              callback(err, subs);\n            }\n          };\n          debug('subscribe :: call _sendPacket');\n          this._sendPacket(packet);\n          return this;\n        };\n\n        /**\n         * unsubscribe - unsubscribe from topic(s)\n         *\n         * @param {String, Array} topic - topics to unsubscribe from\n         * @param {Object} [opts] - optional subscription options, includes:\n         *    {Object} properties - properties of unsubscribe packet\n         * @param {Function} [callback] - callback fired on unsuback\n         * @returns {MqttClient} this - for chaining\n         * @api public\n         * @example client.unsubscribe('topic');\n         * @example client.unsubscribe('topic', console.log);\n         */\n        MqttClient.prototype.unsubscribe = function () {\n          var packet = {\n            cmd: 'unsubscribe',\n            qos: 1,\n            messageId: this._nextId()\n          };\n          var that = this;\n          var args = new Array(arguments.length);\n          for (var i = 0; i < arguments.length; i++) {\n            args[i] = arguments[i];\n          }\n          var topic = args.shift();\n          var callback = args.pop() || nop;\n          var opts = args.pop();\n          if (typeof topic === 'string') {\n            topic = [topic];\n          }\n          if (typeof callback !== 'function') {\n            opts = callback;\n            callback = nop;\n          }\n          if (this._checkDisconnecting(callback)) {\n            return this;\n          }\n          if (typeof topic === 'string') {\n            packet.unsubscriptions = [topic];\n          } else if (Array.isArray(topic)) {\n            packet.unsubscriptions = topic;\n          }\n          if (this.options.resubscribe) {\n            packet.unsubscriptions.forEach(function (topic) {\n              delete that._resubscribeTopics[topic];\n            });\n          }\n          if (_typeof(opts) === 'object' && opts.properties) {\n            packet.properties = opts.properties;\n          }\n          this.outgoing[packet.messageId] = {\n            volatile: true,\n            cb: callback\n          };\n          debug('unsubscribe: call _sendPacket');\n          this._sendPacket(packet);\n          return this;\n        };\n\n        /**\n         * end - close connection\n         *\n         * @returns {MqttClient} this - for chaining\n         * @param {Boolean} force - do not wait for all in-flight messages to be acked\n         * @param {Function} cb - called when the client has been closed\n         *\n         * @api public\n         */\n        MqttClient.prototype.end = function (force, opts, cb) {\n          var that = this;\n          debug('end :: (%s)', this.options.clientId);\n          if (force == null || typeof force !== 'boolean') {\n            cb = opts || nop;\n            opts = force;\n            force = false;\n            if (_typeof(opts) !== 'object') {\n              cb = opts;\n              opts = null;\n              if (typeof cb !== 'function') {\n                cb = nop;\n              }\n            }\n          }\n          if (_typeof(opts) !== 'object') {\n            cb = opts;\n            opts = null;\n          }\n          debug('end :: cb? %s', !!cb);\n          cb = cb || nop;\n          function closeStores() {\n            debug('end :: closeStores: closing incoming and outgoing stores');\n            that.disconnected = true;\n            that.incomingStore.close(function () {\n              that.outgoingStore.close(function () {\n                debug('end :: closeStores: emitting end');\n                that.emit('end');\n                if (cb) {\n                  debug('end :: closeStores: invoking callback with args');\n                  cb();\n                }\n              });\n            });\n            if (that._deferredReconnect) {\n              that._deferredReconnect();\n            }\n          }\n          function finish() {\n            // defer closesStores of an I/O cycle,\n            // just to make sure things are\n            // ok for websockets\n            debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force);\n            that._cleanUp(force, function () {\n              debug('end :: finish :: calling process.nextTick on closeStores');\n              // var boundProcess = process.nextTick.bind(null, closeStores)\n              process.nextTick(closeStores.bind(that));\n            }, opts);\n          }\n          if (this.disconnecting) {\n            cb();\n            return this;\n          }\n          this._clearReconnect();\n          this.disconnecting = true;\n          if (!force && Object.keys(this.outgoing).length > 0) {\n            // wait 10ms, just to be sure we received all of it\n            debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId);\n            this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n          } else {\n            debug('end :: (%s) :: immediately calling finish', that.options.clientId);\n            finish();\n          }\n          return this;\n        };\n\n        /**\n         * removeOutgoingMessage - remove a message in outgoing store\n         * the outgoing callback will be called withe Error('Message removed') if the message is removed\n         *\n         * @param {Number} messageId - messageId to remove message\n         * @returns {MqttClient} this - for chaining\n         * @api public\n         *\n         * @example client.removeOutgoingMessage(client.getLastMessageId());\n         */\n        MqttClient.prototype.removeOutgoingMessage = function (messageId) {\n          var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n          delete this.outgoing[messageId];\n          this.outgoingStore.del({\n            messageId: messageId\n          }, function () {\n            cb(new Error('Message removed'));\n          });\n          return this;\n        };\n\n        /**\n         * reconnect - connect again using the same options as connect()\n         *\n         * @param {Object} [opts] - optional reconnect options, includes:\n         *    {Store} incomingStore - a store for the incoming packets\n         *    {Store} outgoingStore - a store for the outgoing packets\n         *    if opts is not given, current stores are used\n         * @returns {MqttClient} this - for chaining\n         *\n         * @api public\n         */\n        MqttClient.prototype.reconnect = function (opts) {\n          debug('client reconnect');\n          var that = this;\n          var f = function f() {\n            if (opts) {\n              that.options.incomingStore = opts.incomingStore;\n              that.options.outgoingStore = opts.outgoingStore;\n            } else {\n              that.options.incomingStore = null;\n              that.options.outgoingStore = null;\n            }\n            that.incomingStore = that.options.incomingStore || new Store();\n            that.outgoingStore = that.options.outgoingStore || new Store();\n            that.disconnecting = false;\n            that.disconnected = false;\n            that._deferredReconnect = null;\n            that._reconnect();\n          };\n          if (this.disconnecting && !this.disconnected) {\n            this._deferredReconnect = f;\n          } else {\n            f();\n          }\n          return this;\n        };\n\n        /**\n         * _reconnect - implement reconnection\n         * @api privateish\n         */\n        MqttClient.prototype._reconnect = function () {\n          debug('_reconnect: emitting reconnect to client');\n          this.emit('reconnect');\n          debug('_reconnect: calling _setupStream');\n          this._setupStream();\n        };\n\n        /**\n         * _setupReconnect - setup reconnect timer\n         */\n        MqttClient.prototype._setupReconnect = function () {\n          var that = this;\n          if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n            if (!this.reconnecting) {\n              debug('_setupReconnect :: emit `offline` state');\n              this.emit('offline');\n              debug('_setupReconnect :: set `reconnecting` to `true`');\n              this.reconnecting = true;\n            }\n            debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod);\n            that.reconnectTimer = setInterval(function () {\n              debug('reconnectTimer :: reconnect triggered!');\n              that._reconnect();\n            }, that.options.reconnectPeriod);\n          } else {\n            debug('_setupReconnect :: doing nothing...');\n          }\n        };\n\n        /**\n         * _clearReconnect - clear the reconnect timer\n         */\n        MqttClient.prototype._clearReconnect = function () {\n          debug('_clearReconnect : clearing reconnect timer');\n          if (this.reconnectTimer) {\n            clearInterval(this.reconnectTimer);\n            this.reconnectTimer = null;\n          }\n        };\n\n        /**\n         * _cleanUp - clean up on connection end\n         * @api private\n         */\n        MqttClient.prototype._cleanUp = function (forced, done) {\n          var opts = arguments[2];\n          if (done) {\n            debug('_cleanUp :: done callback provided for on stream close');\n            this.stream.on('close', done);\n          }\n          debug('_cleanUp :: forced? %s', forced);\n          if (forced) {\n            if (this.options.reconnectPeriod === 0 && this.options.clean) {\n              flush(this.outgoing);\n            }\n            debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n            this.stream.destroy();\n          } else {\n            var packet = xtend({\n              cmd: 'disconnect'\n            }, opts);\n            debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n            this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n          }\n          if (!this.disconnecting) {\n            debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n            this._clearReconnect();\n            this._setupReconnect();\n          }\n          if (this.pingTimer !== null) {\n            debug('_cleanUp :: clearing pingTimer');\n            this.pingTimer.clear();\n            this.pingTimer = null;\n          }\n          if (done && !this.connected) {\n            debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n            this.stream.removeListener('close', done);\n            done();\n          }\n        };\n\n        /**\n         * _sendPacket - send or queue a packet\n         * @param {Object} packet - packet options\n         * @param {Function} cb - callback when the packet is sent\n         * @param {Function} cbStorePut - called when message is put into outgoingStore\n         * @api private\n         */\n        MqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n          debug('_sendPacket :: (%s) ::  start', this.options.clientId);\n          cbStorePut = cbStorePut || nop;\n          if (!this.connected) {\n            debug('_sendPacket :: client not connected. Storing packet offline.');\n            this._storePacket(packet, cb, cbStorePut);\n            return;\n          }\n\n          // When sending a packet, reschedule the ping timer\n          this._shiftPingInterval();\n          switch (packet.cmd) {\n            case 'publish':\n              break;\n            case 'pubrel':\n              storeAndSend(this, packet, cb, cbStorePut);\n              return;\n            default:\n              sendPacket(this, packet, cb);\n              return;\n          }\n          switch (packet.qos) {\n            case 2:\n            case 1:\n              storeAndSend(this, packet, cb, cbStorePut);\n              break;\n            /**\n             * no need of case here since it will be caught by default\n             * and jshint comply that before default it must be a break\n             * anyway it will result in -1 evaluation\n             */\n            case 0:\n            /* falls through */\n            default:\n              sendPacket(this, packet, cb);\n              break;\n          }\n          debug('_sendPacket :: (%s) ::  end', this.options.clientId);\n        };\n\n        /**\n         * _storePacket - queue a packet\n         * @param {Object} packet - packet options\n         * @param {Function} cb - callback when the packet is sent\n         * @param {Function} cbStorePut - called when message is put into outgoingStore\n         * @api private\n         */\n        MqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n          debug('_storePacket :: packet: %o', packet);\n          debug('_storePacket :: cb? %s', !!cb);\n          cbStorePut = cbStorePut || nop;\n\n          // check that the packet is not a qos of 0, or that the command is not a publish\n          if ((packet.qos || 0) === 0 && this.queueQoSZero || packet.cmd !== 'publish') {\n            this.queue.push({\n              packet: packet,\n              cb: cb\n            });\n          } else if (packet.qos > 0) {\n            cb = this.outgoing[packet.messageId] ? this.outgoing[packet.messageId].cb : null;\n            this.outgoingStore.put(packet, function (err) {\n              if (err) {\n                return cb && cb(err);\n              }\n              cbStorePut();\n            });\n          } else if (cb) {\n            cb(new Error('No connection to broker'));\n          }\n        };\n\n        /**\n         * _setupPingTimer - setup the ping timer\n         *\n         * @api private\n         */\n        MqttClient.prototype._setupPingTimer = function () {\n          debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n          var that = this;\n          if (!this.pingTimer && this.options.keepalive) {\n            this.pingResp = true;\n            this.pingTimer = reInterval(function () {\n              that._checkPing();\n            }, this.options.keepalive * 1000);\n          }\n        };\n\n        /**\n         * _shiftPingInterval - reschedule the ping interval\n         *\n         * @api private\n         */\n        MqttClient.prototype._shiftPingInterval = function () {\n          if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n            this.pingTimer.reschedule(this.options.keepalive * 1000);\n          }\n        };\n        /**\n         * _checkPing - check if a pingresp has come back, and ping the server again\n         *\n         * @api private\n         */\n        MqttClient.prototype._checkPing = function () {\n          debug('_checkPing :: checking ping...');\n          if (this.pingResp) {\n            debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n            this.pingResp = false;\n            this._sendPacket({\n              cmd: 'pingreq'\n            });\n          } else {\n            // do a forced cleanup since socket will be in bad shape\n            debug('_checkPing :: calling _cleanUp with force true');\n            this._cleanUp(true);\n          }\n        };\n\n        /**\n         * _handlePingresp - handle a pingresp\n         *\n         * @api private\n         */\n        MqttClient.prototype._handlePingresp = function () {\n          this.pingResp = true;\n        };\n\n        /**\n         * _handleConnack\n         *\n         * @param {Object} packet\n         * @api private\n         */\n        MqttClient.prototype._handleConnack = function (packet) {\n          debug('_handleConnack');\n          var options = this.options;\n          var version = options.protocolVersion;\n          var rc = version === 5 ? packet.reasonCode : packet.returnCode;\n          clearTimeout(this.connackTimer);\n          if (packet.properties) {\n            if (packet.properties.topicAliasMaximum) {\n              if (!options.properties) {\n                options.properties = {};\n              }\n              options.properties.topicAliasMaximum = packet.properties.topicAliasMaximum;\n            }\n            if (packet.properties.serverKeepAlive && options.keepalive) {\n              options.keepalive = packet.properties.serverKeepAlive;\n              this._shiftPingInterval();\n            }\n            if (packet.properties.maximumPacketSize) {\n              if (!options.properties) {\n                options.properties = {};\n              }\n              options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n            }\n          }\n          if (rc === 0) {\n            this.reconnecting = false;\n            this._onConnect(packet);\n          } else if (rc > 0) {\n            var err = new Error('Connection refused: ' + errors[rc]);\n            err.code = rc;\n            this.emit('error', err);\n          }\n        };\n\n        /**\n         * _handlePublish\n         *\n         * @param {Object} packet\n         * @api private\n         */\n        /*\n        those late 2 case should be rewrite to comply with coding style:\n        \n        case 1:\n        case 0:\n          // do not wait sending a puback\n          // no callback passed\n          if (1 === qos) {\n            this._sendPacket({\n              cmd: 'puback',\n              messageId: messageId\n            });\n          }\n          // emit the message event for both qos 1 and 0\n          this.emit('message', topic, message, packet);\n          this.handleMessage(packet, done);\n          break;\n        default:\n          // do nothing but every switch mus have a default\n          // log or throw an error about unknown qos\n          break;\n        \n        for now i just suppressed the warnings\n        */\n        MqttClient.prototype._handlePublish = function (packet, done) {\n          debug('_handlePublish: packet %o', packet);\n          done = typeof done !== 'undefined' ? done : nop;\n          var topic = packet.topic.toString();\n          var message = packet.payload;\n          var qos = packet.qos;\n          var messageId = packet.messageId;\n          var that = this;\n          var options = this.options;\n          var validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n          debug('_handlePublish: qos %d', qos);\n          switch (qos) {\n            case 2:\n              {\n                options.customHandleAcks(topic, message, packet, function (error, code) {\n                  if (!(error instanceof Error)) {\n                    code = error;\n                    error = null;\n                  }\n                  if (error) {\n                    return that.emit('error', error);\n                  }\n                  if (validReasonCodes.indexOf(code) === -1) {\n                    return that.emit('error', new Error('Wrong reason code for pubrec'));\n                  }\n                  if (code) {\n                    that._sendPacket({\n                      cmd: 'pubrec',\n                      messageId: messageId,\n                      reasonCode: code\n                    }, done);\n                  } else {\n                    that.incomingStore.put(packet, function () {\n                      that._sendPacket({\n                        cmd: 'pubrec',\n                        messageId: messageId\n                      }, done);\n                    });\n                  }\n                });\n                break;\n              }\n            case 1:\n              {\n                // emit the message event\n                options.customHandleAcks(topic, message, packet, function (error, code) {\n                  if (!(error instanceof Error)) {\n                    code = error;\n                    error = null;\n                  }\n                  if (error) {\n                    return that.emit('error', error);\n                  }\n                  if (validReasonCodes.indexOf(code) === -1) {\n                    return that.emit('error', new Error('Wrong reason code for puback'));\n                  }\n                  if (!code) {\n                    that.emit('message', topic, message, packet);\n                  }\n                  that.handleMessage(packet, function (err) {\n                    if (err) {\n                      return done && done(err);\n                    }\n                    that._sendPacket({\n                      cmd: 'puback',\n                      messageId: messageId,\n                      reasonCode: code\n                    }, done);\n                  });\n                });\n                break;\n              }\n            case 0:\n              // emit the message event\n              this.emit('message', topic, message, packet);\n              this.handleMessage(packet, done);\n              break;\n            default:\n              // do nothing\n              debug('_handlePublish: unknown QoS. Doing nothing.');\n              // log or throw an error about unknown qos\n              break;\n          }\n        };\n\n        /**\n         * Handle messages with backpressure support, one at a time.\n         * Override at will.\n         *\n         * @param Packet packet the packet\n         * @param Function callback call when finished\n         * @api public\n         */\n        MqttClient.prototype.handleMessage = function (packet, callback) {\n          callback();\n        };\n\n        /**\n         * _handleAck\n         *\n         * @param {Object} packet\n         * @api private\n         */\n\n        MqttClient.prototype._handleAck = function (packet) {\n          /* eslint no-fallthrough: \"off\" */\n          var messageId = packet.messageId;\n          var type = packet.cmd;\n          var response = null;\n          var cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n          var that = this;\n          var err;\n          if (!cb) {\n            debug('_handleAck :: Server sent an ack in error. Ignoring.');\n            // Server sent an ack in error, ignore it.\n            return;\n          }\n\n          // Process\n          debug('_handleAck :: packet type', type);\n          switch (type) {\n            case 'pubcomp':\n            // same thing as puback for QoS 2\n            case 'puback':\n              var pubackRC = packet.reasonCode;\n              // Callback - we're done\n              if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n                err = new Error('Publish error: ' + errors[pubackRC]);\n                err.code = pubackRC;\n                cb(err, packet);\n              }\n              delete this.outgoing[messageId];\n              this.outgoingStore.del(packet, cb);\n              break;\n            case 'pubrec':\n              response = {\n                cmd: 'pubrel',\n                qos: 2,\n                messageId: messageId\n              };\n              var pubrecRC = packet.reasonCode;\n              if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n                err = new Error('Publish error: ' + errors[pubrecRC]);\n                err.code = pubrecRC;\n                cb(err, packet);\n              } else {\n                this._sendPacket(response);\n              }\n              break;\n            case 'suback':\n              delete this.outgoing[messageId];\n              for (var grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n                if ((packet.granted[grantedI] & 0x80) !== 0) {\n                  // suback with Failure status\n                  var topics = this.messageIdToTopic[messageId];\n                  if (topics) {\n                    topics.forEach(function (topic) {\n                      delete that._resubscribeTopics[topic];\n                    });\n                  }\n                }\n              }\n              cb(null, packet);\n              break;\n            case 'unsuback':\n              delete this.outgoing[messageId];\n              cb(null);\n              break;\n            default:\n              that.emit('error', new Error('unrecognized packet type'));\n          }\n          if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n            this.emit('outgoingEmpty');\n          }\n        };\n\n        /**\n         * _handlePubrel\n         *\n         * @param {Object} packet\n         * @api private\n         */\n        MqttClient.prototype._handlePubrel = function (packet, callback) {\n          debug('handling pubrel packet');\n          callback = typeof callback !== 'undefined' ? callback : nop;\n          var messageId = packet.messageId;\n          var that = this;\n          var comp = {\n            cmd: 'pubcomp',\n            messageId: messageId\n          };\n          that.incomingStore.get(packet, function (err, pub) {\n            if (!err) {\n              that.emit('message', pub.topic, pub.payload, pub);\n              that.handleMessage(pub, function (err) {\n                if (err) {\n                  return callback(err);\n                }\n                that.incomingStore.del(pub, nop);\n                that._sendPacket(comp, callback);\n              });\n            } else {\n              that._sendPacket(comp, callback);\n            }\n          });\n        };\n\n        /**\n         * _handleDisconnect\n         *\n         * @param {Object} packet\n         * @api private\n         */\n        MqttClient.prototype._handleDisconnect = function (packet) {\n          this.emit('disconnect', packet);\n        };\n\n        /**\n         * _nextId\n         * @return unsigned int\n         */\n        MqttClient.prototype._nextId = function () {\n          // id becomes current state of this.nextId and increments afterwards\n          var id = this.nextId++;\n          // Ensure 16 bit unsigned int (max 65535, nextId got one higher)\n          if (this.nextId === 65536) {\n            this.nextId = 1;\n          }\n          return id;\n        };\n\n        /**\n         * getLastMessageId\n         * @return unsigned int\n         */\n        MqttClient.prototype.getLastMessageId = function () {\n          return this.nextId === 1 ? 65535 : this.nextId - 1;\n        };\n\n        /**\n         * _resubscribe\n         * @api private\n         */\n        MqttClient.prototype._resubscribe = function (connack) {\n          debug('_resubscribe');\n          var _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n          if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !connack.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n            if (this.options.resubscribe) {\n              if (this.options.protocolVersion === 5) {\n                debug('_resubscribe: protocolVersion 5');\n                for (var topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n                  var resubscribeTopic = {};\n                  resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n                  resubscribeTopic.resubscribe = true;\n                  this.subscribe(resubscribeTopic, {\n                    properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n                  });\n                }\n              } else {\n                this._resubscribeTopics.resubscribe = true;\n                this.subscribe(this._resubscribeTopics);\n              }\n            } else {\n              this._resubscribeTopics = {};\n            }\n          }\n          this._firstConnection = false;\n        };\n\n        /**\n         * _onConnect\n         *\n         * @api private\n         */\n        MqttClient.prototype._onConnect = function (packet) {\n          if (this.disconnected) {\n            this.emit('connect', packet);\n            return;\n          }\n          var that = this;\n          this._setupPingTimer();\n          this._resubscribe(packet);\n          this.connected = true;\n          function startStreamProcess() {\n            var outStore = that.outgoingStore.createStream();\n            function clearStoreProcessing() {\n              that._storeProcessing = false;\n              that._packetIdsDuringStoreProcessing = {};\n            }\n            that.once('close', remove);\n            outStore.on('error', function (err) {\n              clearStoreProcessing();\n              that.removeListener('close', remove);\n              that.emit('error', err);\n            });\n            function remove() {\n              outStore.destroy();\n              outStore = null;\n              clearStoreProcessing();\n            }\n            function storeDeliver() {\n              // edge case, we wrapped this twice\n              if (!outStore) {\n                return;\n              }\n              that._storeProcessing = true;\n              var packet = outStore.read(1);\n              var _cb;\n              if (!packet) {\n                // read when data is available in the future\n                outStore.once('readable', storeDeliver);\n                return;\n              }\n\n              // Skip already processed store packets\n              if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n                storeDeliver();\n                return;\n              }\n\n              // Avoid unnecessary stream read operations when disconnected\n              if (!that.disconnecting && !that.reconnectTimer) {\n                _cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n                that.outgoing[packet.messageId] = {\n                  volatile: false,\n                  cb: function cb(err, status) {\n                    // Ensure that the original callback passed in to publish gets invoked\n                    if (_cb) {\n                      _cb(err, status);\n                    }\n                    storeDeliver();\n                  }\n                };\n                that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n                that._sendPacket(packet);\n              } else if (outStore.destroy) {\n                outStore.destroy();\n              }\n            }\n            outStore.on('end', function () {\n              var allProcessed = true;\n              for (var id in that._packetIdsDuringStoreProcessing) {\n                if (!that._packetIdsDuringStoreProcessing[id]) {\n                  allProcessed = false;\n                  break;\n                }\n              }\n              if (allProcessed) {\n                clearStoreProcessing();\n                that.removeListener('close', remove);\n                that.emit('connect', packet);\n              } else {\n                startStreamProcess();\n              }\n            });\n            storeDeliver();\n          }\n          // start flowing\n          startStreamProcess();\n        };\n        module.exports = MqttClient;\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./store\": 7,\n      \"./validations\": 8,\n      \"_process\": 100,\n      \"debug\": 17,\n      \"events\": 83,\n      \"inherits\": 88,\n      \"mqtt-packet\": 92,\n      \"readable-stream\": 116,\n      \"reinterval\": 117,\n      \"xtend\": 140\n    }],\n    2: [function (require, module, exports) {\n      (function (Buffer) {\n        'use strict';\n\n        var Transform = require('readable-stream').Transform;\n        var duplexify = require('duplexify');\n        var base64 = require('base64-js');\n\n        /* global FileReader */\n        var my;\n        var proxy;\n        var stream;\n        var isInitialized = false;\n        function buildProxy() {\n          var proxy = new Transform();\n          proxy._write = function (chunk, encoding, next) {\n            my.sendSocketMessage({\n              data: chunk.buffer,\n              success: function success() {\n                next();\n              },\n              fail: function fail() {\n                next(new Error());\n              }\n            });\n          };\n          proxy._flush = function socketEnd(done) {\n            my.closeSocket({\n              success: function success() {\n                done();\n              }\n            });\n          };\n          return proxy;\n        }\n        function setDefaultOpts(opts) {\n          if (!opts.hostname) {\n            opts.hostname = 'localhost';\n          }\n          if (!opts.path) {\n            opts.path = '/';\n          }\n          if (!opts.wsOptions) {\n            opts.wsOptions = {};\n          }\n        }\n        function buildUrl(opts, client) {\n          var protocol = opts.protocol === 'alis' ? 'wss' : 'ws';\n          var url = protocol + '://' + opts.hostname + opts.path;\n          if (opts.port && opts.port !== 80 && opts.port !== 443) {\n            url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n          }\n          if (typeof opts.transformWsUrl === 'function') {\n            url = opts.transformWsUrl(url, opts, client);\n          }\n          return url;\n        }\n        function bindEventHandler() {\n          if (isInitialized) return;\n          isInitialized = true;\n          my.onSocketOpen(function () {\n            stream.setReadable(proxy);\n            stream.setWritable(proxy);\n            stream.emit('connect');\n          });\n          my.onSocketMessage(function (res) {\n            if (typeof res.data === 'string') {\n              var array = base64.toByteArray(res.data);\n              var buffer = Buffer.from(array);\n              proxy.push(buffer);\n            } else {\n              var reader = new FileReader();\n              reader.addEventListener('load', function () {\n                var data = reader.result;\n                if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n                proxy.push(data);\n              });\n              reader.readAsArrayBuffer(res.data);\n            }\n          });\n          my.onSocketClose(function () {\n            stream.end();\n            stream.destroy();\n          });\n          my.onSocketError(function (res) {\n            stream.destroy(res);\n          });\n        }\n        function buildStream(client, opts) {\n          opts.hostname = opts.hostname || opts.host;\n          if (!opts.hostname) {\n            throw new Error('Could not determine host. Specify host manually.');\n          }\n          var websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n          setDefaultOpts(opts);\n          var url = buildUrl(opts, client);\n          my = opts.my;\n          my.connectSocket({\n            url: url,\n            protocols: websocketSubProtocol\n          });\n          proxy = buildProxy();\n          stream = duplexify.obj();\n          bindEventHandler();\n          return stream;\n        }\n        module.exports = buildStream;\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"base64-js\": 10,\n      \"buffer\": 12,\n      \"duplexify\": 19,\n      \"readable-stream\": 116\n    }],\n    3: [function (require, module, exports) {\n      'use strict';\n\n      var net = require('net');\n      var debug = require('debug')('mqttjs:tcp');\n\n      /*\n        variables port and host can be removed since\n        you have all required information in opts object\n      */\n      function streamBuilder(client, opts) {\n        var port, host;\n        opts.port = opts.port || 1883;\n        opts.hostname = opts.hostname || opts.host || 'localhost';\n        port = opts.port;\n        host = opts.hostname;\n        debug('port %d and host %s', port, host);\n        return net.createConnection(port, host);\n      }\n      module.exports = streamBuilder;\n    }, {\n      \"debug\": 17,\n      \"net\": 11\n    }],\n    4: [function (require, module, exports) {\n      'use strict';\n\n      var tls = require('tls');\n      var debug = require('debug')('mqttjs:tls');\n      function buildBuilder(mqttClient, opts) {\n        var connection;\n        opts.port = opts.port || 8883;\n        opts.host = opts.hostname || opts.host || 'localhost';\n        opts.servername = opts.host;\n        opts.rejectUnauthorized = opts.rejectUnauthorized !== false;\n        delete opts.path;\n        debug('port %d host %s rejectUnauthorized %b', opts.port, opts.host, opts.rejectUnauthorized);\n        connection = tls.connect(opts);\n        /* eslint no-use-before-define: [2, \"nofunc\"] */\n        connection.on('secureConnect', function () {\n          if (opts.rejectUnauthorized && !connection.authorized) {\n            connection.emit('error', new Error('TLS not authorized'));\n          } else {\n            connection.removeListener('error', handleTLSerrors);\n          }\n        });\n        function handleTLSerrors(err) {\n          // How can I get verify this error is a tls error?\n          if (opts.rejectUnauthorized) {\n            mqttClient.emit('error', err);\n          }\n\n          // close this connection to match the behaviour of net\n          // otherwise all we get is an error from the connection\n          // and close event doesn't fire. This is a work around\n          // to enable the reconnect code to work the same as with\n          // net.createConnection\n          connection.end();\n        }\n        connection.on('error', handleTLSerrors);\n        return connection;\n      }\n      module.exports = buildBuilder;\n    }, {\n      \"debug\": 17,\n      \"tls\": 11\n    }],\n    5: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        var debug = require('debug')('mqttjs:ws');\n        var websocket = require('websocket-stream');\n        var urlModule = require('url');\n        var WSS_OPTIONS = ['rejectUnauthorized', 'ca', 'cert', 'key', 'pfx', 'passphrase'];\n        var IS_BROWSER = process.title === 'browser';\n        function buildUrl(opts, client) {\n          var url = opts.protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n          if (typeof opts.transformWsUrl === 'function') {\n            url = opts.transformWsUrl(url, opts, client);\n          }\n          return url;\n        }\n        function setDefaultOpts(opts) {\n          if (!opts.hostname) {\n            opts.hostname = 'localhost';\n          }\n          if (!opts.port) {\n            if (opts.protocol === 'wss') {\n              opts.port = 443;\n            } else {\n              opts.port = 80;\n            }\n          }\n          if (!opts.path) {\n            opts.path = '/';\n          }\n          if (!opts.wsOptions) {\n            opts.wsOptions = {};\n          }\n          if (!IS_BROWSER && opts.protocol === 'wss') {\n            // Add cert/key/ca etc options\n            WSS_OPTIONS.forEach(function (prop) {\n              if (opts.hasOwnProperty(prop) && !opts.wsOptions.hasOwnProperty(prop)) {\n                opts.wsOptions[prop] = opts[prop];\n              }\n            });\n          }\n        }\n        function createWebSocket(client, opts) {\n          debug('createWebSocket');\n          var websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n          setDefaultOpts(opts);\n          var url = buildUrl(opts, client);\n          debug('url %s protocol %s', url, websocketSubProtocol);\n          return websocket(url, [websocketSubProtocol], opts.wsOptions);\n        }\n        function streamBuilder(client, opts) {\n          return createWebSocket(client, opts);\n        }\n        function browserStreamBuilder(client, opts) {\n          debug('browserStreamBuilder');\n          if (!opts.hostname) {\n            opts.hostname = opts.host;\n          }\n          if (!opts.hostname) {\n            // Throwing an error in a Web Worker if no `hostname` is given, because we\n            // can not determine the `hostname` automatically.  If connecting to\n            // localhost, please supply the `hostname` as an argument.\n            if (typeof document === 'undefined') {\n              throw new Error('Could not determine host. Specify host manually.');\n            }\n            var parsed = urlModule.parse(document.URL);\n            opts.hostname = parsed.hostname;\n            if (!opts.port) {\n              opts.port = parsed.port;\n            }\n          }\n          return createWebSocket(client, opts);\n        }\n        if (IS_BROWSER) {\n          module.exports = browserStreamBuilder;\n        } else {\n          module.exports = streamBuilder;\n        }\n      }).call(this, require('_process'));\n    }, {\n      \"_process\": 100,\n      \"debug\": 17,\n      \"url\": 132,\n      \"websocket-stream\": 137\n    }],\n    6: [function (require, module, exports) {\n      (function (process, Buffer) {\n        'use strict';\n\n        var Transform = require('readable-stream').Transform;\n        var duplexify = require('duplexify');\n\n        /* global wx */\n        var socketTask;\n        var proxy;\n        var stream;\n        function buildProxy() {\n          var proxy = new Transform();\n          proxy._write = function (chunk, encoding, next) {\n            socketTask.send({\n              data: chunk.buffer,\n              success: function success() {\n                next();\n              },\n              fail: function fail(errMsg) {\n                next(new Error(errMsg));\n              }\n            });\n          };\n          proxy._flush = function socketEnd(done) {\n            socketTask.close({\n              success: function success() {\n                done();\n              }\n            });\n          };\n          return proxy;\n        }\n        function setDefaultOpts(opts) {\n          if (!opts.hostname) {\n            opts.hostname = 'localhost';\n          }\n          if (!opts.path) {\n            opts.path = '/';\n          }\n          if (!opts.wsOptions) {\n            opts.wsOptions = {};\n          }\n        }\n        function buildUrl(opts, client) {\n          var protocol = opts.protocol === 'wxs' ? 'wss' : 'ws';\n          var url = protocol + '://' + opts.hostname + opts.path;\n          if (opts.port && opts.port !== 80 && opts.port !== 443) {\n            url = protocol + '://' + opts.hostname + ':' + opts.port + opts.path;\n          }\n          if (typeof opts.transformWsUrl === 'function') {\n            url = opts.transformWsUrl(url, opts, client);\n          }\n          return url;\n        }\n        function bindEventHandler() {\n          socketTask.onOpen(function () {\n            stream.setReadable(proxy);\n            stream.setWritable(proxy);\n            stream.emit('connect');\n          });\n          socketTask.onMessage(function (res) {\n            var data = res.data;\n            if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n            proxy.push(data);\n          });\n          socketTask.onClose(function () {\n            stream.end();\n            stream.destroy();\n          });\n          socketTask.onError(function (res) {\n            stream.destroy(new Error(res.errMsg));\n          });\n        }\n        function buildStream(client, opts) {\n          opts.hostname = opts.hostname || opts.host;\n          if (!opts.hostname) {\n            throw new Error('Could not determine host. Specify host manually.');\n          }\n          var websocketSubProtocol = opts.protocolId === 'MQIsdp' && opts.protocolVersion === 3 ? 'mqttv3.1' : 'mqtt';\n          setDefaultOpts(opts);\n          var url = buildUrl(opts, client);\n          socketTask = wx.connectSocket({\n            url: url,\n            protocols: [websocketSubProtocol]\n          });\n          proxy = buildProxy();\n          stream = duplexify.obj();\n          stream._destroy = function (err, cb) {\n            socketTask.close({\n              success: function success() {\n                cb && cb(err);\n              }\n            });\n          };\n          var destroyRef = stream.destroy;\n          stream.destroy = function () {\n            stream.destroy = destroyRef;\n            var self = this;\n            process.nextTick(function () {\n              socketTask.close({\n                fail: function fail() {\n                  self._destroy(new Error());\n                }\n              });\n            });\n          }.bind(stream);\n          bindEventHandler();\n          return stream;\n        }\n        module.exports = buildStream;\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, {\n      \"_process\": 100,\n      \"buffer\": 12,\n      \"duplexify\": 19,\n      \"readable-stream\": 116\n    }],\n    7: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        /**\n         * Module dependencies\n         */\n        var xtend = require('xtend');\n        var Readable = require('readable-stream').Readable;\n        var streamsOpts = {\n          objectMode: true\n        };\n        var defaultStoreOptions = {\n          clean: true\n        };\n\n        /**\n         * es6-map can preserve insertion order even if ES version is older.\n         *\n         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Description\n         * It should be noted that a Map which is a map of an object, especially\n         * a dictionary of dictionaries, will only map to the object's insertion\n         * order. In ES2015 this is ordered for objects but for older versions of\n         * ES, this may be random and not ordered.\n         *\n         */\n        var Map = require('es6-map');\n\n        /**\n         * In-memory implementation of the message store\n         * This can actually be saved into files.\n         *\n         * @param {Object} [options] - store options\n         */\n        function Store(options) {\n          if (!(this instanceof Store)) {\n            return new Store(options);\n          }\n          this.options = options || {};\n\n          // Defaults\n          this.options = xtend(defaultStoreOptions, options);\n          this._inflights = new Map();\n        }\n\n        /**\n         * Adds a packet to the store, a packet is\n         * anything that has a messageId property.\n         *\n         */\n        Store.prototype.put = function (packet, cb) {\n          this._inflights.set(packet.messageId, packet);\n          if (cb) {\n            cb();\n          }\n          return this;\n        };\n\n        /**\n         * Creates a stream with all the packets in the store\n         *\n         */\n        Store.prototype.createStream = function () {\n          var stream = new Readable(streamsOpts);\n          var destroyed = false;\n          var values = [];\n          var i = 0;\n          this._inflights.forEach(function (value, key) {\n            values.push(value);\n          });\n          stream._read = function () {\n            if (!destroyed && i < values.length) {\n              this.push(values[i++]);\n            } else {\n              this.push(null);\n            }\n          };\n          stream.destroy = function () {\n            if (destroyed) {\n              return;\n            }\n            var self = this;\n            destroyed = true;\n            process.nextTick(function () {\n              self.emit('close');\n            });\n          };\n          return stream;\n        };\n\n        /**\n         * deletes a packet from the store.\n         */\n        Store.prototype.del = function (packet, cb) {\n          packet = this._inflights.get(packet.messageId);\n          if (packet) {\n            this._inflights.delete(packet.messageId);\n            cb(null, packet);\n          } else if (cb) {\n            cb(new Error('missing packet'));\n          }\n          return this;\n        };\n\n        /**\n         * get a packet from the store.\n         */\n        Store.prototype.get = function (packet, cb) {\n          packet = this._inflights.get(packet.messageId);\n          if (packet) {\n            cb(null, packet);\n          } else if (cb) {\n            cb(new Error('missing packet'));\n          }\n          return this;\n        };\n\n        /**\n         * Close the store\n         */\n        Store.prototype.close = function (cb) {\n          if (this.options.clean) {\n            this._inflights = null;\n          }\n          if (cb) {\n            cb();\n          }\n        };\n        module.exports = Store;\n      }).call(this, require('_process'));\n    }, {\n      \"_process\": 100,\n      \"es6-map\": 68,\n      \"readable-stream\": 116,\n      \"xtend\": 140\n    }],\n    8: [function (require, module, exports) {\n      'use strict';\n\n      /**\n       * Validate a topic to see if it's valid or not.\n       * A topic is valid if it follow below rules:\n       * - Rule #1: If any part of the topic is not `+` or `#`, then it must not contain `+` and '#'\n       * - Rule #2: Part `#` must be located at the end of the mailbox\n       *\n       * @param {String} topic - A topic\n       * @returns {Boolean} If the topic is valid, returns true. Otherwise, returns false.\n       */\n      function validateTopic(topic) {\n        var parts = topic.split('/');\n        for (var i = 0; i < parts.length; i++) {\n          if (parts[i] === '+') {\n            continue;\n          }\n          if (parts[i] === '#') {\n            // for Rule #2\n            return i === parts.length - 1;\n          }\n          if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      /**\n       * Validate an array of topics to see if any of them is valid or not\n        * @param {Array} topics - Array of topics\n       * @returns {String} If the topics is valid, returns null. Otherwise, returns the invalid one\n       */\n      function validateTopics(topics) {\n        if (topics.length === 0) {\n          return 'empty_topic_list';\n        }\n        for (var i = 0; i < topics.length; i++) {\n          if (!validateTopic(topics[i])) {\n            return topics[i];\n          }\n        }\n        return null;\n      }\n      module.exports = {\n        validateTopics: validateTopics\n      };\n    }, {}],\n    9: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        var MqttClient = require('../client');\n        var Store = require('../store');\n        var url = require('url');\n        var xtend = require('xtend');\n        var debug = require('debug')('mqttjs');\n        var protocols = {};\n        if (process.title !== 'browser') {\n          protocols.mqtt = require('./tcp');\n          protocols.tcp = require('./tcp');\n          protocols.ssl = require('./tls');\n          protocols.tls = require('./tls');\n          protocols.mqtts = require('./tls');\n        } else {\n          protocols.wx = require('./wx');\n          protocols.wxs = require('./wx');\n          protocols.ali = require('./ali');\n          protocols.alis = require('./ali');\n        }\n        protocols.ws = require('./ws');\n        protocols.wss = require('./ws');\n\n        /**\n         * Parse the auth attribute and merge username and password in the options object.\n         *\n         * @param {Object} [opts] option object\n         */\n        function parseAuthOptions(opts) {\n          var matches;\n          if (opts.auth) {\n            matches = opts.auth.match(/^(.+):(.+)$/);\n            if (matches) {\n              opts.username = matches[1];\n              opts.password = matches[2];\n            } else {\n              opts.username = opts.auth;\n            }\n          }\n        }\n\n        /**\n         * connect - connect to an MQTT broker.\n         *\n         * @param {String} [brokerUrl] - url of the broker, optional\n         * @param {Object} opts - see MqttClient#constructor\n         */\n        function connect(brokerUrl, opts) {\n          debug('connecting to an MQTT broker...');\n          if (_typeof(brokerUrl) === 'object' && !opts) {\n            opts = brokerUrl;\n            brokerUrl = null;\n          }\n          opts = opts || {};\n          if (brokerUrl) {\n            var parsed = url.parse(brokerUrl, true);\n            if (parsed.port != null) {\n              parsed.port = Number(parsed.port);\n            }\n            opts = xtend(parsed, opts);\n            if (opts.protocol === null) {\n              throw new Error('Missing protocol');\n            }\n            opts.protocol = opts.protocol.replace(/:$/, '');\n          }\n\n          // merge in the auth options if supplied\n          parseAuthOptions(opts);\n\n          // support clientId passed in the query string of the url\n          if (opts.query && typeof opts.query.clientId === 'string') {\n            opts.clientId = opts.query.clientId;\n          }\n          if (opts.cert && opts.key) {\n            if (opts.protocol) {\n              if (['mqtts', 'wss', 'wxs', 'alis'].indexOf(opts.protocol) === -1) {\n                switch (opts.protocol) {\n                  case 'mqtt':\n                    opts.protocol = 'mqtts';\n                    break;\n                  case 'ws':\n                    opts.protocol = 'wss';\n                    break;\n                  case 'wx':\n                    opts.protocol = 'wxs';\n                    break;\n                  case 'ali':\n                    opts.protocol = 'alis';\n                    break;\n                  default:\n                    throw new Error('Unknown protocol for secure connection: \"' + opts.protocol + '\"!');\n                }\n              }\n            } else {\n              // A cert and key was provided, however no protocol was specified, so we will throw an error.\n              throw new Error('Missing secure protocol key');\n            }\n          }\n          if (!protocols[opts.protocol]) {\n            var isSecure = ['mqtts', 'wss'].indexOf(opts.protocol) !== -1;\n            opts.protocol = ['mqtt', 'mqtts', 'ws', 'wss', 'wx', 'wxs', 'ali', 'alis'].filter(function (key, index) {\n              if (isSecure && index % 2 === 0) {\n                // Skip insecure protocols when requesting a secure one.\n                return false;\n              }\n              return typeof protocols[key] === 'function';\n            })[0];\n          }\n          if (opts.clean === false && !opts.clientId) {\n            throw new Error('Missing clientId for unclean clients');\n          }\n          if (opts.protocol) {\n            opts.defaultProtocol = opts.protocol;\n          }\n          function wrapper(client) {\n            if (opts.servers) {\n              if (!client._reconnectCount || client._reconnectCount === opts.servers.length) {\n                client._reconnectCount = 0;\n              }\n              opts.host = opts.servers[client._reconnectCount].host;\n              opts.port = opts.servers[client._reconnectCount].port;\n              opts.protocol = !opts.servers[client._reconnectCount].protocol ? opts.defaultProtocol : opts.servers[client._reconnectCount].protocol;\n              opts.hostname = opts.host;\n              client._reconnectCount++;\n            }\n            debug('calling streambuilder for', opts.protocol);\n            return protocols[opts.protocol](client, opts);\n          }\n          var client = new MqttClient(wrapper, opts);\n          client.on('error', function () {/* Automatically set up client error handling */});\n          return client;\n        }\n        module.exports = connect;\n        module.exports.connect = connect;\n        module.exports.MqttClient = MqttClient;\n        module.exports.Store = Store;\n      }).call(this, require('_process'));\n    }, {\n      \"../client\": 1,\n      \"../store\": 7,\n      \"./ali\": 2,\n      \"./tcp\": 3,\n      \"./tls\": 4,\n      \"./ws\": 5,\n      \"./wx\": 6,\n      \"_process\": 100,\n      \"debug\": 17,\n      \"url\": 132,\n      \"xtend\": 140\n    }],\n    10: [function (require, module, exports) {\n      'use strict';\n\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n      for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n\n      // Support decoding URL-safe base64 strings, as Node.js does.\n      // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n      revLookup['-'.charCodeAt(0)] = 62;\n      revLookup['_'.charCodeAt(0)] = 63;\n      function getLens(b64) {\n        var len = b64.length;\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        }\n\n        // Trim off extra bytes after placeholder bytes are found\n        // See: https://github.com/beatgammit/base64-js/issues/42\n        var validLen = b64.indexOf('=');\n        if (validLen === -1) validLen = len;\n        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n        return [validLen, placeHoldersLen];\n      }\n\n      // base64 is 4/3 + up to two characters of the original data\n      function byteLength(b64) {\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function _byteLength(b64, validLen, placeHoldersLen) {\n        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n      }\n      function toByteArray(b64) {\n        var tmp;\n        var lens = getLens(b64);\n        var validLen = lens[0];\n        var placeHoldersLen = lens[1];\n        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n        var curByte = 0;\n\n        // if there are placeholders, only get up to the last complete 4 chars\n        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n        for (var i = 0; i < len; i += 4) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[curByte++] = tmp >> 16 & 0xFF;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n        if (placeHoldersLen === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[curByte++] = tmp & 0xFF;\n        }\n        if (placeHoldersLen === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[curByte++] = tmp >> 8 & 0xFF;\n          arr[curByte++] = tmp & 0xFF;\n        }\n        return arr;\n      }\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n      }\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n        for (var i = start; i < end; i += 3) {\n          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n          output.push(tripletToBase64(tmp));\n        }\n        return output.join('');\n      }\n      function fromByteArray(uint8) {\n        var tmp;\n        var len = uint8.length;\n        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        var parts = [];\n        var maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n          tmp = uint8[len - 1];\n          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n        }\n        return parts.join('');\n      }\n    }, {}],\n    11: [function (require, module, exports) {}, {}],\n    12: [function (require, module, exports) {\n      (function (Buffer) {\n        /*!\n         * The buffer module from node.js, for the browser.\n         *\n         * @author   Feross Aboukhadijeh <https://feross.org>\n         * @license  MIT\n         */\n        /* eslint-disable no-proto */\n\n        'use strict';\n\n        var base64 = require('base64-js');\n        var ieee754 = require('ieee754');\n        exports.Buffer = Buffer;\n        exports.SlowBuffer = SlowBuffer;\n        exports.INSPECT_MAX_BYTES = 50;\n        var K_MAX_LENGTH = 0x7fffffff;\n        exports.kMaxLength = K_MAX_LENGTH;\n\n        /**\n         * If `Buffer.TYPED_ARRAY_SUPPORT`:\n         *   === true    Use Uint8Array implementation (fastest)\n         *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n         *               implementation (most compatible, even IE6)\n         *\n         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n         * Opera 11.6+, iOS 4.2+.\n         *\n         * We report that the browser does not support typed arrays if the are not subclassable\n         * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n         * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n         * for __proto__ and has a buggy typed array implementation.\n         */\n        Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n        if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {\n          __f__(\"error\", 'This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.', \" at mqtt.js:2579\");\n        }\n        function typedArraySupport() {\n          // Can typed array instances can be augmented?\n          try {\n            var arr = new Uint8Array(1);\n            arr.__proto__ = {\n              __proto__: Uint8Array.prototype,\n              foo: function foo() {\n                return 42;\n              }\n            };\n            return arr.foo() === 42;\n          } catch (e) {\n            return false;\n          }\n        }\n        Object.defineProperty(Buffer.prototype, 'parent', {\n          enumerable: true,\n          get: function get() {\n            if (!Buffer.isBuffer(this)) return undefined;\n            return this.buffer;\n          }\n        });\n        Object.defineProperty(Buffer.prototype, 'offset', {\n          enumerable: true,\n          get: function get() {\n            if (!Buffer.isBuffer(this)) return undefined;\n            return this.byteOffset;\n          }\n        });\n        function createBuffer(length) {\n          if (length > K_MAX_LENGTH) {\n            throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n          }\n          // Return an augmented `Uint8Array` instance\n          var buf = new Uint8Array(length);\n          buf.__proto__ = Buffer.prototype;\n          return buf;\n        }\n\n        /**\n         * The Buffer constructor returns instances of `Uint8Array` that have their\n         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n         * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n         * returns a single octet.\n         *\n         * The `Uint8Array` prototype remains unmodified.\n         */\n\n        function Buffer(arg, encodingOrOffset, length) {\n          // Common case.\n          if (typeof arg === 'number') {\n            if (typeof encodingOrOffset === 'string') {\n              throw new TypeError('The \"string\" argument must be of type string. Received type number');\n            }\n            return allocUnsafe(arg);\n          }\n          return from(arg, encodingOrOffset, length);\n        }\n\n        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n        if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {\n          Object.defineProperty(Buffer, Symbol.species, {\n            value: null,\n            configurable: true,\n            enumerable: false,\n            writable: false\n          });\n        }\n        Buffer.poolSize = 8192; // not used by this implementation\n\n        function from(value, encodingOrOffset, length) {\n          if (typeof value === 'string') {\n            return fromString(value, encodingOrOffset);\n          }\n          if (ArrayBuffer.isView(value)) {\n            return fromArrayLike(value);\n          }\n          if (value == null) {\n            throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));\n          }\n          if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n            return fromArrayBuffer(value, encodingOrOffset, length);\n          }\n          if (typeof value === 'number') {\n            throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n          }\n          var valueOf = value.valueOf && value.valueOf();\n          if (valueOf != null && valueOf !== value) {\n            return Buffer.from(valueOf, encodingOrOffset, length);\n          }\n          var b = fromObject(value);\n          if (b) return b;\n          if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {\n            return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n          }\n          throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));\n        }\n\n        /**\n         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n         * if value is a number.\n         * Buffer.from(str[, encoding])\n         * Buffer.from(array)\n         * Buffer.from(buffer)\n         * Buffer.from(arrayBuffer[, byteOffset[, length]])\n         **/\n        Buffer.from = function (value, encodingOrOffset, length) {\n          return from(value, encodingOrOffset, length);\n        };\n\n        // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n        // https://github.com/feross/buffer/pull/148\n        Buffer.prototype.__proto__ = Uint8Array.prototype;\n        Buffer.__proto__ = Uint8Array;\n        function assertSize(size) {\n          if (typeof size !== 'number') {\n            throw new TypeError('\"size\" argument must be of type number');\n          } else if (size < 0) {\n            throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n          }\n        }\n        function alloc(size, fill, encoding) {\n          assertSize(size);\n          if (size <= 0) {\n            return createBuffer(size);\n          }\n          if (fill !== undefined) {\n            // Only pay attention to encoding if it's a string. This\n            // prevents accidentally sending in a number that would\n            // be interpretted as a start offset.\n            return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n          }\n          return createBuffer(size);\n        }\n\n        /**\n         * Creates a new filled Buffer instance.\n         * alloc(size[, fill[, encoding]])\n         **/\n        Buffer.alloc = function (size, fill, encoding) {\n          return alloc(size, fill, encoding);\n        };\n        function allocUnsafe(size) {\n          assertSize(size);\n          return createBuffer(size < 0 ? 0 : checked(size) | 0);\n        }\n\n        /**\n         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n         * */\n        Buffer.allocUnsafe = function (size) {\n          return allocUnsafe(size);\n        };\n        /**\n         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n         */\n        Buffer.allocUnsafeSlow = function (size) {\n          return allocUnsafe(size);\n        };\n        function fromString(string, encoding) {\n          if (typeof encoding !== 'string' || encoding === '') {\n            encoding = 'utf8';\n          }\n          if (!Buffer.isEncoding(encoding)) {\n            throw new TypeError('Unknown encoding: ' + encoding);\n          }\n          var length = byteLength(string, encoding) | 0;\n          var buf = createBuffer(length);\n          var actual = buf.write(string, encoding);\n          if (actual !== length) {\n            // Writing a hex string, for example, that contains invalid characters will\n            // cause everything after the first invalid character to be ignored. (e.g.\n            // 'abxxcd' will be treated as 'ab')\n            buf = buf.slice(0, actual);\n          }\n          return buf;\n        }\n        function fromArrayLike(array) {\n          var length = array.length < 0 ? 0 : checked(array.length) | 0;\n          var buf = createBuffer(length);\n          for (var i = 0; i < length; i += 1) {\n            buf[i] = array[i] & 255;\n          }\n          return buf;\n        }\n        function fromArrayBuffer(array, byteOffset, length) {\n          if (byteOffset < 0 || array.byteLength < byteOffset) {\n            throw new RangeError('\"offset\" is outside of buffer bounds');\n          }\n          if (array.byteLength < byteOffset + (length || 0)) {\n            throw new RangeError('\"length\" is outside of buffer bounds');\n          }\n          var buf;\n          if (byteOffset === undefined && length === undefined) {\n            buf = new Uint8Array(array);\n          } else if (length === undefined) {\n            buf = new Uint8Array(array, byteOffset);\n          } else {\n            buf = new Uint8Array(array, byteOffset, length);\n          }\n\n          // Return an augmented `Uint8Array` instance\n          buf.__proto__ = Buffer.prototype;\n          return buf;\n        }\n        function fromObject(obj) {\n          if (Buffer.isBuffer(obj)) {\n            var len = checked(obj.length) | 0;\n            var buf = createBuffer(len);\n            if (buf.length === 0) {\n              return buf;\n            }\n            obj.copy(buf, 0, 0, len);\n            return buf;\n          }\n          if (obj.length !== undefined) {\n            if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n              return createBuffer(0);\n            }\n            return fromArrayLike(obj);\n          }\n          if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n            return fromArrayLike(obj.data);\n          }\n        }\n        function checked(length) {\n          // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n          // length is NaN (which is otherwise coerced to zero.)\n          if (length >= K_MAX_LENGTH) {\n            throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n          }\n          return length | 0;\n        }\n        function SlowBuffer(length) {\n          if (+length != length) {\n            // eslint-disable-line eqeqeq\n            length = 0;\n          }\n          return Buffer.alloc(+length);\n        }\n        Buffer.isBuffer = function isBuffer(b) {\n          return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n        };\n\n        Buffer.compare = function compare(a, b) {\n          if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n          if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n            throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n          }\n          if (a === b) return 0;\n          var x = a.length;\n          var y = b.length;\n          for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n            if (a[i] !== b[i]) {\n              x = a[i];\n              y = b[i];\n              break;\n            }\n          }\n          if (x < y) return -1;\n          if (y < x) return 1;\n          return 0;\n        };\n        Buffer.isEncoding = function isEncoding(encoding) {\n          switch (String(encoding).toLowerCase()) {\n            case 'hex':\n            case 'utf8':\n            case 'utf-8':\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n            case 'base64':\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return true;\n            default:\n              return false;\n          }\n        };\n        Buffer.concat = function concat(list, length) {\n          if (!Array.isArray(list)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          }\n          if (list.length === 0) {\n            return Buffer.alloc(0);\n          }\n          var i;\n          if (length === undefined) {\n            length = 0;\n            for (i = 0; i < list.length; ++i) {\n              length += list[i].length;\n            }\n          }\n          var buffer = Buffer.allocUnsafe(length);\n          var pos = 0;\n          for (i = 0; i < list.length; ++i) {\n            var buf = list[i];\n            if (isInstance(buf, Uint8Array)) {\n              buf = Buffer.from(buf);\n            }\n            if (!Buffer.isBuffer(buf)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n            buf.copy(buffer, pos);\n            pos += buf.length;\n          }\n          return buffer;\n        };\n        function byteLength(string, encoding) {\n          if (Buffer.isBuffer(string)) {\n            return string.length;\n          }\n          if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n            return string.byteLength;\n          }\n          if (typeof string !== 'string') {\n            throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));\n          }\n          var len = string.length;\n          var mustMatch = arguments.length > 2 && arguments[2] === true;\n          if (!mustMatch && len === 0) return 0;\n\n          // Use a for loop to avoid recursion\n          var loweredCase = false;\n          for (;;) {\n            switch (encoding) {\n              case 'ascii':\n              case 'latin1':\n              case 'binary':\n                return len;\n              case 'utf8':\n              case 'utf-8':\n                return utf8ToBytes(string).length;\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return len * 2;\n              case 'hex':\n                return len >>> 1;\n              case 'base64':\n                return base64ToBytes(string).length;\n              default:\n                if (loweredCase) {\n                  return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n                }\n\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n            }\n          }\n        }\n        Buffer.byteLength = byteLength;\n        function slowToString(encoding, start, end) {\n          var loweredCase = false;\n\n          // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n          // property of a typed array.\n\n          // This behaves neither like String nor Uint8Array in that we set start/end\n          // to their upper/lower bounds if the value passed is out of range.\n          // undefined is handled specially as per ECMA-262 6th Edition,\n          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n          if (start === undefined || start < 0) {\n            start = 0;\n          }\n          // Return early if start > this.length. Done here to prevent potential uint32\n          // coercion fail below.\n          if (start > this.length) {\n            return '';\n          }\n          if (end === undefined || end > this.length) {\n            end = this.length;\n          }\n          if (end <= 0) {\n            return '';\n          }\n\n          // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n          end >>>= 0;\n          start >>>= 0;\n          if (end <= start) {\n            return '';\n          }\n          if (!encoding) encoding = 'utf8';\n          while (true) {\n            switch (encoding) {\n              case 'hex':\n                return hexSlice(this, start, end);\n              case 'utf8':\n              case 'utf-8':\n                return utf8Slice(this, start, end);\n              case 'ascii':\n                return asciiSlice(this, start, end);\n              case 'latin1':\n              case 'binary':\n                return latin1Slice(this, start, end);\n              case 'base64':\n                return base64Slice(this, start, end);\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return utf16leSlice(this, start, end);\n              default:\n                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = (encoding + '').toLowerCase();\n                loweredCase = true;\n            }\n          }\n        }\n\n        // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n        // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n        // reliably in a browserify context because there could be multiple different\n        // copies of the 'buffer' package in use. This method works even for Buffer\n        // instances that were created from another copy of the `buffer` package.\n        // See: https://github.com/feross/buffer/issues/154\n        Buffer.prototype._isBuffer = true;\n        function swap(b, n, m) {\n          var i = b[n];\n          b[n] = b[m];\n          b[m] = i;\n        }\n        Buffer.prototype.swap16 = function swap16() {\n          var len = this.length;\n          if (len % 2 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 16-bits');\n          }\n          for (var i = 0; i < len; i += 2) {\n            swap(this, i, i + 1);\n          }\n          return this;\n        };\n        Buffer.prototype.swap32 = function swap32() {\n          var len = this.length;\n          if (len % 4 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 32-bits');\n          }\n          for (var i = 0; i < len; i += 4) {\n            swap(this, i, i + 3);\n            swap(this, i + 1, i + 2);\n          }\n          return this;\n        };\n        Buffer.prototype.swap64 = function swap64() {\n          var len = this.length;\n          if (len % 8 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 64-bits');\n          }\n          for (var i = 0; i < len; i += 8) {\n            swap(this, i, i + 7);\n            swap(this, i + 1, i + 6);\n            swap(this, i + 2, i + 5);\n            swap(this, i + 3, i + 4);\n          }\n          return this;\n        };\n        Buffer.prototype.toString = function toString() {\n          var length = this.length;\n          if (length === 0) return '';\n          if (arguments.length === 0) return utf8Slice(this, 0, length);\n          return slowToString.apply(this, arguments);\n        };\n        Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n        Buffer.prototype.equals = function equals(b) {\n          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n          if (this === b) return true;\n          return Buffer.compare(this, b) === 0;\n        };\n        Buffer.prototype.inspect = function inspect() {\n          var str = '';\n          var max = exports.INSPECT_MAX_BYTES;\n          str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n          if (this.length > max) str += ' ... ';\n          return '<Buffer ' + str + '>';\n        };\n        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n          if (isInstance(target, Uint8Array)) {\n            target = Buffer.from(target, target.offset, target.byteLength);\n          }\n          if (!Buffer.isBuffer(target)) {\n            throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));\n          }\n          if (start === undefined) {\n            start = 0;\n          }\n          if (end === undefined) {\n            end = target ? target.length : 0;\n          }\n          if (thisStart === undefined) {\n            thisStart = 0;\n          }\n          if (thisEnd === undefined) {\n            thisEnd = this.length;\n          }\n          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n            throw new RangeError('out of range index');\n          }\n          if (thisStart >= thisEnd && start >= end) {\n            return 0;\n          }\n          if (thisStart >= thisEnd) {\n            return -1;\n          }\n          if (start >= end) {\n            return 1;\n          }\n          start >>>= 0;\n          end >>>= 0;\n          thisStart >>>= 0;\n          thisEnd >>>= 0;\n          if (this === target) return 0;\n          var x = thisEnd - thisStart;\n          var y = end - start;\n          var len = Math.min(x, y);\n          var thisCopy = this.slice(thisStart, thisEnd);\n          var targetCopy = target.slice(start, end);\n          for (var i = 0; i < len; ++i) {\n            if (thisCopy[i] !== targetCopy[i]) {\n              x = thisCopy[i];\n              y = targetCopy[i];\n              break;\n            }\n          }\n          if (x < y) return -1;\n          if (y < x) return 1;\n          return 0;\n        };\n\n        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n        //\n        // Arguments:\n        // - buffer - a Buffer to search\n        // - val - a string, Buffer, or number\n        // - byteOffset - an index into `buffer`; will be clamped to an int32\n        // - encoding - an optional encoding, relevant is val is a string\n        // - dir - true for indexOf, false for lastIndexOf\n        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n          // Empty buffer means no match\n          if (buffer.length === 0) return -1;\n\n          // Normalize byteOffset\n          if (typeof byteOffset === 'string') {\n            encoding = byteOffset;\n            byteOffset = 0;\n          } else if (byteOffset > 0x7fffffff) {\n            byteOffset = 0x7fffffff;\n          } else if (byteOffset < -0x80000000) {\n            byteOffset = -0x80000000;\n          }\n          byteOffset = +byteOffset; // Coerce to Number.\n          if (numberIsNaN(byteOffset)) {\n            // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n            byteOffset = dir ? 0 : buffer.length - 1;\n          }\n\n          // Normalize byteOffset: negative offsets start from the end of the buffer\n          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n          if (byteOffset >= buffer.length) {\n            if (dir) return -1;else byteOffset = buffer.length - 1;\n          } else if (byteOffset < 0) {\n            if (dir) byteOffset = 0;else return -1;\n          }\n\n          // Normalize val\n          if (typeof val === 'string') {\n            val = Buffer.from(val, encoding);\n          }\n\n          // Finally, search either indexOf (if dir is true) or lastIndexOf\n          if (Buffer.isBuffer(val)) {\n            // Special case: looking for empty string/buffer always fails\n            if (val.length === 0) {\n              return -1;\n            }\n            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n          } else if (typeof val === 'number') {\n            val = val & 0xFF; // Search for a byte value [0-255]\n            if (typeof Uint8Array.prototype.indexOf === 'function') {\n              if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n              } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n              }\n            }\n            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n          }\n          throw new TypeError('val must be string, number or Buffer');\n        }\n        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n          var indexSize = 1;\n          var arrLength = arr.length;\n          var valLength = val.length;\n          if (encoding !== undefined) {\n            encoding = String(encoding).toLowerCase();\n            if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n              if (arr.length < 2 || val.length < 2) {\n                return -1;\n              }\n              indexSize = 2;\n              arrLength /= 2;\n              valLength /= 2;\n              byteOffset /= 2;\n            }\n          }\n          function read(buf, i) {\n            if (indexSize === 1) {\n              return buf[i];\n            } else {\n              return buf.readUInt16BE(i * indexSize);\n            }\n          }\n          var i;\n          if (dir) {\n            var foundIndex = -1;\n            for (i = byteOffset; i < arrLength; i++) {\n              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n              } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n              }\n            }\n          } else {\n            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n            for (i = byteOffset; i >= 0; i--) {\n              var found = true;\n              for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                  found = false;\n                  break;\n                }\n              }\n              if (found) return i;\n            }\n          }\n          return -1;\n        }\n        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n          return this.indexOf(val, byteOffset, encoding) !== -1;\n        };\n        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n        };\n        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n        };\n        function hexWrite(buf, string, offset, length) {\n          offset = Number(offset) || 0;\n          var remaining = buf.length - offset;\n          if (!length) {\n            length = remaining;\n          } else {\n            length = Number(length);\n            if (length > remaining) {\n              length = remaining;\n            }\n          }\n          var strLen = string.length;\n          if (length > strLen / 2) {\n            length = strLen / 2;\n          }\n          for (var i = 0; i < length; ++i) {\n            var parsed = parseInt(string.substr(i * 2, 2), 16);\n            if (numberIsNaN(parsed)) return i;\n            buf[offset + i] = parsed;\n          }\n          return i;\n        }\n        function utf8Write(buf, string, offset, length) {\n          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n        }\n        function asciiWrite(buf, string, offset, length) {\n          return blitBuffer(asciiToBytes(string), buf, offset, length);\n        }\n        function latin1Write(buf, string, offset, length) {\n          return asciiWrite(buf, string, offset, length);\n        }\n        function base64Write(buf, string, offset, length) {\n          return blitBuffer(base64ToBytes(string), buf, offset, length);\n        }\n        function ucs2Write(buf, string, offset, length) {\n          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n        }\n        Buffer.prototype.write = function write(string, offset, length, encoding) {\n          // Buffer#write(string)\n          if (offset === undefined) {\n            encoding = 'utf8';\n            length = this.length;\n            offset = 0;\n            // Buffer#write(string, encoding)\n          } else if (length === undefined && typeof offset === 'string') {\n            encoding = offset;\n            length = this.length;\n            offset = 0;\n            // Buffer#write(string, offset[, length][, encoding])\n          } else if (isFinite(offset)) {\n            offset = offset >>> 0;\n            if (isFinite(length)) {\n              length = length >>> 0;\n              if (encoding === undefined) encoding = 'utf8';\n            } else {\n              encoding = length;\n              length = undefined;\n            }\n          } else {\n            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n          }\n          var remaining = this.length - offset;\n          if (length === undefined || length > remaining) length = remaining;\n          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n            throw new RangeError('Attempt to write outside buffer bounds');\n          }\n          if (!encoding) encoding = 'utf8';\n          var loweredCase = false;\n          for (;;) {\n            switch (encoding) {\n              case 'hex':\n                return hexWrite(this, string, offset, length);\n              case 'utf8':\n              case 'utf-8':\n                return utf8Write(this, string, offset, length);\n              case 'ascii':\n                return asciiWrite(this, string, offset, length);\n              case 'latin1':\n              case 'binary':\n                return latin1Write(this, string, offset, length);\n              case 'base64':\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return ucs2Write(this, string, offset, length);\n              default:\n                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n            }\n          }\n        };\n        Buffer.prototype.toJSON = function toJSON() {\n          return {\n            type: 'Buffer',\n            data: Array.prototype.slice.call(this._arr || this, 0)\n          };\n        };\n        function base64Slice(buf, start, end) {\n          if (start === 0 && end === buf.length) {\n            return base64.fromByteArray(buf);\n          } else {\n            return base64.fromByteArray(buf.slice(start, end));\n          }\n        }\n        function utf8Slice(buf, start, end) {\n          end = Math.min(buf.length, end);\n          var res = [];\n          var i = start;\n          while (i < end) {\n            var firstByte = buf[i];\n            var codePoint = null;\n            var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n            if (i + bytesPerSequence <= end) {\n              var secondByte, thirdByte, fourthByte, tempCodePoint;\n              switch (bytesPerSequence) {\n                case 1:\n                  if (firstByte < 0x80) {\n                    codePoint = firstByte;\n                  }\n                  break;\n                case 2:\n                  secondByte = buf[i + 1];\n                  if ((secondByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                    if (tempCodePoint > 0x7F) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n                  break;\n                case 3:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n                  break;\n                case 4:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n                  fourthByte = buf[i + 3];\n                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n              }\n            }\n            if (codePoint === null) {\n              // we did not generate a valid codePoint so insert a\n              // replacement char (U+FFFD) and advance only 1 byte\n              codePoint = 0xFFFD;\n              bytesPerSequence = 1;\n            } else if (codePoint > 0xFFFF) {\n              // encode to utf16 (surrogate pair dance)\n              codePoint -= 0x10000;\n              res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n              codePoint = 0xDC00 | codePoint & 0x3FF;\n            }\n            res.push(codePoint);\n            i += bytesPerSequence;\n          }\n          return decodeCodePointsArray(res);\n        }\n\n        // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n        // the lowest limit is Chrome, with 0x10000 args.\n        // We go 1 magnitude less, for safety\n        var MAX_ARGUMENTS_LENGTH = 0x1000;\n        function decodeCodePointsArray(codePoints) {\n          var len = codePoints.length;\n          if (len <= MAX_ARGUMENTS_LENGTH) {\n            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n          }\n\n          // Decode in chunks to avoid \"call stack size exceeded\".\n          var res = '';\n          var i = 0;\n          while (i < len) {\n            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n          }\n          return res;\n        }\n        function asciiSlice(buf, start, end) {\n          var ret = '';\n          end = Math.min(buf.length, end);\n          for (var i = start; i < end; ++i) {\n            ret += String.fromCharCode(buf[i] & 0x7F);\n          }\n          return ret;\n        }\n        function latin1Slice(buf, start, end) {\n          var ret = '';\n          end = Math.min(buf.length, end);\n          for (var i = start; i < end; ++i) {\n            ret += String.fromCharCode(buf[i]);\n          }\n          return ret;\n        }\n        function hexSlice(buf, start, end) {\n          var len = buf.length;\n          if (!start || start < 0) start = 0;\n          if (!end || end < 0 || end > len) end = len;\n          var out = '';\n          for (var i = start; i < end; ++i) {\n            out += toHex(buf[i]);\n          }\n          return out;\n        }\n        function utf16leSlice(buf, start, end) {\n          var bytes = buf.slice(start, end);\n          var res = '';\n          for (var i = 0; i < bytes.length; i += 2) {\n            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n          }\n          return res;\n        }\n        Buffer.prototype.slice = function slice(start, end) {\n          var len = this.length;\n          start = ~~start;\n          end = end === undefined ? len : ~~end;\n          if (start < 0) {\n            start += len;\n            if (start < 0) start = 0;\n          } else if (start > len) {\n            start = len;\n          }\n          if (end < 0) {\n            end += len;\n            if (end < 0) end = 0;\n          } else if (end > len) {\n            end = len;\n          }\n          if (end < start) end = start;\n          var newBuf = this.subarray(start, end);\n          // Return an augmented `Uint8Array` instance\n          newBuf.__proto__ = Buffer.prototype;\n          return newBuf;\n        };\n\n        /*\n         * Need to make sure that buffer isn't trying to write out of bounds.\n         */\n        function checkOffset(offset, ext, length) {\n          if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n        }\n        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n          offset = offset >>> 0;\n          byteLength = byteLength >>> 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var val = this[offset];\n          var mul = 1;\n          var i = 0;\n          while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n          }\n          return val;\n        };\n        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n          offset = offset >>> 0;\n          byteLength = byteLength >>> 0;\n          if (!noAssert) {\n            checkOffset(offset, byteLength, this.length);\n          }\n          var val = this[offset + --byteLength];\n          var mul = 1;\n          while (byteLength > 0 && (mul *= 0x100)) {\n            val += this[offset + --byteLength] * mul;\n          }\n          return val;\n        };\n        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 1, this.length);\n          return this[offset];\n        };\n        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          return this[offset] | this[offset + 1] << 8;\n        };\n        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          return this[offset] << 8 | this[offset + 1];\n        };\n        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n        };\n        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n        };\n        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n          offset = offset >>> 0;\n          byteLength = byteLength >>> 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var val = this[offset];\n          var mul = 1;\n          var i = 0;\n          while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n          }\n          mul *= 0x80;\n          if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n          return val;\n        };\n        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n          offset = offset >>> 0;\n          byteLength = byteLength >>> 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var i = byteLength;\n          var mul = 1;\n          var val = this[offset + --i];\n          while (i > 0 && (mul *= 0x100)) {\n            val += this[offset + --i] * mul;\n          }\n          mul *= 0x80;\n          if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n          return val;\n        };\n        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 1, this.length);\n          if (!(this[offset] & 0x80)) return this[offset];\n          return (0xff - this[offset] + 1) * -1;\n        };\n        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          var val = this[offset] | this[offset + 1] << 8;\n          return val & 0x8000 ? val | 0xFFFF0000 : val;\n        };\n        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          var val = this[offset + 1] | this[offset] << 8;\n          return val & 0x8000 ? val | 0xFFFF0000 : val;\n        };\n        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n        };\n        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n        };\n        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return ieee754.read(this, offset, true, 23, 4);\n        };\n        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return ieee754.read(this, offset, false, 23, 4);\n        };\n        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 8, this.length);\n          return ieee754.read(this, offset, true, 52, 8);\n        };\n        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n          offset = offset >>> 0;\n          if (!noAssert) checkOffset(offset, 8, this.length);\n          return ieee754.read(this, offset, false, 52, 8);\n        };\n        function checkInt(buf, value, offset, ext, max, min) {\n          if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n          if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n          if (offset + ext > buf.length) throw new RangeError('Index out of range');\n        }\n        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          byteLength = byteLength >>> 0;\n          if (!noAssert) {\n            var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n          }\n          var mul = 1;\n          var i = 0;\n          this[offset] = value & 0xFF;\n          while (++i < byteLength && (mul *= 0x100)) {\n            this[offset + i] = value / mul & 0xFF;\n          }\n          return offset + byteLength;\n        };\n        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          byteLength = byteLength >>> 0;\n          if (!noAssert) {\n            var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n          }\n          var i = byteLength - 1;\n          var mul = 1;\n          this[offset + i] = value & 0xFF;\n          while (--i >= 0 && (mul *= 0x100)) {\n            this[offset + i] = value / mul & 0xFF;\n          }\n          return offset + byteLength;\n        };\n        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n          this[offset] = value & 0xff;\n          return offset + 1;\n        };\n        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n          this[offset] = value & 0xff;\n          this[offset + 1] = value >>> 8;\n          return offset + 2;\n        };\n        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n          this[offset] = value >>> 8;\n          this[offset + 1] = value & 0xff;\n          return offset + 2;\n        };\n        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n          this[offset + 3] = value >>> 24;\n          this[offset + 2] = value >>> 16;\n          this[offset + 1] = value >>> 8;\n          this[offset] = value & 0xff;\n          return offset + 4;\n        };\n        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n          this[offset] = value >>> 24;\n          this[offset + 1] = value >>> 16;\n          this[offset + 2] = value >>> 8;\n          this[offset + 3] = value & 0xff;\n          return offset + 4;\n        };\n        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) {\n            var limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n          }\n          var i = 0;\n          var mul = 1;\n          var sub = 0;\n          this[offset] = value & 0xFF;\n          while (++i < byteLength && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n              sub = 1;\n            }\n            this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n          }\n          return offset + byteLength;\n        };\n        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) {\n            var limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n          }\n          var i = byteLength - 1;\n          var mul = 1;\n          var sub = 0;\n          this[offset + i] = value & 0xFF;\n          while (--i >= 0 && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n              sub = 1;\n            }\n            this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n          }\n          return offset + byteLength;\n        };\n        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n          if (value < 0) value = 0xff + value + 1;\n          this[offset] = value & 0xff;\n          return offset + 1;\n        };\n        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n          this[offset] = value & 0xff;\n          this[offset + 1] = value >>> 8;\n          return offset + 2;\n        };\n        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n          this[offset] = value >>> 8;\n          this[offset + 1] = value & 0xff;\n          return offset + 2;\n        };\n        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n          this[offset] = value & 0xff;\n          this[offset + 1] = value >>> 8;\n          this[offset + 2] = value >>> 16;\n          this[offset + 3] = value >>> 24;\n          return offset + 4;\n        };\n        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n          if (value < 0) value = 0xffffffff + value + 1;\n          this[offset] = value >>> 24;\n          this[offset + 1] = value >>> 16;\n          this[offset + 2] = value >>> 8;\n          this[offset + 3] = value & 0xff;\n          return offset + 4;\n        };\n        function checkIEEE754(buf, value, offset, ext, max, min) {\n          if (offset + ext > buf.length) throw new RangeError('Index out of range');\n          if (offset < 0) throw new RangeError('Index out of range');\n        }\n        function writeFloat(buf, value, offset, littleEndian, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) {\n            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n          }\n          ieee754.write(buf, value, offset, littleEndian, 23, 4);\n          return offset + 4;\n        }\n        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n          return writeFloat(this, value, offset, true, noAssert);\n        };\n        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n          return writeFloat(this, value, offset, false, noAssert);\n        };\n        function writeDouble(buf, value, offset, littleEndian, noAssert) {\n          value = +value;\n          offset = offset >>> 0;\n          if (!noAssert) {\n            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n          }\n          ieee754.write(buf, value, offset, littleEndian, 52, 8);\n          return offset + 8;\n        }\n        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n          return writeDouble(this, value, offset, true, noAssert);\n        };\n        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n          return writeDouble(this, value, offset, false, noAssert);\n        };\n\n        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n        Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n          if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n          if (!start) start = 0;\n          if (!end && end !== 0) end = this.length;\n          if (targetStart >= target.length) targetStart = target.length;\n          if (!targetStart) targetStart = 0;\n          if (end > 0 && end < start) end = start;\n\n          // Copy 0 bytes; we're done\n          if (end === start) return 0;\n          if (target.length === 0 || this.length === 0) return 0;\n\n          // Fatal error conditions\n          if (targetStart < 0) {\n            throw new RangeError('targetStart out of bounds');\n          }\n          if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n          if (end < 0) throw new RangeError('sourceEnd out of bounds');\n\n          // Are we oob?\n          if (end > this.length) end = this.length;\n          if (target.length - targetStart < end - start) {\n            end = target.length - targetStart + start;\n          }\n          var len = end - start;\n          if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n            // Use built-in when available, missing from IE11\n            this.copyWithin(targetStart, start, end);\n          } else if (this === target && start < targetStart && targetStart < end) {\n            // descending copy from end\n            for (var i = len - 1; i >= 0; --i) {\n              target[i + targetStart] = this[i + start];\n            }\n          } else {\n            Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n          }\n          return len;\n        };\n\n        // Usage:\n        //    buffer.fill(number[, offset[, end]])\n        //    buffer.fill(buffer[, offset[, end]])\n        //    buffer.fill(string[, offset[, end]][, encoding])\n        Buffer.prototype.fill = function fill(val, start, end, encoding) {\n          // Handle string cases:\n          if (typeof val === 'string') {\n            if (typeof start === 'string') {\n              encoding = start;\n              start = 0;\n              end = this.length;\n            } else if (typeof end === 'string') {\n              encoding = end;\n              end = this.length;\n            }\n            if (encoding !== undefined && typeof encoding !== 'string') {\n              throw new TypeError('encoding must be a string');\n            }\n            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n              throw new TypeError('Unknown encoding: ' + encoding);\n            }\n            if (val.length === 1) {\n              var code = val.charCodeAt(0);\n              if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {\n                // Fast path: If `val` fits into a single byte, use that numeric value.\n                val = code;\n              }\n            }\n          } else if (typeof val === 'number') {\n            val = val & 255;\n          }\n\n          // Invalid ranges are not set to a default, so can range check early.\n          if (start < 0 || this.length < start || this.length < end) {\n            throw new RangeError('Out of range index');\n          }\n          if (end <= start) {\n            return this;\n          }\n          start = start >>> 0;\n          end = end === undefined ? this.length : end >>> 0;\n          if (!val) val = 0;\n          var i;\n          if (typeof val === 'number') {\n            for (i = start; i < end; ++i) {\n              this[i] = val;\n            }\n          } else {\n            var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n            var len = bytes.length;\n            if (len === 0) {\n              throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n            }\n            for (i = 0; i < end - start; ++i) {\n              this[i + start] = bytes[i % len];\n            }\n          }\n          return this;\n        };\n\n        // HELPER FUNCTIONS\n        // ================\n\n        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n        function base64clean(str) {\n          // Node takes equal signs as end of the Base64 encoding\n          str = str.split('=')[0];\n          // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n          str = str.trim().replace(INVALID_BASE64_RE, '');\n          // Node converts strings with length < 2 to ''\n          if (str.length < 2) return '';\n          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n          while (str.length % 4 !== 0) {\n            str = str + '=';\n          }\n          return str;\n        }\n        function toHex(n) {\n          if (n < 16) return '0' + n.toString(16);\n          return n.toString(16);\n        }\n        function utf8ToBytes(string, units) {\n          units = units || Infinity;\n          var codePoint;\n          var length = string.length;\n          var leadSurrogate = null;\n          var bytes = [];\n          for (var i = 0; i < length; ++i) {\n            codePoint = string.charCodeAt(i);\n\n            // is surrogate component\n            if (codePoint > 0xD7FF && codePoint < 0xE000) {\n              // last char was a lead\n              if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                  // unexpected trail\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  continue;\n                } else if (i + 1 === length) {\n                  // unpaired lead\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  continue;\n                }\n\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n              }\n\n              // 2 leads in a row\n              if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n              }\n\n              // valid surrogate pair\n              codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n            } else if (leadSurrogate) {\n              // valid bmp char, but last char was a lead\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n            }\n            leadSurrogate = null;\n\n            // encode utf8\n            if (codePoint < 0x80) {\n              if ((units -= 1) < 0) break;\n              bytes.push(codePoint);\n            } else if (codePoint < 0x800) {\n              if ((units -= 2) < 0) break;\n              bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n            } else if (codePoint < 0x10000) {\n              if ((units -= 3) < 0) break;\n              bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n            } else if (codePoint < 0x110000) {\n              if ((units -= 4) < 0) break;\n              bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n            } else {\n              throw new Error('Invalid code point');\n            }\n          }\n          return bytes;\n        }\n        function asciiToBytes(str) {\n          var byteArray = [];\n          for (var i = 0; i < str.length; ++i) {\n            // Node's code seems to be doing this and not & 0x7F..\n            byteArray.push(str.charCodeAt(i) & 0xFF);\n          }\n          return byteArray;\n        }\n        function utf16leToBytes(str, units) {\n          var c, hi, lo;\n          var byteArray = [];\n          for (var i = 0; i < str.length; ++i) {\n            if ((units -= 2) < 0) break;\n            c = str.charCodeAt(i);\n            hi = c >> 8;\n            lo = c % 256;\n            byteArray.push(lo);\n            byteArray.push(hi);\n          }\n          return byteArray;\n        }\n        function base64ToBytes(str) {\n          return base64.toByteArray(base64clean(str));\n        }\n        function blitBuffer(src, dst, offset, length) {\n          for (var i = 0; i < length; ++i) {\n            if (i + offset >= dst.length || i >= src.length) break;\n            dst[i + offset] = src[i];\n          }\n          return i;\n        }\n\n        // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n        // the `instanceof` check but they should be treated as of that type.\n        // See: https://github.com/feross/buffer/issues/166\n        function isInstance(obj, type) {\n          return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n        }\n        function numberIsNaN(obj) {\n          // For IE11 support\n          return obj !== obj; // eslint-disable-line no-self-compare\n        }\n      }).call(this, require(\"buffer\").Buffer);\n    }, {\n      \"base64-js\": 10,\n      \"buffer\": 12,\n      \"ieee754\": 87\n    }],\n    13: [function (require, module, exports) {\n      (function (Buffer) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        // NOTE: These type checking functions intentionally don't use `instanceof`\n        // because it is fragile and can be easily faked with `Object.create()`.\n\n        function isArray(arg) {\n          if (Array.isArray) {\n            return Array.isArray(arg);\n          }\n          return objectToString(arg) === '[object Array]';\n        }\n        exports.isArray = isArray;\n        function isBoolean(arg) {\n          return typeof arg === 'boolean';\n        }\n        exports.isBoolean = isBoolean;\n        function isNull(arg) {\n          return arg === null;\n        }\n        exports.isNull = isNull;\n        function isNullOrUndefined(arg) {\n          return arg == null;\n        }\n        exports.isNullOrUndefined = isNullOrUndefined;\n        function isNumber(arg) {\n          return typeof arg === 'number';\n        }\n        exports.isNumber = isNumber;\n        function isString(arg) {\n          return typeof arg === 'string';\n        }\n        exports.isString = isString;\n        function isSymbol(arg) {\n          return _typeof(arg) === 'symbol';\n        }\n        exports.isSymbol = isSymbol;\n        function isUndefined(arg) {\n          return arg === void 0;\n        }\n        exports.isUndefined = isUndefined;\n        function isRegExp(re) {\n          return objectToString(re) === '[object RegExp]';\n        }\n        exports.isRegExp = isRegExp;\n        function isObject(arg) {\n          return _typeof(arg) === 'object' && arg !== null;\n        }\n        exports.isObject = isObject;\n        function isDate(d) {\n          return objectToString(d) === '[object Date]';\n        }\n        exports.isDate = isDate;\n        function isError(e) {\n          return objectToString(e) === '[object Error]' || e instanceof Error;\n        }\n        exports.isError = isError;\n        function isFunction(arg) {\n          return typeof arg === 'function';\n        }\n        exports.isFunction = isFunction;\n        function isPrimitive(arg) {\n          return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' ||\n          // ES6 symbol\n          typeof arg === 'undefined';\n        }\n        exports.isPrimitive = isPrimitive;\n        exports.isBuffer = Buffer.isBuffer;\n        function objectToString(o) {\n          return Object.prototype.toString.call(o);\n        }\n      }).call(this, {\n        \"isBuffer\": require(\"../../is-buffer/index.js\")\n      });\n    }, {\n      \"../../is-buffer/index.js\": 89\n    }],\n    14: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"type/value/is\"),\n        ensureValue = require(\"type/value/ensure\"),\n        ensurePlainFunction = require(\"type/plain-function/ensure\"),\n        copy = require(\"es5-ext/object/copy\"),\n        normalizeOptions = require(\"es5-ext/object/normalize-options\"),\n        map = require(\"es5-ext/object/map\");\n      var bind = Function.prototype.bind,\n        defineProperty = Object.defineProperty,\n        hasOwnProperty = Object.prototype.hasOwnProperty,\n        define;\n      define = function define(name, desc, options) {\n        var value = ensureValue(desc) && ensurePlainFunction(desc.value),\n          dgs;\n        dgs = copy(desc);\n        delete dgs.writable;\n        delete dgs.value;\n        dgs.get = function () {\n          if (!options.overwriteDefinition && hasOwnProperty.call(this, name)) return value;\n          desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);\n          defineProperty(this, name, desc);\n          return this[name];\n        };\n        return dgs;\n      };\n      module.exports = function (props /*, options*/) {\n        var options = normalizeOptions(arguments[1]);\n        if (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);\n        return map(props, function (desc, name) {\n          return define(name, desc, options);\n        });\n      };\n    }, {\n      \"es5-ext/object/copy\": 41,\n      \"es5-ext/object/map\": 49,\n      \"es5-ext/object/normalize-options\": 50,\n      \"type/plain-function/ensure\": 126,\n      \"type/value/ensure\": 130,\n      \"type/value/is\": 131\n    }],\n    15: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"type/value/is\"),\n        isPlainFunction = require(\"type/plain-function/is\"),\n        assign = require(\"es5-ext/object/assign\"),\n        normalizeOpts = require(\"es5-ext/object/normalize-options\"),\n        contains = require(\"es5-ext/string/#/contains\");\n      var d = module.exports = function (dscr, value /*, options*/) {\n        var c, e, w, options, desc;\n        if (arguments.length < 2 || typeof dscr !== \"string\") {\n          options = value;\n          value = dscr;\n          dscr = null;\n        } else {\n          options = arguments[2];\n        }\n        if (isValue(dscr)) {\n          c = contains.call(dscr, \"c\");\n          e = contains.call(dscr, \"e\");\n          w = contains.call(dscr, \"w\");\n        } else {\n          c = w = true;\n          e = false;\n        }\n        desc = {\n          value: value,\n          configurable: c,\n          enumerable: e,\n          writable: w\n        };\n        return !options ? desc : assign(normalizeOpts(options), desc);\n      };\n      d.gs = function (dscr, get, set /*, options*/) {\n        var c, e, options, desc;\n        if (typeof dscr !== \"string\") {\n          options = set;\n          set = get;\n          get = dscr;\n          dscr = null;\n        } else {\n          options = arguments[3];\n        }\n        if (!isValue(get)) {\n          get = undefined;\n        } else if (!isPlainFunction(get)) {\n          options = get;\n          get = set = undefined;\n        } else if (!isValue(set)) {\n          set = undefined;\n        } else if (!isPlainFunction(set)) {\n          options = set;\n          set = undefined;\n        }\n        if (isValue(dscr)) {\n          c = contains.call(dscr, \"c\");\n          e = contains.call(dscr, \"e\");\n        } else {\n          c = true;\n          e = false;\n        }\n        desc = {\n          get: get,\n          set: set,\n          configurable: c,\n          enumerable: e\n        };\n        return !options ? desc : assign(normalizeOpts(options), desc);\n      };\n    }, {\n      \"es5-ext/object/assign\": 38,\n      \"es5-ext/object/normalize-options\": 50,\n      \"es5-ext/string/#/contains\": 57,\n      \"type/plain-function/is\": 127,\n      \"type/value/is\": 131\n    }],\n    16: [function (require, module, exports) {\n      /**\n       * Helpers.\n       */\n\n      var s = 1000;\n      var m = s * 60;\n      var h = m * 60;\n      var d = h * 24;\n      var w = d * 7;\n      var y = d * 365.25;\n\n      /**\n       * Parse or format the given `val`.\n       *\n       * Options:\n       *\n       *  - `long` verbose formatting [false]\n       *\n       * @param {String|Number} val\n       * @param {Object} [options]\n       * @throws {Error} throw an error if val is not a non-empty string or a number\n       * @return {String|Number}\n       * @api public\n       */\n\n      module.exports = function (val, options) {\n        options = options || {};\n        var type = _typeof(val);\n        if (type === 'string' && val.length > 0) {\n          return parse(val);\n        } else if (type === 'number' && isFinite(val)) {\n          return options.long ? fmtLong(val) : fmtShort(val);\n        }\n        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n      };\n\n      /**\n       * Parse the given `str` and return milliseconds.\n       *\n       * @param {String} str\n       * @return {Number}\n       * @api private\n       */\n\n      function parse(str) {\n        str = String(str);\n        if (str.length > 100) {\n          return;\n        }\n        var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n        if (!match) {\n          return;\n        }\n        var n = parseFloat(match[1]);\n        var type = (match[2] || 'ms').toLowerCase();\n        switch (type) {\n          case 'years':\n          case 'year':\n          case 'yrs':\n          case 'yr':\n          case 'y':\n            return n * y;\n          case 'weeks':\n          case 'week':\n          case 'w':\n            return n * w;\n          case 'days':\n          case 'day':\n          case 'd':\n            return n * d;\n          case 'hours':\n          case 'hour':\n          case 'hrs':\n          case 'hr':\n          case 'h':\n            return n * h;\n          case 'minutes':\n          case 'minute':\n          case 'mins':\n          case 'min':\n          case 'm':\n            return n * m;\n          case 'seconds':\n          case 'second':\n          case 'secs':\n          case 'sec':\n          case 's':\n            return n * s;\n          case 'milliseconds':\n          case 'millisecond':\n          case 'msecs':\n          case 'msec':\n          case 'ms':\n            return n;\n          default:\n            return undefined;\n        }\n      }\n\n      /**\n       * Short format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n      function fmtShort(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n          return Math.round(ms / d) + 'd';\n        }\n        if (msAbs >= h) {\n          return Math.round(ms / h) + 'h';\n        }\n        if (msAbs >= m) {\n          return Math.round(ms / m) + 'm';\n        }\n        if (msAbs >= s) {\n          return Math.round(ms / s) + 's';\n        }\n        return ms + 'ms';\n      }\n\n      /**\n       * Long format for `ms`.\n       *\n       * @param {Number} ms\n       * @return {String}\n       * @api private\n       */\n\n      function fmtLong(ms) {\n        var msAbs = Math.abs(ms);\n        if (msAbs >= d) {\n          return plural(ms, msAbs, d, 'day');\n        }\n        if (msAbs >= h) {\n          return plural(ms, msAbs, h, 'hour');\n        }\n        if (msAbs >= m) {\n          return plural(ms, msAbs, m, 'minute');\n        }\n        if (msAbs >= s) {\n          return plural(ms, msAbs, s, 'second');\n        }\n        return ms + ' ms';\n      }\n\n      /**\n       * Pluralization helper.\n       */\n\n      function plural(ms, msAbs, n, name) {\n        var isPlural = msAbs >= n * 1.5;\n        return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n      }\n    }, {}],\n    17: [function (require, module, exports) {\n      (function (process) {\n        /* eslint-env browser */\n\n        /**\n         * This is the web browser implementation of `debug()`.\n         */\n\n        exports.log = log;\n        exports.formatArgs = formatArgs;\n        exports.save = save;\n        exports.load = load;\n        exports.useColors = useColors;\n        exports.storage = localstorage();\n\n        /**\n         * Colors.\n         */\n\n        exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n\n        /**\n         * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n         * and the Firebug extension (any Firefox version) are known\n         * to support \"%c\" CSS customizations.\n         *\n         * TODO: add a `localStorage` variable to explicitly enable/disable colors\n         */\n\n        // eslint-disable-next-line complexity\n        function useColors() {\n          // NB: In an Electron preload script, document will be defined but not fully\n          // initialized. Since we know we're in Chrome, we'll just detect this case\n          // explicitly\n          if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n            return true;\n          }\n\n          // Internet Explorer and Edge do not support colors.\n          if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n            return false;\n          }\n\n          // Is webkit? http://stackoverflow.com/a/16459606/376773\n          // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n          return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||\n          // Is firebug? http://stackoverflow.com/a/398120/376773\n          typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||\n          // Is firefox >= v31?\n          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n          typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||\n          // Double check webkit in userAgent just in case we are in a worker\n          typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n        }\n\n        /**\n         * Colorize log arguments if enabled.\n         *\n         * @api public\n         */\n\n        function formatArgs(args) {\n          args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n          if (!this.useColors) {\n            return;\n          }\n          var c = 'color: ' + this.color;\n          args.splice(1, 0, c, 'color: inherit');\n\n          // The final \"%c\" is somewhat tricky, because there could be other\n          // arguments passed either before or after the %c, so we need to\n          // figure out the correct index to insert the CSS into\n          var index = 0;\n          var lastC = 0;\n          args[0].replace(/%[a-zA-Z%]/g, function (match) {\n            if (match === '%%') {\n              return;\n            }\n            index++;\n            if (match === '%c') {\n              // We only are interested in the *last* %c\n              // (the user may have provided their own)\n              lastC = index;\n            }\n          });\n          args.splice(lastC, 0, c);\n        }\n\n        /**\n         * Invokes `console.log()` when available.\n         * No-op when `console.log` is not a \"function\".\n         *\n         * @api public\n         */\n        function log() {\n          // This hackery is required for IE8/9, where\n          // the `console.log` function doesn't have 'apply'\n          return (typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.log && __f__.apply(void 0, [\"log\"].concat(Array.prototype.slice.call(arguments), [\" at mqtt.js:4878\"]));\n        }\n\n        /**\n         * Save `namespaces`.\n         *\n         * @param {String} namespaces\n         * @api private\n         */\n        function save(namespaces) {\n          try {\n            if (namespaces) {\n              exports.storage.setItem('debug', namespaces);\n            } else {\n              exports.storage.removeItem('debug');\n            }\n          } catch (error) {\n            // Swallow\n            // XXX (@Qix-) should we be logging these?\n          }\n        }\n\n        /**\n         * Load `namespaces`.\n         *\n         * @return {String} returns the previously persisted debug modes\n         * @api private\n         */\n        function load() {\n          var r;\n          try {\n            r = exports.storage.getItem('debug');\n          } catch (error) {\n            // Swallow\n            // XXX (@Qix-) should we be logging these?\n          }\n\n          // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n          if (!r && typeof process !== 'undefined' && 'env' in process) {\n            r = process.env.DEBUG;\n          }\n          return r;\n        }\n\n        /**\n         * Localstorage attempts to return the localstorage.\n         *\n         * This is necessary because safari throws\n         * when a user disables cookies/localstorage\n         * and you attempt to access it.\n         *\n         * @return {LocalStorage}\n         * @api private\n         */\n\n        function localstorage() {\n          try {\n            // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n            // The Browser also has localStorage in the global context.\n            return localStorage;\n          } catch (error) {\n            // Swallow\n            // XXX (@Qix-) should we be logging these?\n          }\n        }\n        module.exports = require('./common')(exports);\n        var formatters = module.exports.formatters;\n\n        /**\n         * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n         */\n\n        formatters.j = function (v) {\n          try {\n            return JSON.stringify(v);\n          } catch (error) {\n            return '[UnexpectedJSONParseError]: ' + error.message;\n          }\n        };\n      }).call(this, require('_process'));\n    }, {\n      \"./common\": 18,\n      \"_process\": 100\n    }],\n    18: [function (require, module, exports) {\n      /**\n       * This is the common logic for both the Node.js and web browser\n       * implementations of `debug()`.\n       */\n\n      function setup(env) {\n        createDebug.debug = createDebug;\n        createDebug.default = createDebug;\n        createDebug.coerce = coerce;\n        createDebug.disable = disable;\n        createDebug.enable = enable;\n        createDebug.enabled = enabled;\n        createDebug.humanize = require('ms');\n        Object.keys(env).forEach(function (key) {\n          createDebug[key] = env[key];\n        });\n\n        /**\n        * Active `debug` instances.\n        */\n        createDebug.instances = [];\n\n        /**\n        * The currently active debug mode names, and names to skip.\n        */\n\n        createDebug.names = [];\n        createDebug.skips = [];\n\n        /**\n        * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n        *\n        * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n        */\n        createDebug.formatters = {};\n\n        /**\n        * Selects a color for a debug namespace\n        * @param {String} namespace The namespace string for the for the debug instance to be colored\n        * @return {Number|String} An ANSI color code for the given namespace\n        * @api private\n        */\n        function selectColor(namespace) {\n          var hash = 0;\n          for (var i = 0; i < namespace.length; i++) {\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n          }\n\n          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n        }\n        createDebug.selectColor = selectColor;\n\n        /**\n        * Create a debugger with the given `namespace`.\n        *\n        * @param {String} namespace\n        * @return {Function}\n        * @api public\n        */\n        function createDebug(namespace) {\n          var prevTime;\n          function debug() {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            // Disabled?\n            if (!debug.enabled) {\n              return;\n            }\n            var self = debug;\n\n            // Set `diff` timestamp\n            var curr = Number(new Date());\n            var ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== 'string') {\n              // Anything else let's inspect with %O\n              args.unshift('%O');\n            }\n\n            // Apply any `formatters` transformations\n            var index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n              // If we encounter an escaped % then don't increase the array index\n              if (match === '%%') {\n                return match;\n              }\n              index++;\n              var formatter = createDebug.formatters[format];\n              if (typeof formatter === 'function') {\n                var val = args[index];\n                match = formatter.call(self, val);\n\n                // Now we need to remove `args[index]` since it's inlined in the `format`\n                args.splice(index, 1);\n                index--;\n              }\n              return match;\n            });\n\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            var logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n          }\n          debug.namespace = namespace;\n          debug.enabled = createDebug.enabled(namespace);\n          debug.useColors = createDebug.useColors();\n          debug.color = selectColor(namespace);\n          debug.destroy = destroy;\n          debug.extend = extend;\n          // Debug.formatArgs = formatArgs;\n          // debug.rawLog = rawLog;\n\n          // env-specific initialization logic for debug instances\n          if (typeof createDebug.init === 'function') {\n            createDebug.init(debug);\n          }\n          createDebug.instances.push(debug);\n          return debug;\n        }\n        function destroy() {\n          var index = createDebug.instances.indexOf(this);\n          if (index !== -1) {\n            createDebug.instances.splice(index, 1);\n            return true;\n          }\n          return false;\n        }\n        function extend(namespace, delimiter) {\n          var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n          newDebug.log = this.log;\n          return newDebug;\n        }\n\n        /**\n        * Enables a debug mode by namespaces. This can include modes\n        * separated by a colon and wildcards.\n        *\n        * @param {String} namespaces\n        * @api public\n        */\n        function enable(namespaces) {\n          createDebug.save(namespaces);\n          createDebug.names = [];\n          createDebug.skips = [];\n          var i;\n          var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n          var len = split.length;\n          for (i = 0; i < len; i++) {\n            if (!split[i]) {\n              // ignore empty strings\n              continue;\n            }\n            namespaces = split[i].replace(/\\*/g, '.*?');\n            if (namespaces[0] === '-') {\n              createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n            } else {\n              createDebug.names.push(new RegExp('^' + namespaces + '$'));\n            }\n          }\n          for (i = 0; i < createDebug.instances.length; i++) {\n            var instance = createDebug.instances[i];\n            instance.enabled = createDebug.enabled(instance.namespace);\n          }\n        }\n\n        /**\n        * Disable debug output.\n        *\n        * @return {String} namespaces\n        * @api public\n        */\n        function disable() {\n          var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {\n            return '-' + namespace;\n          }))).join(',');\n          createDebug.enable('');\n          return namespaces;\n        }\n\n        /**\n        * Returns true if the given mode name is enabled, false otherwise.\n        *\n        * @param {String} name\n        * @return {Boolean}\n        * @api public\n        */\n        function enabled(name) {\n          if (name[name.length - 1] === '*') {\n            return true;\n          }\n          var i;\n          var len;\n          for (i = 0, len = createDebug.skips.length; i < len; i++) {\n            if (createDebug.skips[i].test(name)) {\n              return false;\n            }\n          }\n          for (i = 0, len = createDebug.names.length; i < len; i++) {\n            if (createDebug.names[i].test(name)) {\n              return true;\n            }\n          }\n          return false;\n        }\n\n        /**\n        * Convert regexp to namespace\n        *\n        * @param {RegExp} regxep\n        * @return {String} namespace\n        * @api private\n        */\n        function toNamespace(regexp) {\n          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n        }\n\n        /**\n        * Coerce `val`.\n        *\n        * @param {Mixed} val\n        * @return {Mixed}\n        * @api private\n        */\n        function coerce(val) {\n          if (val instanceof Error) {\n            return val.stack || val.message;\n          }\n          return val;\n        }\n        createDebug.enable(createDebug.load());\n        return createDebug;\n      }\n      module.exports = setup;\n    }, {\n      \"ms\": 16\n    }],\n    19: [function (require, module, exports) {\n      (function (process, Buffer) {\n        var stream = require('readable-stream');\n        var eos = require('end-of-stream');\n        var inherits = require('inherits');\n        var shift = require('stream-shift');\n        var SIGNAL_FLUSH = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]);\n        var onuncork = function onuncork(self, fn) {\n          if (self._corked) self.once('uncork', fn);else fn();\n        };\n        var autoDestroy = function autoDestroy(self, err) {\n          if (self._autoDestroy) self.destroy(err);\n        };\n        var destroyer = function destroyer(self, end) {\n          return function (err) {\n            if (err) autoDestroy(self, err.message === 'premature close' ? null : err);else if (end && !self._ended) self.end();\n          };\n        };\n        var end = function end(ws, fn) {\n          if (!ws) return fn();\n          if (ws._writableState && ws._writableState.finished) return fn();\n          if (ws._writableState) return ws.end(fn);\n          ws.end();\n          fn();\n        };\n        var toStreams2 = function toStreams2(rs) {\n          return new stream.Readable({\n            objectMode: true,\n            highWaterMark: 16\n          }).wrap(rs);\n        };\n        var Duplexify = function Duplexify(writable, readable, opts) {\n          if (!(this instanceof Duplexify)) return new Duplexify(writable, readable, opts);\n          stream.Duplex.call(this, opts);\n          this._writable = null;\n          this._readable = null;\n          this._readable2 = null;\n          this._autoDestroy = !opts || opts.autoDestroy !== false;\n          this._forwardDestroy = !opts || opts.destroy !== false;\n          this._forwardEnd = !opts || opts.end !== false;\n          this._corked = 1; // start corked\n          this._ondrain = null;\n          this._drained = false;\n          this._forwarding = false;\n          this._unwrite = null;\n          this._unread = null;\n          this._ended = false;\n          this.destroyed = false;\n          if (writable) this.setWritable(writable);\n          if (readable) this.setReadable(readable);\n        };\n        inherits(Duplexify, stream.Duplex);\n        Duplexify.obj = function (writable, readable, opts) {\n          if (!opts) opts = {};\n          opts.objectMode = true;\n          opts.highWaterMark = 16;\n          return new Duplexify(writable, readable, opts);\n        };\n        Duplexify.prototype.cork = function () {\n          if (++this._corked === 1) this.emit('cork');\n        };\n        Duplexify.prototype.uncork = function () {\n          if (this._corked && --this._corked === 0) this.emit('uncork');\n        };\n        Duplexify.prototype.setWritable = function (writable) {\n          if (this._unwrite) this._unwrite();\n          if (this.destroyed) {\n            if (writable && writable.destroy) writable.destroy();\n            return;\n          }\n          if (writable === null || writable === false) {\n            this.end();\n            return;\n          }\n          var self = this;\n          var unend = eos(writable, {\n            writable: true,\n            readable: false\n          }, destroyer(this, this._forwardEnd));\n          var ondrain = function ondrain() {\n            var ondrain = self._ondrain;\n            self._ondrain = null;\n            if (ondrain) ondrain();\n          };\n          var clear = function clear() {\n            self._writable.removeListener('drain', ondrain);\n            unend();\n          };\n          if (this._unwrite) process.nextTick(ondrain); // force a drain on stream reset to avoid livelocks\n\n          this._writable = writable;\n          this._writable.on('drain', ondrain);\n          this._unwrite = clear;\n          this.uncork(); // always uncork setWritable\n        };\n\n        Duplexify.prototype.setReadable = function (readable) {\n          if (this._unread) this._unread();\n          if (this.destroyed) {\n            if (readable && readable.destroy) readable.destroy();\n            return;\n          }\n          if (readable === null || readable === false) {\n            this.push(null);\n            this.resume();\n            return;\n          }\n          var self = this;\n          var unend = eos(readable, {\n            writable: false,\n            readable: true\n          }, destroyer(this));\n          var onreadable = function onreadable() {\n            self._forward();\n          };\n          var onend = function onend() {\n            self.push(null);\n          };\n          var clear = function clear() {\n            self._readable2.removeListener('readable', onreadable);\n            self._readable2.removeListener('end', onend);\n            unend();\n          };\n          this._drained = true;\n          this._readable = readable;\n          this._readable2 = readable._readableState ? readable : toStreams2(readable);\n          this._readable2.on('readable', onreadable);\n          this._readable2.on('end', onend);\n          this._unread = clear;\n          this._forward();\n        };\n        Duplexify.prototype._read = function () {\n          this._drained = true;\n          this._forward();\n        };\n        Duplexify.prototype._forward = function () {\n          if (this._forwarding || !this._readable2 || !this._drained) return;\n          this._forwarding = true;\n          var data;\n          while (this._drained && (data = shift(this._readable2)) !== null) {\n            if (this.destroyed) continue;\n            this._drained = this.push(data);\n          }\n          this._forwarding = false;\n        };\n        Duplexify.prototype.destroy = function (err) {\n          if (this.destroyed) return;\n          this.destroyed = true;\n          var self = this;\n          process.nextTick(function () {\n            self._destroy(err);\n          });\n        };\n        Duplexify.prototype._destroy = function (err) {\n          if (err) {\n            var ondrain = this._ondrain;\n            this._ondrain = null;\n            if (ondrain) ondrain(err);else this.emit('error', err);\n          }\n          if (this._forwardDestroy) {\n            if (this._readable && this._readable.destroy) this._readable.destroy();\n            if (this._writable && this._writable.destroy) this._writable.destroy();\n          }\n          this.emit('close');\n        };\n        Duplexify.prototype._write = function (data, enc, cb) {\n          if (this.destroyed) return cb();\n          if (this._corked) return onuncork(this, this._write.bind(this, data, enc, cb));\n          if (data === SIGNAL_FLUSH) return this._finish(cb);\n          if (!this._writable) return cb();\n          if (this._writable.write(data) === false) this._ondrain = cb;else cb();\n        };\n        Duplexify.prototype._finish = function (cb) {\n          var self = this;\n          this.emit('preend');\n          onuncork(this, function () {\n            end(self._forwardEnd && self._writable, function () {\n              // haxx to not emit prefinish twice\n              if (self._writableState.prefinished === false) self._writableState.prefinished = true;\n              self.emit('prefinish');\n              onuncork(self, cb);\n            });\n          });\n        };\n        Duplexify.prototype.end = function (data, enc, cb) {\n          if (typeof data === 'function') return this.end(null, null, data);\n          if (typeof enc === 'function') return this.end(data, null, enc);\n          this._ended = true;\n          if (data) this.write(data);\n          if (!this._writableState.ending) this.write(SIGNAL_FLUSH);\n          return stream.Writable.prototype.end.call(this, cb);\n        };\n        module.exports = Duplexify;\n      }).call(this, require('_process'), require(\"buffer\").Buffer);\n    }, {\n      \"_process\": 100,\n      \"buffer\": 12,\n      \"end-of-stream\": 20,\n      \"inherits\": 88,\n      \"readable-stream\": 116,\n      \"stream-shift\": 119\n    }],\n    20: [function (require, module, exports) {\n      var once = require('once');\n      var noop = function noop() {};\n      var isRequest = function isRequest(stream) {\n        return stream.setHeader && typeof stream.abort === 'function';\n      };\n      var isChildProcess = function isChildProcess(stream) {\n        return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;\n      };\n      var eos = function eos(stream, opts, callback) {\n        if (typeof opts === 'function') return eos(stream, null, opts);\n        if (!opts) opts = {};\n        callback = once(callback || noop);\n        var ws = stream._writableState;\n        var rs = stream._readableState;\n        var readable = opts.readable || opts.readable !== false && stream.readable;\n        var writable = opts.writable || opts.writable !== false && stream.writable;\n        var onlegacyfinish = function onlegacyfinish() {\n          if (!stream.writable) onfinish();\n        };\n        var onfinish = function onfinish() {\n          writable = false;\n          if (!readable) callback.call(stream);\n        };\n        var onend = function onend() {\n          readable = false;\n          if (!writable) callback.call(stream);\n        };\n        var onexit = function onexit(exitCode) {\n          callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n        };\n        var onerror = function onerror(err) {\n          callback.call(stream, err);\n        };\n        var onclose = function onclose() {\n          if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));\n          if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));\n        };\n        var onrequest = function onrequest() {\n          stream.req.on('finish', onfinish);\n        };\n        if (isRequest(stream)) {\n          stream.on('complete', onfinish);\n          stream.on('abort', onclose);\n          if (stream.req) onrequest();else stream.on('request', onrequest);\n        } else if (writable && !ws) {\n          // legacy streams\n          stream.on('end', onlegacyfinish);\n          stream.on('close', onlegacyfinish);\n        }\n        if (isChildProcess(stream)) stream.on('exit', onexit);\n        stream.on('end', onend);\n        stream.on('finish', onfinish);\n        if (opts.error !== false) stream.on('error', onerror);\n        stream.on('close', onclose);\n        return function () {\n          stream.removeListener('complete', onfinish);\n          stream.removeListener('abort', onclose);\n          stream.removeListener('request', onrequest);\n          if (stream.req) stream.req.removeListener('finish', onfinish);\n          stream.removeListener('end', onlegacyfinish);\n          stream.removeListener('close', onlegacyfinish);\n          stream.removeListener('finish', onfinish);\n          stream.removeListener('exit', onexit);\n          stream.removeListener('end', onend);\n          stream.removeListener('error', onerror);\n          stream.removeListener('close', onclose);\n        };\n      };\n      module.exports = eos;\n    }, {\n      \"once\": 98\n    }],\n    21: [function (require, module, exports) {\n      // Inspired by Google Closure:\n      // http://closure-library.googlecode.com/svn/docs/\n      // closure_goog_array_array.js.html#goog.array.clear\n\n      \"use strict\";\n\n      var value = require(\"../../object/valid-value\");\n      module.exports = function () {\n        value(this).length = 0;\n        return this;\n      };\n    }, {\n      \"../../object/valid-value\": 56\n    }],\n    22: [function (require, module, exports) {\n      \"use strict\";\n\n      var numberIsNaN = require(\"../../number/is-nan\"),\n        toPosInt = require(\"../../number/to-pos-integer\"),\n        value = require(\"../../object/valid-value\"),\n        indexOf = Array.prototype.indexOf,\n        objHasOwnProperty = Object.prototype.hasOwnProperty,\n        abs = Math.abs,\n        floor = Math.floor;\n      module.exports = function (searchElement /*, fromIndex*/) {\n        var i, length, fromIndex, val;\n        if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);\n        length = toPosInt(value(this).length);\n        fromIndex = arguments[1];\n        if (isNaN(fromIndex)) fromIndex = 0;else if (fromIndex >= 0) fromIndex = floor(fromIndex);else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));\n        for (i = fromIndex; i < length; ++i) {\n          if (objHasOwnProperty.call(this, i)) {\n            val = this[i];\n            if (numberIsNaN(val)) return i; // Jslint: ignore\n          }\n        }\n\n        return -1;\n      };\n    }, {\n      \"../../number/is-nan\": 32,\n      \"../../number/to-pos-integer\": 36,\n      \"../../object/valid-value\": 56\n    }],\n    23: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? Array.from : require(\"./shim\");\n    }, {\n      \"./is-implemented\": 24,\n      \"./shim\": 25\n    }],\n    24: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var from = Array.from,\n          arr,\n          result;\n        if (typeof from !== \"function\") return false;\n        arr = [\"raz\", \"dwa\"];\n        result = from(arr);\n        return Boolean(result && result !== arr && result[1] === \"dwa\");\n      };\n    }, {}],\n    25: [function (require, module, exports) {\n      \"use strict\";\n\n      var iteratorSymbol = require(\"es6-symbol\").iterator,\n        isArguments = require(\"../../function/is-arguments\"),\n        isFunction = require(\"../../function/is-function\"),\n        toPosInt = require(\"../../number/to-pos-integer\"),\n        callable = require(\"../../object/valid-callable\"),\n        validValue = require(\"../../object/valid-value\"),\n        isValue = require(\"../../object/is-value\"),\n        isString = require(\"../../string/is-string\"),\n        isArray = Array.isArray,\n        call = Function.prototype.call,\n        desc = {\n          configurable: true,\n          enumerable: true,\n          writable: true,\n          value: null\n        },\n        defineProperty = Object.defineProperty;\n\n      // eslint-disable-next-line complexity, max-lines-per-function\n      module.exports = function (arrayLike /*, mapFn, thisArg*/) {\n        var mapFn = arguments[1],\n          thisArg = arguments[2],\n          Context,\n          i,\n          j,\n          arr,\n          length,\n          code,\n          iterator,\n          result,\n          getIterator,\n          value;\n        arrayLike = Object(validValue(arrayLike));\n        if (isValue(mapFn)) callable(mapFn);\n        if (!this || this === Array || !isFunction(this)) {\n          // Result: Plain array\n          if (!mapFn) {\n            if (isArguments(arrayLike)) {\n              // Source: Arguments\n              length = arrayLike.length;\n              if (length !== 1) return Array.apply(null, arrayLike);\n              arr = new Array(1);\n              arr[0] = arrayLike[0];\n              return arr;\n            }\n            if (isArray(arrayLike)) {\n              // Source: Array\n              arr = new Array(length = arrayLike.length);\n              for (i = 0; i < length; ++i) {\n                arr[i] = arrayLike[i];\n              }\n              return arr;\n            }\n          }\n          arr = [];\n        } else {\n          // Result: Non plain array\n          Context = this;\n        }\n        if (!isArray(arrayLike)) {\n          if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {\n            // Source: Iterator\n            iterator = callable(getIterator).call(arrayLike);\n            if (Context) arr = new Context();\n            result = iterator.next();\n            i = 0;\n            while (!result.done) {\n              value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;\n              if (Context) {\n                desc.value = value;\n                defineProperty(arr, i, desc);\n              } else {\n                arr[i] = value;\n              }\n              result = iterator.next();\n              ++i;\n            }\n            length = i;\n          } else if (isString(arrayLike)) {\n            // Source: String\n            length = arrayLike.length;\n            if (Context) arr = new Context();\n            for (i = 0, j = 0; i < length; ++i) {\n              value = arrayLike[i];\n              if (i + 1 < length) {\n                code = value.charCodeAt(0);\n                // eslint-disable-next-line max-depth\n                if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];\n              }\n              value = mapFn ? call.call(mapFn, thisArg, value, j) : value;\n              if (Context) {\n                desc.value = value;\n                defineProperty(arr, j, desc);\n              } else {\n                arr[j] = value;\n              }\n              ++j;\n            }\n            length = j;\n          }\n        }\n        if (length === undefined) {\n          // Source: array or array-like\n          length = toPosInt(arrayLike.length);\n          if (Context) arr = new Context(length);\n          for (i = 0; i < length; ++i) {\n            value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];\n            if (Context) {\n              desc.value = value;\n              defineProperty(arr, i, desc);\n            } else {\n              arr[i] = value;\n            }\n          }\n        }\n        if (Context) {\n          desc.value = null;\n          arr.length = length;\n        }\n        return arr;\n      };\n    }, {\n      \"../../function/is-arguments\": 26,\n      \"../../function/is-function\": 27,\n      \"../../number/to-pos-integer\": 36,\n      \"../../object/is-value\": 45,\n      \"../../object/valid-callable\": 55,\n      \"../../object/valid-value\": 56,\n      \"../../string/is-string\": 60,\n      \"es6-symbol\": 74\n    }],\n    26: [function (require, module, exports) {\n      \"use strict\";\n\n      var objToString = Object.prototype.toString,\n        id = objToString.call(function () {\n          return arguments;\n        }());\n      module.exports = function (value) {\n        return objToString.call(value) === id;\n      };\n    }, {}],\n    27: [function (require, module, exports) {\n      \"use strict\";\n\n      var objToString = Object.prototype.toString,\n        isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);\n      module.exports = function (value) {\n        return typeof value === \"function\" && isFunctionStringTag(objToString.call(value));\n      };\n    }, {}],\n    28: [function (require, module, exports) {\n      \"use strict\";\n\n      // eslint-disable-next-line no-empty-function\n      module.exports = function () {};\n    }, {}],\n    29: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? Math.sign : require(\"./shim\");\n    }, {\n      \"./is-implemented\": 30,\n      \"./shim\": 31\n    }],\n    30: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var sign = Math.sign;\n        if (typeof sign !== \"function\") return false;\n        return sign(10) === 1 && sign(-20) === -1;\n      };\n    }, {}],\n    31: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (value) {\n        value = Number(value);\n        if (isNaN(value) || value === 0) return value;\n        return value > 0 ? 1 : -1;\n      };\n    }, {}],\n    32: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? Number.isNaN : require(\"./shim\");\n    }, {\n      \"./is-implemented\": 33,\n      \"./shim\": 34\n    }],\n    33: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var numberIsNaN = Number.isNaN;\n        if (typeof numberIsNaN !== \"function\") return false;\n        return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);\n      };\n    }, {}],\n    34: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (value) {\n        // eslint-disable-next-line no-self-compare\n        return value !== value;\n      };\n    }, {}],\n    35: [function (require, module, exports) {\n      \"use strict\";\n\n      var sign = require(\"../math/sign\"),\n        abs = Math.abs,\n        floor = Math.floor;\n      module.exports = function (value) {\n        if (isNaN(value)) return 0;\n        value = Number(value);\n        if (value === 0 || !isFinite(value)) return value;\n        return sign(value) * floor(abs(value));\n      };\n    }, {\n      \"../math/sign\": 29\n    }],\n    36: [function (require, module, exports) {\n      \"use strict\";\n\n      var toInteger = require(\"./to-integer\"),\n        max = Math.max;\n      module.exports = function (value) {\n        return max(0, toInteger(value));\n      };\n    }, {\n      \"./to-integer\": 35\n    }],\n    37: [function (require, module, exports) {\n      // Internal method, used by iteration functions.\n      // Calls a function for each key-value pair found in object\n      // Optionally takes compareFn to iterate object in specific order\n\n      \"use strict\";\n\n      var callable = require(\"./valid-callable\"),\n        value = require(\"./valid-value\"),\n        bind = Function.prototype.bind,\n        call = Function.prototype.call,\n        keys = Object.keys,\n        objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n      module.exports = function (method, defVal) {\n        return function (obj, cb /*, thisArg, compareFn*/) {\n          var list,\n            thisArg = arguments[2],\n            compareFn = arguments[3];\n          obj = Object(value(obj));\n          callable(cb);\n          list = keys(obj);\n          if (compareFn) {\n            list.sort(typeof compareFn === \"function\" ? bind.call(compareFn, obj) : undefined);\n          }\n          if (typeof method !== \"function\") method = list[method];\n          return call.call(method, list, function (key, index) {\n            if (!objPropertyIsEnumerable.call(obj, key)) return defVal;\n            return call.call(cb, thisArg, obj[key], key, obj, index);\n          });\n        };\n      };\n    }, {\n      \"./valid-callable\": 55,\n      \"./valid-value\": 56\n    }],\n    38: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? Object.assign : require(\"./shim\");\n    }, {\n      \"./is-implemented\": 39,\n      \"./shim\": 40\n    }],\n    39: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var assign = Object.assign,\n          obj;\n        if (typeof assign !== \"function\") return false;\n        obj = {\n          foo: \"raz\"\n        };\n        assign(obj, {\n          bar: \"dwa\"\n        }, {\n          trzy: \"trzy\"\n        });\n        return obj.foo + obj.bar + obj.trzy === \"razdwatrzy\";\n      };\n    }, {}],\n    40: [function (require, module, exports) {\n      \"use strict\";\n\n      var keys = require(\"../keys\"),\n        value = require(\"../valid-value\"),\n        max = Math.max;\n      module.exports = function (dest, src /*, …srcn*/) {\n        var error,\n          i,\n          length = max(arguments.length, 2),\n          assign;\n        dest = Object(value(dest));\n        assign = function assign(key) {\n          try {\n            dest[key] = src[key];\n          } catch (e) {\n            if (!error) error = e;\n          }\n        };\n        for (i = 1; i < length; ++i) {\n          src = arguments[i];\n          keys(src).forEach(assign);\n        }\n        if (error !== undefined) throw error;\n        return dest;\n      };\n    }, {\n      \"../keys\": 46,\n      \"../valid-value\": 56\n    }],\n    41: [function (require, module, exports) {\n      \"use strict\";\n\n      var aFrom = require(\"../array/from\"),\n        assign = require(\"./assign\"),\n        value = require(\"./valid-value\");\n      module.exports = function (obj /*, propertyNames, options*/) {\n        var copy = Object(value(obj)),\n          propertyNames = arguments[1],\n          options = Object(arguments[2]);\n        if (copy !== obj && !propertyNames) return copy;\n        var result = {};\n        if (propertyNames) {\n          aFrom(propertyNames, function (propertyName) {\n            if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];\n          });\n        } else {\n          assign(result, obj);\n        }\n        return result;\n      };\n    }, {\n      \"../array/from\": 23,\n      \"./assign\": 38,\n      \"./valid-value\": 56\n    }],\n    42: [function (require, module, exports) {\n      // Workaround for http://code.google.com/p/v8/issues/detail?id=2804\n\n      \"use strict\";\n\n      var create = Object.create,\n        shim;\n      if (!require(\"./set-prototype-of/is-implemented\")()) {\n        shim = require(\"./set-prototype-of/shim\");\n      }\n      module.exports = function () {\n        var nullObject, polyProps, desc;\n        if (!shim) return create;\n        if (shim.level !== 1) return create;\n        nullObject = {};\n        polyProps = {};\n        desc = {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: undefined\n        };\n        Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {\n          if (name === \"__proto__\") {\n            polyProps[name] = {\n              configurable: true,\n              enumerable: false,\n              writable: true,\n              value: undefined\n            };\n            return;\n          }\n          polyProps[name] = desc;\n        });\n        Object.defineProperties(nullObject, polyProps);\n        Object.defineProperty(shim, \"nullPolyfill\", {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: nullObject\n        });\n        return function (prototype, props) {\n          return create(prototype === null ? nullObject : prototype, props);\n        };\n      }();\n    }, {\n      \"./set-prototype-of/is-implemented\": 53,\n      \"./set-prototype-of/shim\": 54\n    }],\n    43: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./_iterate\")(\"forEach\");\n    }, {\n      \"./_iterate\": 37\n    }],\n    44: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"./is-value\");\n      var map = {\n        function: true,\n        object: true\n      };\n      module.exports = function (value) {\n        return isValue(value) && map[_typeof(value)] || false;\n      };\n    }, {\n      \"./is-value\": 45\n    }],\n    45: [function (require, module, exports) {\n      \"use strict\";\n\n      var _undefined = require(\"../function/noop\")(); // Support ES3 engines\n\n      module.exports = function (val) {\n        return val !== _undefined && val !== null;\n      };\n    }, {\n      \"../function/noop\": 28\n    }],\n    46: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? Object.keys : require(\"./shim\");\n    }, {\n      \"./is-implemented\": 47,\n      \"./shim\": 48\n    }],\n    47: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        try {\n          Object.keys(\"primitive\");\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n    }, {}],\n    48: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"../is-value\");\n      var keys = Object.keys;\n      module.exports = function (object) {\n        return keys(isValue(object) ? Object(object) : object);\n      };\n    }, {\n      \"../is-value\": 45\n    }],\n    49: [function (require, module, exports) {\n      \"use strict\";\n\n      var callable = require(\"./valid-callable\"),\n        forEach = require(\"./for-each\"),\n        call = Function.prototype.call;\n      module.exports = function (obj, cb /*, thisArg*/) {\n        var result = {},\n          thisArg = arguments[2];\n        callable(cb);\n        forEach(obj, function (value, key, targetObj, index) {\n          result[key] = call.call(cb, thisArg, value, key, targetObj, index);\n        });\n        return result;\n      };\n    }, {\n      \"./for-each\": 43,\n      \"./valid-callable\": 55\n    }],\n    50: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"./is-value\");\n      var forEach = Array.prototype.forEach,\n        create = Object.create;\n      var process = function process(src, obj) {\n        var key;\n        for (key in src) {\n          obj[key] = src[key];\n        }\n      };\n\n      // eslint-disable-next-line no-unused-vars\n      module.exports = function (opts1 /*, …options*/) {\n        var result = create(null);\n        forEach.call(arguments, function (options) {\n          if (!isValue(options)) return;\n          process(Object(options), result);\n        });\n        return result;\n      };\n    }, {\n      \"./is-value\": 45\n    }],\n    51: [function (require, module, exports) {\n      \"use strict\";\n\n      var forEach = Array.prototype.forEach,\n        create = Object.create;\n\n      // eslint-disable-next-line no-unused-vars\n      module.exports = function (arg /*, …args*/) {\n        var set = create(null);\n        forEach.call(arguments, function (name) {\n          set[name] = true;\n        });\n        return set;\n      };\n    }, {}],\n    52: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? Object.setPrototypeOf : require(\"./shim\");\n    }, {\n      \"./is-implemented\": 53,\n      \"./shim\": 54\n    }],\n    53: [function (require, module, exports) {\n      \"use strict\";\n\n      var create = Object.create,\n        getPrototypeOf = Object.getPrototypeOf,\n        plainObject = {};\n      module.exports = function /* CustomCreate*/\n      () {\n        var setPrototypeOf = Object.setPrototypeOf,\n          customCreate = arguments[0] || create;\n        if (typeof setPrototypeOf !== \"function\") return false;\n        return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;\n      };\n    }, {}],\n    54: [function (require, module, exports) {\n      /* eslint no-proto: \"off\" */\n\n      // Big thanks to @WebReflection for sorting this out\n      // https://gist.github.com/WebReflection/5593554\n\n      \"use strict\";\n\n      var isObject = require(\"../is-object\"),\n        value = require(\"../valid-value\"),\n        objIsPrototypeOf = Object.prototype.isPrototypeOf,\n        defineProperty = Object.defineProperty,\n        nullDesc = {\n          configurable: true,\n          enumerable: false,\n          writable: true,\n          value: undefined\n        },\n        validate;\n      validate = function validate(obj, prototype) {\n        value(obj);\n        if (prototype === null || isObject(prototype)) return obj;\n        throw new TypeError(\"Prototype must be null or an object\");\n      };\n      module.exports = function (status) {\n        var fn, set;\n        if (!status) return null;\n        if (status.level === 2) {\n          if (status.set) {\n            set = status.set;\n            fn = function fn(obj, prototype) {\n              set.call(validate(obj, prototype), prototype);\n              return obj;\n            };\n          } else {\n            fn = function fn(obj, prototype) {\n              validate(obj, prototype).__proto__ = prototype;\n              return obj;\n            };\n          }\n        } else {\n          fn = function self(obj, prototype) {\n            var isNullBase;\n            validate(obj, prototype);\n            isNullBase = objIsPrototypeOf.call(self.nullPolyfill, obj);\n            if (isNullBase) delete self.nullPolyfill.__proto__;\n            if (prototype === null) prototype = self.nullPolyfill;\n            obj.__proto__ = prototype;\n            if (isNullBase) defineProperty(self.nullPolyfill, \"__proto__\", nullDesc);\n            return obj;\n          };\n        }\n        return Object.defineProperty(fn, \"level\", {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: status.level\n        });\n      }(function () {\n        var tmpObj1 = Object.create(null),\n          tmpObj2 = {},\n          set,\n          desc = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\");\n        if (desc) {\n          try {\n            set = desc.set; // Opera crashes at this point\n            set.call(tmpObj1, tmpObj2);\n          } catch (ignore) {}\n          if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return {\n            set: set,\n            level: 2\n          };\n        }\n        tmpObj1.__proto__ = tmpObj2;\n        if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return {\n          level: 2\n        };\n        tmpObj1 = {};\n        tmpObj1.__proto__ = tmpObj2;\n        if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return {\n          level: 1\n        };\n        return false;\n      }());\n      require(\"../create\");\n    }, {\n      \"../create\": 42,\n      \"../is-object\": 44,\n      \"../valid-value\": 56\n    }],\n    55: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (fn) {\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        return fn;\n      };\n    }, {}],\n    56: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"./is-value\");\n      module.exports = function (value) {\n        if (!isValue(value)) throw new TypeError(\"Cannot use null or undefined\");\n        return value;\n      };\n    }, {\n      \"./is-value\": 45\n    }],\n    57: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? String.prototype.contains : require(\"./shim\");\n    }, {\n      \"./is-implemented\": 58,\n      \"./shim\": 59\n    }],\n    58: [function (require, module, exports) {\n      \"use strict\";\n\n      var str = \"razdwatrzy\";\n      module.exports = function () {\n        if (typeof str.contains !== \"function\") return false;\n        return str.contains(\"dwa\") === true && str.contains(\"foo\") === false;\n      };\n    }, {}],\n    59: [function (require, module, exports) {\n      \"use strict\";\n\n      var indexOf = String.prototype.indexOf;\n      module.exports = function (searchString /*, position*/) {\n        return indexOf.call(this, searchString, arguments[1]) > -1;\n      };\n    }, {}],\n    60: [function (require, module, exports) {\n      \"use strict\";\n\n      var objToString = Object.prototype.toString,\n        id = objToString.call(\"\");\n      module.exports = function (value) {\n        return typeof value === \"string\" || value && _typeof(value) === \"object\" && (value instanceof String || objToString.call(value) === id) || false;\n      };\n    }, {}],\n    61: [function (require, module, exports) {\n      \"use strict\";\n\n      var setPrototypeOf = require(\"es5-ext/object/set-prototype-of\"),\n        contains = require(\"es5-ext/string/#/contains\"),\n        d = require(\"d\"),\n        _Symbol = require(\"es6-symbol\"),\n        Iterator = require(\"./\");\n      var defineProperty = Object.defineProperty,\n        ArrayIterator;\n      ArrayIterator = module.exports = function (arr, kind) {\n        if (!(this instanceof ArrayIterator)) throw new TypeError(\"Constructor requires 'new'\");\n        Iterator.call(this, arr);\n        if (!kind) kind = \"value\";else if (contains.call(kind, \"key+value\")) kind = \"key+value\";else if (contains.call(kind, \"key\")) kind = \"key\";else kind = \"value\";\n        defineProperty(this, \"__kind__\", d(\"\", kind));\n      };\n      if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);\n\n      // Internal %ArrayIteratorPrototype% doesn't expose its constructor\n      delete ArrayIterator.prototype.constructor;\n      ArrayIterator.prototype = Object.create(Iterator.prototype, {\n        _resolve: d(function (i) {\n          if (this.__kind__ === \"value\") return this.__list__[i];\n          if (this.__kind__ === \"key+value\") return [i, this.__list__[i]];\n          return i;\n        })\n      });\n      defineProperty(ArrayIterator.prototype, _Symbol.toStringTag, d(\"c\", \"Array Iterator\"));\n    }, {\n      \"./\": 64,\n      \"d\": 15,\n      \"es5-ext/object/set-prototype-of\": 52,\n      \"es5-ext/string/#/contains\": 57,\n      \"es6-symbol\": 74\n    }],\n    62: [function (require, module, exports) {\n      \"use strict\";\n\n      var isArguments = require(\"es5-ext/function/is-arguments\"),\n        callable = require(\"es5-ext/object/valid-callable\"),\n        isString = require(\"es5-ext/string/is-string\"),\n        get = require(\"./get\");\n      var isArray = Array.isArray,\n        call = Function.prototype.call,\n        some = Array.prototype.some;\n      module.exports = function (iterable, cb /*, thisArg*/) {\n        var mode,\n          thisArg = arguments[2],\n          result,\n          doBreak,\n          broken,\n          i,\n          length,\n          char,\n          code;\n        if (isArray(iterable) || isArguments(iterable)) mode = \"array\";else if (isString(iterable)) mode = \"string\";else iterable = get(iterable);\n        callable(cb);\n        doBreak = function doBreak() {\n          broken = true;\n        };\n        if (mode === \"array\") {\n          some.call(iterable, function (value) {\n            call.call(cb, thisArg, value, doBreak);\n            return broken;\n          });\n          return;\n        }\n        if (mode === \"string\") {\n          length = iterable.length;\n          for (i = 0; i < length; ++i) {\n            char = iterable[i];\n            if (i + 1 < length) {\n              code = char.charCodeAt(0);\n              if (code >= 0xd800 && code <= 0xdbff) char += iterable[++i];\n            }\n            call.call(cb, thisArg, char, doBreak);\n            if (broken) break;\n          }\n          return;\n        }\n        result = iterable.next();\n        while (!result.done) {\n          call.call(cb, thisArg, result.value, doBreak);\n          if (broken) return;\n          result = iterable.next();\n        }\n      };\n    }, {\n      \"./get\": 63,\n      \"es5-ext/function/is-arguments\": 26,\n      \"es5-ext/object/valid-callable\": 55,\n      \"es5-ext/string/is-string\": 60\n    }],\n    63: [function (require, module, exports) {\n      \"use strict\";\n\n      var isArguments = require(\"es5-ext/function/is-arguments\"),\n        isString = require(\"es5-ext/string/is-string\"),\n        ArrayIterator = require(\"./array\"),\n        StringIterator = require(\"./string\"),\n        iterable = require(\"./valid-iterable\"),\n        iteratorSymbol = require(\"es6-symbol\").iterator;\n      module.exports = function (obj) {\n        if (typeof iterable(obj)[iteratorSymbol] === \"function\") return obj[iteratorSymbol]();\n        if (isArguments(obj)) return new ArrayIterator(obj);\n        if (isString(obj)) return new StringIterator(obj);\n        return new ArrayIterator(obj);\n      };\n    }, {\n      \"./array\": 61,\n      \"./string\": 66,\n      \"./valid-iterable\": 67,\n      \"es5-ext/function/is-arguments\": 26,\n      \"es5-ext/string/is-string\": 60,\n      \"es6-symbol\": 74\n    }],\n    64: [function (require, module, exports) {\n      \"use strict\";\n\n      var clear = require(\"es5-ext/array/#/clear\"),\n        assign = require(\"es5-ext/object/assign\"),\n        callable = require(\"es5-ext/object/valid-callable\"),\n        value = require(\"es5-ext/object/valid-value\"),\n        d = require(\"d\"),\n        autoBind = require(\"d/auto-bind\"),\n        _Symbol2 = require(\"es6-symbol\");\n      var defineProperty = Object.defineProperty,\n        defineProperties = Object.defineProperties,\n        _Iterator;\n      module.exports = _Iterator = function Iterator(list, context) {\n        if (!(this instanceof _Iterator)) throw new TypeError(\"Constructor requires 'new'\");\n        defineProperties(this, {\n          __list__: d(\"w\", value(list)),\n          __context__: d(\"w\", context),\n          __nextIndex__: d(\"w\", 0)\n        });\n        if (!context) return;\n        callable(context.on);\n        context.on(\"_add\", this._onAdd);\n        context.on(\"_delete\", this._onDelete);\n        context.on(\"_clear\", this._onClear);\n      };\n\n      // Internal %IteratorPrototype% doesn't expose its constructor\n      delete _Iterator.prototype.constructor;\n      defineProperties(_Iterator.prototype, assign({\n        _next: d(function () {\n          var i;\n          if (!this.__list__) return undefined;\n          if (this.__redo__) {\n            i = this.__redo__.shift();\n            if (i !== undefined) return i;\n          }\n          if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;\n          this._unBind();\n          return undefined;\n        }),\n        next: d(function () {\n          return this._createResult(this._next());\n        }),\n        _createResult: d(function (i) {\n          if (i === undefined) return {\n            done: true,\n            value: undefined\n          };\n          return {\n            done: false,\n            value: this._resolve(i)\n          };\n        }),\n        _resolve: d(function (i) {\n          return this.__list__[i];\n        }),\n        _unBind: d(function () {\n          this.__list__ = null;\n          delete this.__redo__;\n          if (!this.__context__) return;\n          this.__context__.off(\"_add\", this._onAdd);\n          this.__context__.off(\"_delete\", this._onDelete);\n          this.__context__.off(\"_clear\", this._onClear);\n          this.__context__ = null;\n        }),\n        toString: d(function () {\n          return \"[object \" + (this[_Symbol2.toStringTag] || \"Object\") + \"]\";\n        })\n      }, autoBind({\n        _onAdd: d(function (index) {\n          if (index >= this.__nextIndex__) return;\n          ++this.__nextIndex__;\n          if (!this.__redo__) {\n            defineProperty(this, \"__redo__\", d(\"c\", [index]));\n            return;\n          }\n          this.__redo__.forEach(function (redo, i) {\n            if (redo >= index) this.__redo__[i] = ++redo;\n          }, this);\n          this.__redo__.push(index);\n        }),\n        _onDelete: d(function (index) {\n          var i;\n          if (index >= this.__nextIndex__) return;\n          --this.__nextIndex__;\n          if (!this.__redo__) return;\n          i = this.__redo__.indexOf(index);\n          if (i !== -1) this.__redo__.splice(i, 1);\n          this.__redo__.forEach(function (redo, j) {\n            if (redo > index) this.__redo__[j] = --redo;\n          }, this);\n        }),\n        _onClear: d(function () {\n          if (this.__redo__) clear.call(this.__redo__);\n          this.__nextIndex__ = 0;\n        })\n      })));\n      defineProperty(_Iterator.prototype, _Symbol2.iterator, d(function () {\n        return this;\n      }));\n    }, {\n      \"d\": 15,\n      \"d/auto-bind\": 14,\n      \"es5-ext/array/#/clear\": 21,\n      \"es5-ext/object/assign\": 38,\n      \"es5-ext/object/valid-callable\": 55,\n      \"es5-ext/object/valid-value\": 56,\n      \"es6-symbol\": 74\n    }],\n    65: [function (require, module, exports) {\n      \"use strict\";\n\n      var isArguments = require(\"es5-ext/function/is-arguments\"),\n        isValue = require(\"es5-ext/object/is-value\"),\n        isString = require(\"es5-ext/string/is-string\");\n      var iteratorSymbol = require(\"es6-symbol\").iterator,\n        isArray = Array.isArray;\n      module.exports = function (value) {\n        if (!isValue(value)) return false;\n        if (isArray(value)) return true;\n        if (isString(value)) return true;\n        if (isArguments(value)) return true;\n        return typeof value[iteratorSymbol] === \"function\";\n      };\n    }, {\n      \"es5-ext/function/is-arguments\": 26,\n      \"es5-ext/object/is-value\": 45,\n      \"es5-ext/string/is-string\": 60,\n      \"es6-symbol\": 74\n    }],\n    66: [function (require, module, exports) {\n      // Thanks @mathiasbynens\n      // http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols\n\n      \"use strict\";\n\n      var setPrototypeOf = require(\"es5-ext/object/set-prototype-of\"),\n        d = require(\"d\"),\n        _Symbol3 = require(\"es6-symbol\"),\n        Iterator = require(\"./\");\n      var defineProperty = Object.defineProperty,\n        StringIterator;\n      StringIterator = module.exports = function (str) {\n        if (!(this instanceof StringIterator)) throw new TypeError(\"Constructor requires 'new'\");\n        str = String(str);\n        Iterator.call(this, str);\n        defineProperty(this, \"__length__\", d(\"\", str.length));\n      };\n      if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);\n\n      // Internal %ArrayIteratorPrototype% doesn't expose its constructor\n      delete StringIterator.prototype.constructor;\n      StringIterator.prototype = Object.create(Iterator.prototype, {\n        _next: d(function () {\n          if (!this.__list__) return undefined;\n          if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;\n          this._unBind();\n          return undefined;\n        }),\n        _resolve: d(function (i) {\n          var char = this.__list__[i],\n            code;\n          if (this.__nextIndex__ === this.__length__) return char;\n          code = char.charCodeAt(0);\n          if (code >= 0xd800 && code <= 0xdbff) return char + this.__list__[this.__nextIndex__++];\n          return char;\n        })\n      });\n      defineProperty(StringIterator.prototype, _Symbol3.toStringTag, d(\"c\", \"String Iterator\"));\n    }, {\n      \"./\": 64,\n      \"d\": 15,\n      \"es5-ext/object/set-prototype-of\": 52,\n      \"es6-symbol\": 74\n    }],\n    67: [function (require, module, exports) {\n      \"use strict\";\n\n      var isIterable = require(\"./is-iterable\");\n      module.exports = function (value) {\n        if (!isIterable(value)) throw new TypeError(value + \" is not iterable\");\n        return value;\n      };\n    }, {\n      \"./is-iterable\": 65\n    }],\n    68: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('./is-implemented')() ? Map : require('./polyfill');\n    }, {\n      \"./is-implemented\": 69,\n      \"./polyfill\": 73\n    }],\n    69: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = function () {\n        var map, iterator, result;\n        if (typeof Map !== 'function') return false;\n        try {\n          // WebKit doesn't support arguments and crashes\n          map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);\n        } catch (e) {\n          return false;\n        }\n        if (String(map) !== '[object Map]') return false;\n        if (map.size !== 3) return false;\n        if (typeof map.clear !== 'function') return false;\n        if (typeof map.delete !== 'function') return false;\n        if (typeof map.entries !== 'function') return false;\n        if (typeof map.forEach !== 'function') return false;\n        if (typeof map.get !== 'function') return false;\n        if (typeof map.has !== 'function') return false;\n        if (typeof map.keys !== 'function') return false;\n        if (typeof map.set !== 'function') return false;\n        if (typeof map.values !== 'function') return false;\n        iterator = map.entries();\n        result = iterator.next();\n        if (result.done !== false) return false;\n        if (!result.value) return false;\n        if (result.value[0] !== 'raz') return false;\n        if (result.value[1] !== 'one') return false;\n        return true;\n      };\n    }, {}],\n    70: [function (require, module, exports) {\n      // Exports true if environment provides native `Map` implementation,\n      // whatever that is.\n\n      'use strict';\n\n      module.exports = function () {\n        if (typeof Map === 'undefined') return false;\n        return Object.prototype.toString.call(new Map()) === '[object Map]';\n      }();\n    }, {}],\n    71: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = require('es5-ext/object/primitive-set')('key', 'value', 'key+value');\n    }, {\n      \"es5-ext/object/primitive-set\": 51\n    }],\n    72: [function (require, module, exports) {\n      'use strict';\n\n      var setPrototypeOf = require('es5-ext/object/set-prototype-of'),\n        d = require('d'),\n        Iterator = require('es6-iterator'),\n        toStringTagSymbol = require('es6-symbol').toStringTag,\n        kinds = require('./iterator-kinds'),\n        defineProperties = Object.defineProperties,\n        unBind = Iterator.prototype._unBind,\n        MapIterator;\n      MapIterator = module.exports = function (map, kind) {\n        if (!(this instanceof MapIterator)) return new MapIterator(map, kind);\n        Iterator.call(this, map.__mapKeysData__, map);\n        if (!kind || !kinds[kind]) kind = 'key+value';\n        defineProperties(this, {\n          __kind__: d('', kind),\n          __values__: d('w', map.__mapValuesData__)\n        });\n      };\n      if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);\n      MapIterator.prototype = Object.create(Iterator.prototype, {\n        constructor: d(MapIterator),\n        _resolve: d(function (i) {\n          if (this.__kind__ === 'value') return this.__values__[i];\n          if (this.__kind__ === 'key') return this.__list__[i];\n          return [this.__list__[i], this.__values__[i]];\n        }),\n        _unBind: d(function () {\n          this.__values__ = null;\n          unBind.call(this);\n        }),\n        toString: d(function () {\n          return '[object Map Iterator]';\n        })\n      });\n      Object.defineProperty(MapIterator.prototype, toStringTagSymbol, d('c', 'Map Iterator'));\n    }, {\n      \"./iterator-kinds\": 71,\n      \"d\": 15,\n      \"es5-ext/object/set-prototype-of\": 52,\n      \"es6-iterator\": 64,\n      \"es6-symbol\": 74\n    }],\n    73: [function (require, module, exports) {\n      'use strict';\n\n      var clear = require('es5-ext/array/#/clear'),\n        eIndexOf = require('es5-ext/array/#/e-index-of'),\n        setPrototypeOf = require('es5-ext/object/set-prototype-of'),\n        callable = require('es5-ext/object/valid-callable'),\n        validValue = require('es5-ext/object/valid-value'),\n        d = require('d'),\n        ee = require('event-emitter'),\n        _Symbol4 = require('es6-symbol'),\n        iterator = require('es6-iterator/valid-iterable'),\n        forOf = require('es6-iterator/for-of'),\n        Iterator = require('./lib/iterator'),\n        isNative = require('./is-native-implemented'),\n        call = Function.prototype.call,\n        defineProperties = Object.defineProperties,\n        getPrototypeOf = Object.getPrototypeOf,\n        _MapPoly;\n      module.exports = _MapPoly = function MapPoly( /*iterable*/\n      ) {\n        var iterable = arguments[0],\n          keys,\n          values,\n          self;\n        if (!(this instanceof _MapPoly)) throw new TypeError('Constructor requires \\'new\\'');\n        if (isNative && setPrototypeOf && Map !== _MapPoly) {\n          self = setPrototypeOf(new Map(), getPrototypeOf(this));\n        } else {\n          self = this;\n        }\n        if (iterable != null) iterator(iterable);\n        defineProperties(self, {\n          __mapKeysData__: d('c', keys = []),\n          __mapValuesData__: d('c', values = [])\n        });\n        if (!iterable) return self;\n        forOf(iterable, function (value) {\n          var key = validValue(value)[0];\n          value = value[1];\n          if (eIndexOf.call(keys, key) !== -1) return;\n          keys.push(key);\n          values.push(value);\n        }, self);\n        return self;\n      };\n      if (isNative) {\n        if (setPrototypeOf) setPrototypeOf(_MapPoly, Map);\n        _MapPoly.prototype = Object.create(Map.prototype, {\n          constructor: d(_MapPoly)\n        });\n      }\n      ee(defineProperties(_MapPoly.prototype, {\n        clear: d(function () {\n          if (!this.__mapKeysData__.length) return;\n          clear.call(this.__mapKeysData__);\n          clear.call(this.__mapValuesData__);\n          this.emit('_clear');\n        }),\n        delete: d(function (key) {\n          var index = eIndexOf.call(this.__mapKeysData__, key);\n          if (index === -1) return false;\n          this.__mapKeysData__.splice(index, 1);\n          this.__mapValuesData__.splice(index, 1);\n          this.emit('_delete', index, key);\n          return true;\n        }),\n        entries: d(function () {\n          return new Iterator(this, 'key+value');\n        }),\n        forEach: d(function (cb /*, thisArg*/) {\n          var thisArg = arguments[1],\n            iterator,\n            result;\n          callable(cb);\n          iterator = this.entries();\n          result = iterator._next();\n          while (result !== undefined) {\n            call.call(cb, thisArg, this.__mapValuesData__[result], this.__mapKeysData__[result], this);\n            result = iterator._next();\n          }\n        }),\n        get: d(function (key) {\n          var index = eIndexOf.call(this.__mapKeysData__, key);\n          if (index === -1) return;\n          return this.__mapValuesData__[index];\n        }),\n        has: d(function (key) {\n          return eIndexOf.call(this.__mapKeysData__, key) !== -1;\n        }),\n        keys: d(function () {\n          return new Iterator(this, 'key');\n        }),\n        set: d(function (key, value) {\n          var index = eIndexOf.call(this.__mapKeysData__, key),\n            emit;\n          if (index === -1) {\n            index = this.__mapKeysData__.push(key) - 1;\n            emit = true;\n          }\n          this.__mapValuesData__[index] = value;\n          if (emit) this.emit('_add', index, key);\n          return this;\n        }),\n        size: d.gs(function () {\n          return this.__mapKeysData__.length;\n        }),\n        values: d(function () {\n          return new Iterator(this, 'value');\n        }),\n        toString: d(function () {\n          return '[object Map]';\n        })\n      }));\n      Object.defineProperty(_MapPoly.prototype, _Symbol4.iterator, d(function () {\n        return this.entries();\n      }));\n      Object.defineProperty(_MapPoly.prototype, _Symbol4.toStringTag, d('c', 'Map'));\n    }, {\n      \"./is-native-implemented\": 70,\n      \"./lib/iterator\": 72,\n      \"d\": 15,\n      \"es5-ext/array/#/clear\": 21,\n      \"es5-ext/array/#/e-index-of\": 22,\n      \"es5-ext/object/set-prototype-of\": 52,\n      \"es5-ext/object/valid-callable\": 55,\n      \"es5-ext/object/valid-value\": 56,\n      \"es6-iterator/for-of\": 62,\n      \"es6-iterator/valid-iterable\": 67,\n      \"es6-symbol\": 74,\n      \"event-emitter\": 82\n    }],\n    74: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? require(\"ext/global-this\").Symbol : require(\"./polyfill\");\n    }, {\n      \"./is-implemented\": 75,\n      \"./polyfill\": 80,\n      \"ext/global-this\": 85\n    }],\n    75: [function (require, module, exports) {\n      \"use strict\";\n\n      var global = require(\"ext/global-this\"),\n        validTypes = {\n          object: true,\n          symbol: true\n        };\n      module.exports = function () {\n        var _Symbol5 = global.Symbol;\n        var symbol;\n        if (typeof _Symbol5 !== \"function\") return false;\n        symbol = _Symbol5(\"test symbol\");\n        try {\n          String(symbol);\n        } catch (e) {\n          return false;\n        }\n\n        // Return 'true' also for polyfills\n        if (!validTypes[_typeof(_Symbol5.iterator)]) return false;\n        if (!validTypes[_typeof(_Symbol5.toPrimitive)]) return false;\n        if (!validTypes[_typeof(_Symbol5.toStringTag)]) return false;\n        return true;\n      };\n    }, {\n      \"ext/global-this\": 85\n    }],\n    76: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (value) {\n        if (!value) return false;\n        if (_typeof(value) === \"symbol\") return true;\n        if (!value.constructor) return false;\n        if (value.constructor.name !== \"Symbol\") return false;\n        return value[value.constructor.toStringTag] === \"Symbol\";\n      };\n    }, {}],\n    77: [function (require, module, exports) {\n      \"use strict\";\n\n      var d = require(\"d\");\n      var create = Object.create,\n        defineProperty = Object.defineProperty,\n        objPrototype = Object.prototype;\n      var created = create(null);\n      module.exports = function (desc) {\n        var postfix = 0,\n          name,\n          ie11BugWorkaround;\n        while (created[desc + (postfix || \"\")]) {\n          ++postfix;\n        }\n        desc += postfix || \"\";\n        created[desc] = true;\n        name = \"@@\" + desc;\n        defineProperty(objPrototype, name, d.gs(null, function (value) {\n          // For IE11 issue see:\n          // https://connect.microsoft.com/IE/feedbackdetail/view/1928508/\n          //    ie11-broken-getters-on-dom-objects\n          // https://github.com/medikoo/es6-symbol/issues/12\n          if (ie11BugWorkaround) return;\n          ie11BugWorkaround = true;\n          defineProperty(this, name, d(value));\n          ie11BugWorkaround = false;\n        }));\n        return name;\n      };\n    }, {\n      \"d\": 15\n    }],\n    78: [function (require, module, exports) {\n      \"use strict\";\n\n      var d = require(\"d\"),\n        NativeSymbol = require(\"ext/global-this\").Symbol;\n      module.exports = function (SymbolPolyfill) {\n        return Object.defineProperties(SymbolPolyfill, {\n          // To ensure proper interoperability with other native functions (e.g. Array.from)\n          // fallback to eventual native implementation of given symbol\n          hasInstance: d(\"\", NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill(\"hasInstance\")),\n          isConcatSpreadable: d(\"\", NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill(\"isConcatSpreadable\")),\n          iterator: d(\"\", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill(\"iterator\")),\n          match: d(\"\", NativeSymbol && NativeSymbol.match || SymbolPolyfill(\"match\")),\n          replace: d(\"\", NativeSymbol && NativeSymbol.replace || SymbolPolyfill(\"replace\")),\n          search: d(\"\", NativeSymbol && NativeSymbol.search || SymbolPolyfill(\"search\")),\n          species: d(\"\", NativeSymbol && NativeSymbol.species || SymbolPolyfill(\"species\")),\n          split: d(\"\", NativeSymbol && NativeSymbol.split || SymbolPolyfill(\"split\")),\n          toPrimitive: d(\"\", NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill(\"toPrimitive\")),\n          toStringTag: d(\"\", NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill(\"toStringTag\")),\n          unscopables: d(\"\", NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill(\"unscopables\"))\n        });\n      };\n    }, {\n      \"d\": 15,\n      \"ext/global-this\": 85\n    }],\n    79: [function (require, module, exports) {\n      \"use strict\";\n\n      var d = require(\"d\"),\n        validateSymbol = require(\"../../../validate-symbol\");\n      var registry = Object.create(null);\n      module.exports = function (SymbolPolyfill) {\n        return Object.defineProperties(SymbolPolyfill, {\n          for: d(function (key) {\n            if (registry[key]) return registry[key];\n            return registry[key] = SymbolPolyfill(String(key));\n          }),\n          keyFor: d(function (symbol) {\n            var key;\n            validateSymbol(symbol);\n            for (key in registry) {\n              if (registry[key] === symbol) return key;\n            }\n            return undefined;\n          })\n        });\n      };\n    }, {\n      \"../../../validate-symbol\": 81,\n      \"d\": 15\n    }],\n    80: [function (require, module, exports) {\n      // ES2015 Symbol polyfill for environments that do not (or partially) support it\n\n      \"use strict\";\n\n      var d = require(\"d\"),\n        validateSymbol = require(\"./validate-symbol\"),\n        NativeSymbol = require(\"ext/global-this\").Symbol,\n        generateName = require(\"./lib/private/generate-name\"),\n        setupStandardSymbols = require(\"./lib/private/setup/standard-symbols\"),\n        setupSymbolRegistry = require(\"./lib/private/setup/symbol-registry\");\n      var create = Object.create,\n        defineProperties = Object.defineProperties,\n        defineProperty = Object.defineProperty;\n      var SymbolPolyfill, HiddenSymbol, isNativeSafe;\n      if (typeof NativeSymbol === \"function\") {\n        try {\n          String(NativeSymbol());\n          isNativeSafe = true;\n        } catch (ignore) {}\n      } else {\n        NativeSymbol = null;\n      }\n\n      // Internal constructor (not one exposed) for creating Symbol instances.\n      // This one is used to ensure that `someSymbol instanceof Symbol` always return false\n      HiddenSymbol = function _Symbol6(description) {\n        if (this instanceof HiddenSymbol) throw new TypeError(\"Symbol is not a constructor\");\n        return SymbolPolyfill(description);\n      };\n\n      // Exposed `Symbol` constructor\n      // (returns instances of HiddenSymbol)\n      module.exports = SymbolPolyfill = function _Symbol7(description) {\n        var symbol;\n        if (this instanceof _Symbol7) throw new TypeError(\"Symbol is not a constructor\");\n        if (isNativeSafe) return NativeSymbol(description);\n        symbol = create(HiddenSymbol.prototype);\n        description = description === undefined ? \"\" : String(description);\n        return defineProperties(symbol, {\n          __description__: d(\"\", description),\n          __name__: d(\"\", generateName(description))\n        });\n      };\n      setupStandardSymbols(SymbolPolyfill);\n      setupSymbolRegistry(SymbolPolyfill);\n\n      // Internal tweaks for real symbol producer\n      defineProperties(HiddenSymbol.prototype, {\n        constructor: d(SymbolPolyfill),\n        toString: d(\"\", function () {\n          return this.__name__;\n        })\n      });\n\n      // Proper implementation of methods exposed on Symbol.prototype\n      // They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype\n      defineProperties(SymbolPolyfill.prototype, {\n        toString: d(function () {\n          return \"Symbol (\" + validateSymbol(this).__description__ + \")\";\n        }),\n        valueOf: d(function () {\n          return validateSymbol(this);\n        })\n      });\n      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d(\"\", function () {\n        var symbol = validateSymbol(this);\n        if (_typeof(symbol) === \"symbol\") return symbol;\n        return symbol.toString();\n      }));\n      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d(\"c\", \"Symbol\"));\n\n      // Proper implementaton of toPrimitive and toStringTag for returned symbol instances\n      defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));\n\n      // Note: It's important to define `toPrimitive` as last one, as some implementations\n      // implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)\n      // And that may invoke error in definition flow:\n      // See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149\n      defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d(\"c\", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));\n    }, {\n      \"./lib/private/generate-name\": 77,\n      \"./lib/private/setup/standard-symbols\": 78,\n      \"./lib/private/setup/symbol-registry\": 79,\n      \"./validate-symbol\": 81,\n      \"d\": 15,\n      \"ext/global-this\": 85\n    }],\n    81: [function (require, module, exports) {\n      \"use strict\";\n\n      var isSymbol = require(\"./is-symbol\");\n      module.exports = function (value) {\n        if (!isSymbol(value)) throw new TypeError(value + \" is not a symbol\");\n        return value;\n      };\n    }, {\n      \"./is-symbol\": 76\n    }],\n    82: [function (require, module, exports) {\n      'use strict';\n\n      var d = require('d'),\n        callable = require('es5-ext/object/valid-callable'),\n        apply = Function.prototype.apply,\n        call = Function.prototype.call,\n        create = Object.create,\n        defineProperty = Object.defineProperty,\n        defineProperties = Object.defineProperties,\n        hasOwnProperty = Object.prototype.hasOwnProperty,\n        descriptor = {\n          configurable: true,\n          enumerable: false,\n          writable: true\n        },\n        on,\n        _once2,\n        off,\n        emit,\n        methods,\n        descriptors,\n        base;\n      on = function on(type, listener) {\n        var data;\n        callable(listener);\n        if (!hasOwnProperty.call(this, '__ee__')) {\n          data = descriptor.value = create(null);\n          defineProperty(this, '__ee__', descriptor);\n          descriptor.value = null;\n        } else {\n          data = this.__ee__;\n        }\n        if (!data[type]) data[type] = listener;else if (_typeof(data[type]) === 'object') data[type].push(listener);else data[type] = [data[type], listener];\n        return this;\n      };\n      _once2 = function once(type, listener) {\n        var _once, self;\n        callable(listener);\n        self = this;\n        on.call(this, type, _once = function once() {\n          off.call(self, type, _once);\n          apply.call(listener, this, arguments);\n        });\n        _once.__eeOnceListener__ = listener;\n        return this;\n      };\n      off = function off(type, listener) {\n        var data, listeners, candidate, i;\n        callable(listener);\n        if (!hasOwnProperty.call(this, '__ee__')) return this;\n        data = this.__ee__;\n        if (!data[type]) return this;\n        listeners = data[type];\n        if (_typeof(listeners) === 'object') {\n          for (i = 0; candidate = listeners[i]; ++i) {\n            if (candidate === listener || candidate.__eeOnceListener__ === listener) {\n              if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];else listeners.splice(i, 1);\n            }\n          }\n        } else {\n          if (listeners === listener || listeners.__eeOnceListener__ === listener) {\n            delete data[type];\n          }\n        }\n        return this;\n      };\n      emit = function emit(type) {\n        var i, l, listener, listeners, args;\n        if (!hasOwnProperty.call(this, '__ee__')) return;\n        listeners = this.__ee__[type];\n        if (!listeners) return;\n        if (_typeof(listeners) === 'object') {\n          l = arguments.length;\n          args = new Array(l - 1);\n          for (i = 1; i < l; ++i) {\n            args[i - 1] = arguments[i];\n          }\n          listeners = listeners.slice();\n          for (i = 0; listener = listeners[i]; ++i) {\n            apply.call(listener, this, args);\n          }\n        } else {\n          switch (arguments.length) {\n            case 1:\n              call.call(listeners, this);\n              break;\n            case 2:\n              call.call(listeners, this, arguments[1]);\n              break;\n            case 3:\n              call.call(listeners, this, arguments[1], arguments[2]);\n              break;\n            default:\n              l = arguments.length;\n              args = new Array(l - 1);\n              for (i = 1; i < l; ++i) {\n                args[i - 1] = arguments[i];\n              }\n              apply.call(listeners, this, args);\n          }\n        }\n      };\n      methods = {\n        on: on,\n        once: _once2,\n        off: off,\n        emit: emit\n      };\n      descriptors = {\n        on: d(on),\n        once: d(_once2),\n        off: d(off),\n        emit: d(emit)\n      };\n      base = defineProperties({}, descriptors);\n      module.exports = exports = function exports(o) {\n        return o == null ? create(base) : defineProperties(Object(o), descriptors);\n      };\n      exports.methods = methods;\n    }, {\n      \"d\": 15,\n      \"es5-ext/object/valid-callable\": 55\n    }],\n    83: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      var objectCreate = Object.create || objectCreatePolyfill;\n      var objectKeys = Object.keys || objectKeysPolyfill;\n      var bind = Function.prototype.bind || functionBindPolyfill;\n      function EventEmitter() {\n        if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        }\n        this._maxListeners = this._maxListeners || undefined;\n      }\n      module.exports = EventEmitter;\n\n      // Backwards-compat with node 0.10.x\n      EventEmitter.EventEmitter = EventEmitter;\n      EventEmitter.prototype._events = undefined;\n      EventEmitter.prototype._maxListeners = undefined;\n\n      // By default EventEmitters will print a warning if more than 10 listeners are\n      // added to it. This is a useful default which helps finding memory leaks.\n      var defaultMaxListeners = 10;\n      var hasDefineProperty;\n      try {\n        var o = {};\n        if (Object.defineProperty) Object.defineProperty(o, 'x', {\n          value: 0\n        });\n        hasDefineProperty = o.x === 0;\n      } catch (err) {\n        hasDefineProperty = false;\n      }\n      if (hasDefineProperty) {\n        Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n          enumerable: true,\n          get: function get() {\n            return defaultMaxListeners;\n          },\n          set: function set(arg) {\n            // check whether the input is a positive number (whose value is zero or\n            // greater and not a NaN).\n            if (typeof arg !== 'number' || arg < 0 || arg !== arg) throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n            defaultMaxListeners = arg;\n          }\n        });\n      } else {\n        EventEmitter.defaultMaxListeners = defaultMaxListeners;\n      }\n\n      // Obviously not all Emitters should be limited to 10. This function allows\n      // that to be increased. Set to zero for unlimited.\n      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n        if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('\"n\" argument must be a positive number');\n        this._maxListeners = n;\n        return this;\n      };\n      function $getMaxListeners(that) {\n        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n        return that._maxListeners;\n      }\n      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n        return $getMaxListeners(this);\n      };\n\n      // These standalone emit* functions are used to optimize calling of event\n      // handlers for fast cases because emit() itself often has a variable number of\n      // arguments and can be deoptimized because of that. These functions always have\n      // the same number of arguments and thus do not get deoptimized, so the code\n      // inside them can execute faster.\n      function emitNone(handler, isFn, self) {\n        if (isFn) handler.call(self);else {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self);\n          }\n        }\n      }\n      function emitOne(handler, isFn, self, arg1) {\n        if (isFn) handler.call(self, arg1);else {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self, arg1);\n          }\n        }\n      }\n      function emitTwo(handler, isFn, self, arg1, arg2) {\n        if (isFn) handler.call(self, arg1, arg2);else {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self, arg1, arg2);\n          }\n        }\n      }\n      function emitThree(handler, isFn, self, arg1, arg2, arg3) {\n        if (isFn) handler.call(self, arg1, arg2, arg3);else {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].call(self, arg1, arg2, arg3);\n          }\n        }\n      }\n      function emitMany(handler, isFn, self, args) {\n        if (isFn) handler.apply(self, args);else {\n          var len = handler.length;\n          var listeners = arrayClone(handler, len);\n          for (var i = 0; i < len; ++i) {\n            listeners[i].apply(self, args);\n          }\n        }\n      }\n      EventEmitter.prototype.emit = function emit(type) {\n        var er, handler, len, args, i, events;\n        var doError = type === 'error';\n        events = this._events;\n        if (events) doError = doError && events.error == null;else if (!doError) return false;\n\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n          if (arguments.length > 1) er = arguments[1];\n          if (er instanceof Error) {\n            throw er; // Unhandled 'error' event\n          } else {\n            // At least give some kind of context to the user\n            var err = new Error('Unhandled \"error\" event. (' + er + ')');\n            err.context = er;\n            throw err;\n          }\n          return false;\n        }\n        handler = events[type];\n        if (!handler) return false;\n        var isFn = typeof handler === 'function';\n        len = arguments.length;\n        switch (len) {\n          // fast cases\n          case 1:\n            emitNone(handler, isFn, this);\n            break;\n          case 2:\n            emitOne(handler, isFn, this, arguments[1]);\n            break;\n          case 3:\n            emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n            break;\n          case 4:\n            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n            break;\n          // slower\n          default:\n            args = new Array(len - 1);\n            for (i = 1; i < len; i++) {\n              args[i - 1] = arguments[i];\n            }\n            emitMany(handler, isFn, this, args);\n        }\n        return true;\n      };\n      function _addListener(target, type, listener, prepend) {\n        var m;\n        var events;\n        var existing;\n        if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n        events = target._events;\n        if (!events) {\n          events = target._events = objectCreate(null);\n          target._eventsCount = 0;\n        } else {\n          // To avoid recursion in the case that type === \"newListener\"! Before\n          // adding it to the listeners, first emit \"newListener\".\n          if (events.newListener) {\n            target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n            // Re-assign `events` because a newListener handler could have caused the\n            // this._events to be assigned to a new object\n            events = target._events;\n          }\n          existing = events[type];\n        }\n        if (!existing) {\n          // Optimize the case of one listener. Don't need the extra array object.\n          existing = events[type] = listener;\n          ++target._eventsCount;\n        } else {\n          if (typeof existing === 'function') {\n            // Adding the second element, need to change to array.\n            existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n          } else {\n            // If we've already got an array, just append.\n            if (prepend) {\n              existing.unshift(listener);\n            } else {\n              existing.push(listener);\n            }\n          }\n\n          // Check for listener leak\n          if (!existing.warned) {\n            m = $getMaxListeners(target);\n            if (m && m > 0 && existing.length > m) {\n              existing.warned = true;\n              var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' \"' + String(type) + '\" listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit.');\n              w.name = 'MaxListenersExceededWarning';\n              w.emitter = target;\n              w.type = type;\n              w.count = existing.length;\n              if ((typeof console === \"undefined\" ? \"undefined\" : _typeof(console)) === 'object' && console.warn) {\n                __f__(\"warn\", '%s: %s', w.name, w.message, \" at mqtt.js:7326\");\n              }\n            }\n          }\n        }\n        return target;\n      }\n      EventEmitter.prototype.addListener = function addListener(type, listener) {\n        return _addListener(this, type, listener, false);\n      };\n      EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n      EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n        return _addListener(this, type, listener, true);\n      };\n      function onceWrapper() {\n        if (!this.fired) {\n          this.target.removeListener(this.type, this.wrapFn);\n          this.fired = true;\n          switch (arguments.length) {\n            case 0:\n              return this.listener.call(this.target);\n            case 1:\n              return this.listener.call(this.target, arguments[0]);\n            case 2:\n              return this.listener.call(this.target, arguments[0], arguments[1]);\n            case 3:\n              return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);\n            default:\n              var args = new Array(arguments.length);\n              for (var i = 0; i < args.length; ++i) {\n                args[i] = arguments[i];\n              }\n              this.listener.apply(this.target, args);\n          }\n        }\n      }\n      function _onceWrap(target, type, listener) {\n        var state = {\n          fired: false,\n          wrapFn: undefined,\n          target: target,\n          type: type,\n          listener: listener\n        };\n        var wrapped = bind.call(onceWrapper, state);\n        wrapped.listener = listener;\n        state.wrapFn = wrapped;\n        return wrapped;\n      }\n      EventEmitter.prototype.once = function once(type, listener) {\n        if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n        this.on(type, _onceWrap(this, type, listener));\n        return this;\n      };\n      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n        if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n        this.prependListener(type, _onceWrap(this, type, listener));\n        return this;\n      };\n\n      // Emits a 'removeListener' event if and only if the listener was removed.\n      EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n        var list, events, position, i, originalListener;\n        if (typeof listener !== 'function') throw new TypeError('\"listener\" argument must be a function');\n        events = this._events;\n        if (!events) return this;\n        list = events[type];\n        if (!list) return this;\n        if (list === listener || list.listener === listener) {\n          if (--this._eventsCount === 0) this._events = objectCreate(null);else {\n            delete events[type];\n            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n          }\n        } else if (typeof list !== 'function') {\n          position = -1;\n          for (i = list.length - 1; i >= 0; i--) {\n            if (list[i] === listener || list[i].listener === listener) {\n              originalListener = list[i].listener;\n              position = i;\n              break;\n            }\n          }\n          if (position < 0) return this;\n          if (position === 0) list.shift();else spliceOne(list, position);\n          if (list.length === 1) events[type] = list[0];\n          if (events.removeListener) this.emit('removeListener', type, originalListener || listener);\n        }\n        return this;\n      };\n      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n        var listeners, events, i;\n        events = this._events;\n        if (!events) return this;\n\n        // not listening for removeListener, no need to emit\n        if (!events.removeListener) {\n          if (arguments.length === 0) {\n            this._events = objectCreate(null);\n            this._eventsCount = 0;\n          } else if (events[type]) {\n            if (--this._eventsCount === 0) this._events = objectCreate(null);else delete events[type];\n          }\n          return this;\n        }\n\n        // emit removeListener for all listeners on all events\n        if (arguments.length === 0) {\n          var keys = objectKeys(events);\n          var key;\n          for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n            if (key === 'removeListener') continue;\n            this.removeAllListeners(key);\n          }\n          this.removeAllListeners('removeListener');\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n          return this;\n        }\n        listeners = events[type];\n        if (typeof listeners === 'function') {\n          this.removeListener(type, listeners);\n        } else if (listeners) {\n          // LIFO order\n          for (i = listeners.length - 1; i >= 0; i--) {\n            this.removeListener(type, listeners[i]);\n          }\n        }\n        return this;\n      };\n      function _listeners(target, type, unwrap) {\n        var events = target._events;\n        if (!events) return [];\n        var evlistener = events[type];\n        if (!evlistener) return [];\n        if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n      }\n      EventEmitter.prototype.listeners = function listeners(type) {\n        return _listeners(this, type, true);\n      };\n      EventEmitter.prototype.rawListeners = function rawListeners(type) {\n        return _listeners(this, type, false);\n      };\n      EventEmitter.listenerCount = function (emitter, type) {\n        if (typeof emitter.listenerCount === 'function') {\n          return emitter.listenerCount(type);\n        } else {\n          return listenerCount.call(emitter, type);\n        }\n      };\n      EventEmitter.prototype.listenerCount = listenerCount;\n      function listenerCount(type) {\n        var events = this._events;\n        if (events) {\n          var evlistener = events[type];\n          if (typeof evlistener === 'function') {\n            return 1;\n          } else if (evlistener) {\n            return evlistener.length;\n          }\n        }\n        return 0;\n      }\n      EventEmitter.prototype.eventNames = function eventNames() {\n        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n      };\n\n      // About 1.5x faster than the two-arg version of Array#splice().\n      function spliceOne(list, index) {\n        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n          list[i] = list[k];\n        }\n        list.pop();\n      }\n      function arrayClone(arr, n) {\n        var copy = new Array(n);\n        for (var i = 0; i < n; ++i) {\n          copy[i] = arr[i];\n        }\n        return copy;\n      }\n      function unwrapListeners(arr) {\n        var ret = new Array(arr.length);\n        for (var i = 0; i < ret.length; ++i) {\n          ret[i] = arr[i].listener || arr[i];\n        }\n        return ret;\n      }\n      function objectCreatePolyfill(proto) {\n        var F = function F() {};\n        F.prototype = proto;\n        return new F();\n      }\n      function objectKeysPolyfill(obj) {\n        var keys = [];\n        for (var k in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, k)) {\n            keys.push(k);\n          }\n        }\n        return k;\n      }\n      function functionBindPolyfill(context) {\n        var fn = this;\n        return function () {\n          return fn.apply(context, arguments);\n        };\n      }\n    }, {}],\n    84: [function (require, module, exports) {\n      var naiveFallback = function naiveFallback() {\n        if ((typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === \"object\" && self) return self;\n        if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && window) return window;\n        throw new Error(\"Unable to resolve global `this`\");\n      };\n      module.exports = function () {\n        if (this) return this;\n\n        // Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n        // Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n        // In all ES5+ engines global object inherits from Object.prototype\n        // (if you approached one that doesn't please report)\n        try {\n          Object.defineProperty(Object.prototype, \"__global__\", {\n            get: function get() {\n              return this;\n            },\n            configurable: true\n          });\n        } catch (error) {\n          // Unfortunate case of Object.prototype being sealed (via preventExtensions, seal or freeze)\n          return naiveFallback();\n        }\n        try {\n          // Safari case (window.__global__ is resolved with global context, but __global__ does not)\n          if (!__global__) return naiveFallback();\n          return __global__;\n        } finally {\n          delete Object.prototype.__global__;\n        }\n      }();\n    }, {}],\n    85: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = require(\"./is-implemented\")() ? globalThis : require(\"./implementation\");\n    }, {\n      \"./implementation\": 84,\n      \"./is-implemented\": 86\n    }],\n    86: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        if ((typeof globalThis === \"undefined\" ? \"undefined\" : _typeof(globalThis)) !== \"object\") return false;\n        if (!globalThis) return false;\n        return globalThis.Array === Array;\n      };\n    }, {}],\n    87: [function (require, module, exports) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n        i += d;\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n        e = e << mLen | m;\n        eLen += mLen;\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n        buffer[offset + i - d] |= s * 128;\n      };\n    }, {}],\n    88: [function (require, module, exports) {\n      if (typeof Object.create === 'function') {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n          ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n              value: ctor,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n        };\n      } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n          var TempCtor = function TempCtor() {};\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        };\n      }\n    }, {}],\n    89: [function (require, module, exports) {\n      /*!\n       * Determine if an object is a Buffer\n       *\n       * @author   Feross Aboukhadijeh <https://feross.org>\n       * @license  MIT\n       */\n\n      // The _isBuffer check is for Safari 5-7 support, because it's missing\n      // Object.prototype.constructor. Remove this eventually\n      module.exports = function (obj) {\n        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n      };\n      function isBuffer(obj) {\n        return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n      }\n\n      // For Node v0.10 support. Remove this eventually.\n      function isSlowBuffer(obj) {\n        return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n      }\n    }, {}],\n    90: [function (require, module, exports) {\n      'use strict';\n\n      var Buffer = require('safe-buffer').Buffer;\n\n      /* Protocol - protocol constants */\n      var protocol = module.exports;\n\n      /* Command code => mnemonic */\n      protocol.types = {\n        0: 'reserved',\n        1: 'connect',\n        2: 'connack',\n        3: 'publish',\n        4: 'puback',\n        5: 'pubrec',\n        6: 'pubrel',\n        7: 'pubcomp',\n        8: 'subscribe',\n        9: 'suback',\n        10: 'unsubscribe',\n        11: 'unsuback',\n        12: 'pingreq',\n        13: 'pingresp',\n        14: 'disconnect',\n        15: 'auth'\n      };\n\n      /* Mnemonic => Command code */\n      protocol.codes = {};\n      for (var k in protocol.types) {\n        var v = protocol.types[k];\n        protocol.codes[v] = k;\n      }\n\n      /* Header */\n      protocol.CMD_SHIFT = 4;\n      protocol.CMD_MASK = 0xF0;\n      protocol.DUP_MASK = 0x08;\n      protocol.QOS_MASK = 0x03;\n      protocol.QOS_SHIFT = 1;\n      protocol.RETAIN_MASK = 0x01;\n\n      /* Length */\n      protocol.LENGTH_MASK = 0x7F;\n      protocol.LENGTH_FIN_MASK = 0x80;\n\n      /* Connack */\n      protocol.SESSIONPRESENT_MASK = 0x01;\n      protocol.SESSIONPRESENT_HEADER = Buffer.from([protocol.SESSIONPRESENT_MASK]);\n      protocol.CONNACK_HEADER = Buffer.from([protocol.codes['connack'] << protocol.CMD_SHIFT]);\n\n      /* Connect */\n      protocol.USERNAME_MASK = 0x80;\n      protocol.PASSWORD_MASK = 0x40;\n      protocol.WILL_RETAIN_MASK = 0x20;\n      protocol.WILL_QOS_MASK = 0x18;\n      protocol.WILL_QOS_SHIFT = 3;\n      protocol.WILL_FLAG_MASK = 0x04;\n      protocol.CLEAN_SESSION_MASK = 0x02;\n      protocol.CONNECT_HEADER = Buffer.from([protocol.codes['connect'] << protocol.CMD_SHIFT]);\n\n      /* Properties */\n      protocol.properties = {\n        sessionExpiryInterval: 17,\n        willDelayInterval: 24,\n        receiveMaximum: 33,\n        maximumPacketSize: 39,\n        topicAliasMaximum: 34,\n        requestResponseInformation: 25,\n        requestProblemInformation: 23,\n        userProperties: 38,\n        authenticationMethod: 21,\n        authenticationData: 22,\n        payloadFormatIndicator: 1,\n        messageExpiryInterval: 2,\n        contentType: 3,\n        responseTopic: 8,\n        correlationData: 9,\n        maximumQoS: 36,\n        retainAvailable: 37,\n        assignedClientIdentifier: 18,\n        reasonString: 31,\n        wildcardSubscriptionAvailable: 40,\n        subscriptionIdentifiersAvailable: 41,\n        sharedSubscriptionAvailable: 42,\n        serverKeepAlive: 19,\n        responseInformation: 26,\n        serverReference: 28,\n        topicAlias: 35,\n        subscriptionIdentifier: 11\n      };\n      protocol.propertiesCodes = {};\n      for (var prop in protocol.properties) {\n        var id = protocol.properties[prop];\n        protocol.propertiesCodes[id] = prop;\n      }\n      protocol.propertiesTypes = {\n        sessionExpiryInterval: 'int32',\n        willDelayInterval: 'int32',\n        receiveMaximum: 'int16',\n        maximumPacketSize: 'int32',\n        topicAliasMaximum: 'int16',\n        requestResponseInformation: 'byte',\n        requestProblemInformation: 'byte',\n        userProperties: 'pair',\n        authenticationMethod: 'string',\n        authenticationData: 'binary',\n        payloadFormatIndicator: 'byte',\n        messageExpiryInterval: 'int32',\n        contentType: 'string',\n        responseTopic: 'string',\n        correlationData: 'binary',\n        maximumQoS: 'int8',\n        retainAvailable: 'byte',\n        assignedClientIdentifier: 'string',\n        reasonString: 'string',\n        wildcardSubscriptionAvailable: 'byte',\n        subscriptionIdentifiersAvailable: 'byte',\n        sharedSubscriptionAvailable: 'byte',\n        serverKeepAlive: 'int32',\n        responseInformation: 'string',\n        serverReference: 'string',\n        topicAlias: 'int16',\n        subscriptionIdentifier: 'var'\n      };\n      function genHeader(type) {\n        return [0, 1, 2].map(function (qos) {\n          return [0, 1].map(function (dup) {\n            return [0, 1].map(function (retain) {\n              var buf = new Buffer(1);\n              buf.writeUInt8(protocol.codes[type] << protocol.CMD_SHIFT | (dup ? protocol.DUP_MASK : 0) | qos << protocol.QOS_SHIFT | retain, 0, true);\n              return buf;\n            });\n          });\n        });\n      }\n\n      /* Publish */\n      protocol.PUBLISH_HEADER = genHeader('publish');\n\n      /* Subscribe */\n      protocol.SUBSCRIBE_HEADER = genHeader('subscribe');\n      protocol.SUBSCRIBE_OPTIONS_QOS_MASK = 0x03;\n      protocol.SUBSCRIBE_OPTIONS_NL_MASK = 0x01;\n      protocol.SUBSCRIBE_OPTIONS_NL_SHIFT = 2;\n      protocol.SUBSCRIBE_OPTIONS_RAP_MASK = 0x01;\n      protocol.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3;\n      protocol.SUBSCRIBE_OPTIONS_RH_MASK = 0x03;\n      protocol.SUBSCRIBE_OPTIONS_RH_SHIFT = 4;\n      protocol.SUBSCRIBE_OPTIONS_RH = [0x00, 0x10, 0x20];\n      protocol.SUBSCRIBE_OPTIONS_NL = 0x04;\n      protocol.SUBSCRIBE_OPTIONS_RAP = 0x08;\n      protocol.SUBSCRIBE_OPTIONS_QOS = [0x00, 0x01, 0x02];\n\n      /* Unsubscribe */\n      protocol.UNSUBSCRIBE_HEADER = genHeader('unsubscribe');\n\n      /* Confirmations */\n      protocol.ACKS = {\n        unsuback: genHeader('unsuback'),\n        puback: genHeader('puback'),\n        pubcomp: genHeader('pubcomp'),\n        pubrel: genHeader('pubrel'),\n        pubrec: genHeader('pubrec')\n      };\n      protocol.SUBACK_HEADER = Buffer.from([protocol.codes['suback'] << protocol.CMD_SHIFT]);\n\n      /* Protocol versions */\n      protocol.VERSION3 = Buffer.from([3]);\n      protocol.VERSION4 = Buffer.from([4]);\n      protocol.VERSION5 = Buffer.from([5]);\n\n      /* QoS */\n      protocol.QOS = [0, 1, 2].map(function (qos) {\n        return Buffer.from([qos]);\n      });\n\n      /* Empty packets */\n      protocol.EMPTY = {\n        pingreq: Buffer.from([protocol.codes['pingreq'] << 4, 0]),\n        pingresp: Buffer.from([protocol.codes['pingresp'] << 4, 0]),\n        disconnect: Buffer.from([protocol.codes['disconnect'] << 4, 0])\n      };\n    }, {\n      \"safe-buffer\": 118\n    }],\n    91: [function (require, module, exports) {\n      'use strict';\n\n      var Buffer = require('safe-buffer').Buffer;\n      var writeToStream = require('./writeToStream');\n      var EE = require('events').EventEmitter;\n      var inherits = require('inherits');\n      function generate(packet, opts) {\n        var stream = new Accumulator();\n        writeToStream(packet, stream, opts);\n        return stream.concat();\n      }\n      function Accumulator() {\n        this._array = new Array(20);\n        this._i = 0;\n      }\n      inherits(Accumulator, EE);\n      Accumulator.prototype.write = function (chunk) {\n        this._array[this._i++] = chunk;\n        return true;\n      };\n      Accumulator.prototype.concat = function () {\n        var length = 0;\n        var lengths = new Array(this._array.length);\n        var list = this._array;\n        var pos = 0;\n        var i;\n        var result;\n        for (i = 0; i < list.length && list[i] !== undefined; i++) {\n          if (typeof list[i] !== 'string') lengths[i] = list[i].length;else lengths[i] = Buffer.byteLength(list[i]);\n          length += lengths[i];\n        }\n        result = Buffer.allocUnsafe(length);\n        for (i = 0; i < list.length && list[i] !== undefined; i++) {\n          if (typeof list[i] !== 'string') {\n            list[i].copy(result, pos);\n            pos += lengths[i];\n          } else {\n            result.write(list[i], pos);\n            pos += lengths[i];\n          }\n        }\n        return result;\n      };\n      module.exports = generate;\n    }, {\n      \"./writeToStream\": 97,\n      \"events\": 83,\n      \"inherits\": 88,\n      \"safe-buffer\": 118\n    }],\n    92: [function (require, module, exports) {\n      'use strict';\n\n      exports.parser = require('./parser');\n      exports.generate = require('./generate');\n      exports.writeToStream = require('./writeToStream');\n    }, {\n      \"./generate\": 91,\n      \"./parser\": 96,\n      \"./writeToStream\": 97\n    }],\n    93: [function (require, module, exports) {\n      var DuplexStream = require('readable-stream/duplex'),\n        util = require('util'),\n        Buffer = require('safe-buffer').Buffer;\n      function BufferList(callback) {\n        if (!(this instanceof BufferList)) return new BufferList(callback);\n        this._bufs = [];\n        this.length = 0;\n        if (typeof callback == 'function') {\n          this._callback = callback;\n          var piper = function piper(err) {\n            if (this._callback) {\n              this._callback(err);\n              this._callback = null;\n            }\n          }.bind(this);\n          this.on('pipe', function onPipe(src) {\n            src.on('error', piper);\n          });\n          this.on('unpipe', function onUnpipe(src) {\n            src.removeListener('error', piper);\n          });\n        } else {\n          this.append(callback);\n        }\n        DuplexStream.call(this);\n      }\n      util.inherits(BufferList, DuplexStream);\n      BufferList.prototype._offset = function _offset(offset) {\n        var tot = 0,\n          i = 0,\n          _t;\n        if (offset === 0) return [0, 0];\n        for (; i < this._bufs.length; i++) {\n          _t = tot + this._bufs[i].length;\n          if (offset < _t || i == this._bufs.length - 1) return [i, offset - tot];\n          tot = _t;\n        }\n      };\n      BufferList.prototype.append = function append(buf) {\n        var i = 0;\n        if (Buffer.isBuffer(buf)) {\n          this._appendBuffer(buf);\n        } else if (Array.isArray(buf)) {\n          for (; i < buf.length; i++) {\n            this.append(buf[i]);\n          }\n        } else if (buf instanceof BufferList) {\n          // unwrap argument into individual BufferLists\n          for (; i < buf._bufs.length; i++) {\n            this.append(buf._bufs[i]);\n          }\n        } else if (buf != null) {\n          // coerce number arguments to strings, since Buffer(number) does\n          // uninitialized memory allocation\n          if (typeof buf == 'number') buf = buf.toString();\n          this._appendBuffer(Buffer.from(buf));\n        }\n        return this;\n      };\n      BufferList.prototype._appendBuffer = function appendBuffer(buf) {\n        this._bufs.push(buf);\n        this.length += buf.length;\n      };\n      BufferList.prototype._write = function _write(buf, encoding, callback) {\n        this._appendBuffer(buf);\n        if (typeof callback == 'function') callback();\n      };\n      BufferList.prototype._read = function _read(size) {\n        if (!this.length) return this.push(null);\n        size = Math.min(size, this.length);\n        this.push(this.slice(0, size));\n        this.consume(size);\n      };\n      BufferList.prototype.end = function end(chunk) {\n        DuplexStream.prototype.end.call(this, chunk);\n        if (this._callback) {\n          this._callback(null, this.slice());\n          this._callback = null;\n        }\n      };\n      BufferList.prototype.get = function get(index) {\n        return this.slice(index, index + 1)[0];\n      };\n      BufferList.prototype.slice = function slice(start, end) {\n        if (typeof start == 'number' && start < 0) start += this.length;\n        if (typeof end == 'number' && end < 0) end += this.length;\n        return this.copy(null, 0, start, end);\n      };\n      BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {\n        if (typeof srcStart != 'number' || srcStart < 0) srcStart = 0;\n        if (typeof srcEnd != 'number' || srcEnd > this.length) srcEnd = this.length;\n        if (srcStart >= this.length) return dst || Buffer.alloc(0);\n        if (srcEnd <= 0) return dst || Buffer.alloc(0);\n        var copy = !!dst,\n          off = this._offset(srcStart),\n          len = srcEnd - srcStart,\n          bytes = len,\n          bufoff = copy && dstStart || 0,\n          start = off[1],\n          l,\n          i;\n\n        // copy/slice everything\n        if (srcStart === 0 && srcEnd == this.length) {\n          if (!copy) {\n            // slice, but full concat if multiple buffers\n            return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);\n          }\n\n          // copy, need to copy individual buffers\n          for (i = 0; i < this._bufs.length; i++) {\n            this._bufs[i].copy(dst, bufoff);\n            bufoff += this._bufs[i].length;\n          }\n          return dst;\n        }\n\n        // easy, cheap case where it's a subset of one of the buffers\n        if (bytes <= this._bufs[off[0]].length - start) {\n          return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);\n        }\n        if (!copy)\n          // a slice, we need something to copy in to\n          dst = Buffer.allocUnsafe(len);\n        for (i = off[0]; i < this._bufs.length; i++) {\n          l = this._bufs[i].length - start;\n          if (bytes > l) {\n            this._bufs[i].copy(dst, bufoff, start);\n          } else {\n            this._bufs[i].copy(dst, bufoff, start, start + bytes);\n            break;\n          }\n          bufoff += l;\n          bytes -= l;\n          if (start) start = 0;\n        }\n        return dst;\n      };\n      BufferList.prototype.shallowSlice = function shallowSlice(start, end) {\n        start = start || 0;\n        end = end || this.length;\n        if (start < 0) start += this.length;\n        if (end < 0) end += this.length;\n        var startOffset = this._offset(start),\n          endOffset = this._offset(end),\n          buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);\n        if (endOffset[1] == 0) buffers.pop();else buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);\n        if (startOffset[1] != 0) buffers[0] = buffers[0].slice(startOffset[1]);\n        return new BufferList(buffers);\n      };\n      BufferList.prototype.toString = function toString(encoding, start, end) {\n        return this.slice(start, end).toString(encoding);\n      };\n      BufferList.prototype.consume = function consume(bytes) {\n        while (this._bufs.length) {\n          if (bytes >= this._bufs[0].length) {\n            bytes -= this._bufs[0].length;\n            this.length -= this._bufs[0].length;\n            this._bufs.shift();\n          } else {\n            this._bufs[0] = this._bufs[0].slice(bytes);\n            this.length -= bytes;\n            break;\n          }\n        }\n        return this;\n      };\n      BufferList.prototype.duplicate = function duplicate() {\n        var i = 0,\n          copy = new BufferList();\n        for (; i < this._bufs.length; i++) {\n          copy.append(this._bufs[i]);\n        }\n        return copy;\n      };\n      BufferList.prototype.destroy = function destroy() {\n        this._bufs.length = 0;\n        this.length = 0;\n        this.push(null);\n      };\n      (function () {\n        var methods = {\n          'readDoubleBE': 8,\n          'readDoubleLE': 8,\n          'readFloatBE': 4,\n          'readFloatLE': 4,\n          'readInt32BE': 4,\n          'readInt32LE': 4,\n          'readUInt32BE': 4,\n          'readUInt32LE': 4,\n          'readInt16BE': 2,\n          'readInt16LE': 2,\n          'readUInt16BE': 2,\n          'readUInt16LE': 2,\n          'readInt8': 1,\n          'readUInt8': 1\n        };\n        for (var m in methods) {\n          (function (m) {\n            BufferList.prototype[m] = function (offset) {\n              return this.slice(offset, offset + methods[m])[m](0);\n            };\n          })(m);\n        }\n      })();\n      module.exports = BufferList;\n    }, {\n      \"readable-stream/duplex\": 105,\n      \"safe-buffer\": 118,\n      \"util\": 136\n    }],\n    94: [function (require, module, exports) {\n      'use strict';\n\n      var Buffer = require('safe-buffer').Buffer;\n      var max = 65536;\n      var cache = {};\n      function generateBuffer(i) {\n        var buffer = Buffer.allocUnsafe(2);\n        buffer.writeUInt8(i >> 8, 0);\n        buffer.writeUInt8(i & 0x00FF, 0 + 1);\n        return buffer;\n      }\n      function generateCache() {\n        for (var i = 0; i < max; i++) {\n          cache[i] = generateBuffer(i);\n        }\n      }\n\n      /**\n       * calcVariableByteIntLength - calculate the variable byte integer\n       * length field\n       *\n       * @api private\n       */\n      function calcVariableByteIntLength(length) {\n        if (length >= 0 && length < 128) return 1;else if (length >= 128 && length < 16384) return 2;else if (length >= 16384 && length < 2097152) return 3;else if (length >= 2097152 && length < 268435456) return 4;else return 0;\n      }\n      function genBufVariableByteInt(num) {\n        var digit = 0;\n        var pos = 0;\n        var length = calcVariableByteIntLength(num);\n        var buffer = Buffer.allocUnsafe(length);\n        do {\n          digit = num % 128 | 0;\n          num = num / 128 | 0;\n          if (num > 0) digit = digit | 0x80;\n          buffer.writeUInt8(digit, pos++);\n        } while (num > 0);\n        return {\n          data: buffer,\n          length: length\n        };\n      }\n      function generate4ByteBuffer(num) {\n        var buffer = Buffer.allocUnsafe(4);\n        buffer.writeUInt32BE(num, 0);\n        return buffer;\n      }\n      module.exports = {\n        cache: cache,\n        generateCache: generateCache,\n        generateNumber: generateBuffer,\n        genBufVariableByteInt: genBufVariableByteInt,\n        generate4ByteBuffer: generate4ByteBuffer\n      };\n    }, {\n      \"safe-buffer\": 118\n    }],\n    95: [function (require, module, exports) {\n      function Packet() {\n        this.cmd = null;\n        this.retain = false;\n        this.qos = 0;\n        this.dup = false;\n        this.length = -1;\n        this.topic = null;\n        this.payload = null;\n      }\n      module.exports = Packet;\n    }, {}],\n    96: [function (require, module, exports) {\n      'use strict';\n\n      var bl = require('bl');\n      var inherits = require('inherits');\n      var EE = require('events').EventEmitter;\n      var Packet = require('./packet');\n      var constants = require('./constants');\n      function Parser(opt) {\n        if (!(this instanceof Parser)) return new Parser(opt);\n        this.settings = opt || {};\n        this._states = ['_parseHeader', '_parseLength', '_parsePayload', '_newPacket'];\n        this._resetState();\n      }\n      inherits(Parser, EE);\n      Parser.prototype._resetState = function () {\n        this.packet = new Packet();\n        this.error = null;\n        this._list = bl();\n        this._stateCounter = 0;\n      };\n      Parser.prototype.parse = function (buf) {\n        if (this.error) this._resetState();\n        this._list.append(buf);\n        while ((this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error) {\n          this._stateCounter++;\n          if (this._stateCounter >= this._states.length) this._stateCounter = 0;\n        }\n        return this._list.length;\n      };\n      Parser.prototype._parseHeader = function () {\n        // There is at least one byte in the buffer\n        var zero = this._list.readUInt8(0);\n        this.packet.cmd = constants.types[zero >> constants.CMD_SHIFT];\n        this.packet.retain = (zero & constants.RETAIN_MASK) !== 0;\n        this.packet.qos = zero >> constants.QOS_SHIFT & constants.QOS_MASK;\n        this.packet.dup = (zero & constants.DUP_MASK) !== 0;\n        this._list.consume(1);\n        return true;\n      };\n      Parser.prototype._parseLength = function () {\n        // There is at least one byte in the list\n        var result = this._parseVarByteNum(true);\n        if (result) {\n          this.packet.length = result.value;\n          this._list.consume(result.bytes);\n        }\n        return !!result;\n      };\n      Parser.prototype._parsePayload = function () {\n        var result = false;\n\n        // Do we have a payload? Do we have enough data to complete the payload?\n        // PINGs have no payload\n        if (this.packet.length === 0 || this._list.length >= this.packet.length) {\n          this._pos = 0;\n          switch (this.packet.cmd) {\n            case 'connect':\n              this._parseConnect();\n              break;\n            case 'connack':\n              this._parseConnack();\n              break;\n            case 'publish':\n              this._parsePublish();\n              break;\n            case 'puback':\n            case 'pubrec':\n            case 'pubrel':\n            case 'pubcomp':\n              this._parseConfirmation();\n              break;\n            case 'subscribe':\n              this._parseSubscribe();\n              break;\n            case 'suback':\n              this._parseSuback();\n              break;\n            case 'unsubscribe':\n              this._parseUnsubscribe();\n              break;\n            case 'unsuback':\n              this._parseUnsuback();\n              break;\n            case 'pingreq':\n            case 'pingresp':\n              // These are empty, nothing to do\n              break;\n            case 'disconnect':\n              this._parseDisconnect();\n              break;\n            case 'auth':\n              this._parseAuth();\n              break;\n            default:\n              this._emitError(new Error('Not supported'));\n          }\n          result = true;\n        }\n        return result;\n      };\n      Parser.prototype._parseConnect = function () {\n        var protocolId; // Protocol ID\n        var clientId; // Client ID\n        var topic; // Will topic\n        var payload; // Will payload\n        var password; // Password\n        var username; // Username\n        var flags = {};\n        var packet = this.packet;\n\n        // Parse protocolId\n        protocolId = this._parseString();\n        if (protocolId === null) return this._emitError(new Error('Cannot parse protocolId'));\n        if (protocolId !== 'MQTT' && protocolId !== 'MQIsdp') {\n          return this._emitError(new Error('Invalid protocolId'));\n        }\n        packet.protocolId = protocolId;\n\n        // Parse constants version number\n        if (this._pos >= this._list.length) return this._emitError(new Error('Packet too short'));\n        packet.protocolVersion = this._list.readUInt8(this._pos);\n        if (packet.protocolVersion !== 3 && packet.protocolVersion !== 4 && packet.protocolVersion !== 5) {\n          return this._emitError(new Error('Invalid protocol version'));\n        }\n        this._pos++;\n        if (this._pos >= this._list.length) {\n          return this._emitError(new Error('Packet too short'));\n        }\n\n        // Parse connect flags\n        flags.username = this._list.readUInt8(this._pos) & constants.USERNAME_MASK;\n        flags.password = this._list.readUInt8(this._pos) & constants.PASSWORD_MASK;\n        flags.will = this._list.readUInt8(this._pos) & constants.WILL_FLAG_MASK;\n        if (flags.will) {\n          packet.will = {};\n          packet.will.retain = (this._list.readUInt8(this._pos) & constants.WILL_RETAIN_MASK) !== 0;\n          packet.will.qos = (this._list.readUInt8(this._pos) & constants.WILL_QOS_MASK) >> constants.WILL_QOS_SHIFT;\n        }\n        packet.clean = (this._list.readUInt8(this._pos) & constants.CLEAN_SESSION_MASK) !== 0;\n        this._pos++;\n\n        // Parse keepalive\n        packet.keepalive = this._parseNum();\n        if (packet.keepalive === -1) return this._emitError(new Error('Packet too short'));\n\n        // parse properties\n        if (packet.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n        // Parse clientId\n        clientId = this._parseString();\n        if (clientId === null) return this._emitError(new Error('Packet too short'));\n        packet.clientId = clientId;\n        if (flags.will) {\n          if (packet.protocolVersion === 5) {\n            var willProperties = this._parseProperties();\n            if (Object.getOwnPropertyNames(willProperties).length) {\n              packet.will.properties = willProperties;\n            }\n          }\n          // Parse will topic\n          topic = this._parseString();\n          if (topic === null) return this._emitError(new Error('Cannot parse will topic'));\n          packet.will.topic = topic;\n\n          // Parse will payload\n          payload = this._parseBuffer();\n          if (payload === null) return this._emitError(new Error('Cannot parse will payload'));\n          packet.will.payload = payload;\n        }\n\n        // Parse username\n        if (flags.username) {\n          username = this._parseString();\n          if (username === null) return this._emitError(new Error('Cannot parse username'));\n          packet.username = username;\n        }\n\n        // Parse password\n        if (flags.password) {\n          password = this._parseBuffer();\n          if (password === null) return this._emitError(new Error('Cannot parse password'));\n          packet.password = password;\n        }\n        // need for right parse auth packet and self set up\n        this.settings = packet;\n        return packet;\n      };\n      Parser.prototype._parseConnack = function () {\n        var packet = this.packet;\n        if (this._list.length < 2) return null;\n        packet.sessionPresent = !!(this._list.readUInt8(this._pos++) & constants.SESSIONPRESENT_MASK);\n        if (this.settings.protocolVersion === 5) {\n          packet.reasonCode = this._list.readUInt8(this._pos++);\n        } else {\n          packet.returnCode = this._list.readUInt8(this._pos++);\n        }\n        if (packet.returnCode === -1 || packet.reasonCode === -1) return this._emitError(new Error('Cannot parse return code'));\n        // mqtt 5 properties\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n      };\n      Parser.prototype._parsePublish = function () {\n        var packet = this.packet;\n        packet.topic = this._parseString();\n        if (packet.topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n        // Parse messageId\n        if (packet.qos > 0) if (!this._parseMessageId()) {\n          return;\n        }\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n        packet.payload = this._list.slice(this._pos, packet.length);\n      };\n      Parser.prototype._parseSubscribe = function () {\n        var packet = this.packet;\n        var topic;\n        var options;\n        var qos;\n        var rh;\n        var rap;\n        var nl;\n        var subscription;\n        if (packet.qos !== 1) {\n          return this._emitError(new Error('Wrong subscribe header'));\n        }\n        packet.subscriptions = [];\n        if (!this._parseMessageId()) {\n          return;\n        }\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n        while (this._pos < packet.length) {\n          // Parse topic\n          topic = this._parseString();\n          if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n          options = this._parseByte();\n          qos = options & constants.SUBSCRIBE_OPTIONS_QOS_MASK;\n          nl = (options >> constants.SUBSCRIBE_OPTIONS_NL_SHIFT & constants.SUBSCRIBE_OPTIONS_NL_MASK) !== 0;\n          rap = (options >> constants.SUBSCRIBE_OPTIONS_RAP_SHIFT & constants.SUBSCRIBE_OPTIONS_RAP_MASK) !== 0;\n          rh = options >> constants.SUBSCRIBE_OPTIONS_RH_SHIFT & constants.SUBSCRIBE_OPTIONS_RH_MASK;\n          subscription = {\n            topic: topic,\n            qos: qos\n          };\n\n          // mqtt 5 options\n          if (this.settings.protocolVersion === 5) {\n            subscription.nl = nl;\n            subscription.rap = rap;\n            subscription.rh = rh;\n          }\n\n          // Push pair to subscriptions\n          packet.subscriptions.push(subscription);\n        }\n      };\n      Parser.prototype._parseSuback = function () {\n        var packet = this.packet;\n        this.packet.granted = [];\n        if (!this._parseMessageId()) {\n          return;\n        }\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n\n        // Parse granted QoSes\n        while (this._pos < this.packet.length) {\n          this.packet.granted.push(this._list.readUInt8(this._pos++));\n        }\n      };\n      Parser.prototype._parseUnsubscribe = function () {\n        var packet = this.packet;\n        packet.unsubscriptions = [];\n\n        // Parse messageId\n        if (!this._parseMessageId()) {\n          return;\n        }\n\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n        while (this._pos < packet.length) {\n          var topic;\n\n          // Parse topic\n          topic = this._parseString();\n          if (topic === null) return this._emitError(new Error('Cannot parse topic'));\n\n          // Push topic to unsubscriptions\n          packet.unsubscriptions.push(topic);\n        }\n      };\n      Parser.prototype._parseUnsuback = function () {\n        var packet = this.packet;\n        if (!this._parseMessageId()) return this._emitError(new Error('Cannot parse messageId'));\n        // Properties mqtt 5\n        if (this.settings.protocolVersion === 5) {\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n          // Parse granted QoSes\n          packet.granted = [];\n          while (this._pos < this.packet.length) {\n            this.packet.granted.push(this._list.readUInt8(this._pos++));\n          }\n        }\n      };\n\n      // parse packets like puback, pubrec, pubrel, pubcomp\n      Parser.prototype._parseConfirmation = function () {\n        var packet = this.packet;\n        this._parseMessageId();\n        if (this.settings.protocolVersion === 5) {\n          if (packet.length > 2) {\n            // response code\n            packet.reasonCode = this._parseByte();\n            // properies mqtt 5\n            var properties = this._parseProperties();\n            if (Object.getOwnPropertyNames(properties).length) {\n              packet.properties = properties;\n            }\n          }\n        }\n        return true;\n      };\n\n      // parse disconnect packet\n      Parser.prototype._parseDisconnect = function () {\n        var packet = this.packet;\n        if (this.settings.protocolVersion === 5) {\n          // response code\n          packet.reasonCode = this._parseByte();\n          // properies mqtt 5\n          var properties = this._parseProperties();\n          if (Object.getOwnPropertyNames(properties).length) {\n            packet.properties = properties;\n          }\n        }\n        return true;\n      };\n\n      // parse auth packet\n      Parser.prototype._parseAuth = function () {\n        var packet = this.packet;\n        if (this.settings.protocolVersion !== 5) {\n          return this._emitError(new Error('Not supported auth packet for this version MQTT'));\n        }\n\n        // response code\n        packet.reasonCode = this._parseByte();\n        // properies mqtt 5\n        var properties = this._parseProperties();\n        if (Object.getOwnPropertyNames(properties).length) {\n          packet.properties = properties;\n        }\n        return true;\n      };\n      Parser.prototype._parseMessageId = function () {\n        var packet = this.packet;\n        packet.messageId = this._parseNum();\n        if (packet.messageId === null) {\n          this._emitError(new Error('Cannot parse messageId'));\n          return false;\n        }\n        return true;\n      };\n      Parser.prototype._parseString = function (maybeBuffer) {\n        var length = this._parseNum();\n        var result;\n        var end = length + this._pos;\n        if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n        result = this._list.toString('utf8', this._pos, end);\n        this._pos += length;\n        return result;\n      };\n      Parser.prototype._parseStringPair = function () {\n        return {\n          name: this._parseString(),\n          value: this._parseString()\n        };\n      };\n      Parser.prototype._parseBuffer = function () {\n        var length = this._parseNum();\n        var result;\n        var end = length + this._pos;\n        if (length === -1 || end > this._list.length || end > this.packet.length) return null;\n        result = this._list.slice(this._pos, end);\n        this._pos += length;\n        return result;\n      };\n      Parser.prototype._parseNum = function () {\n        if (this._list.length - this._pos < 2) return -1;\n        var result = this._list.readUInt16BE(this._pos);\n        this._pos += 2;\n        return result;\n      };\n      Parser.prototype._parse4ByteNum = function () {\n        if (this._list.length - this._pos < 4) return -1;\n        var result = this._list.readUInt32BE(this._pos);\n        this._pos += 4;\n        return result;\n      };\n      Parser.prototype._parseVarByteNum = function (fullInfoFlag) {\n        var bytes = 0;\n        var mul = 1;\n        var length = 0;\n        var result = true;\n        var current;\n        var padding = this._pos ? this._pos : 0;\n        while (bytes < 5) {\n          current = this._list.readUInt8(padding + bytes++);\n          length += mul * (current & constants.LENGTH_MASK);\n          mul *= 0x80;\n          if ((current & constants.LENGTH_FIN_MASK) === 0) break;\n          if (this._list.length <= bytes) {\n            result = false;\n            break;\n          }\n        }\n        if (padding) {\n          this._pos += bytes;\n        }\n        result = result ? fullInfoFlag ? {\n          bytes: bytes,\n          value: length\n        } : length : false;\n        return result;\n      };\n      Parser.prototype._parseByte = function () {\n        var result = this._list.readUInt8(this._pos);\n        this._pos++;\n        return result;\n      };\n      Parser.prototype._parseByType = function (type) {\n        switch (type) {\n          case 'byte':\n            {\n              return this._parseByte() !== 0;\n            }\n          case 'int8':\n            {\n              return this._parseByte();\n            }\n          case 'int16':\n            {\n              return this._parseNum();\n            }\n          case 'int32':\n            {\n              return this._parse4ByteNum();\n            }\n          case 'var':\n            {\n              return this._parseVarByteNum();\n            }\n          case 'string':\n            {\n              return this._parseString();\n            }\n          case 'pair':\n            {\n              return this._parseStringPair();\n            }\n          case 'binary':\n            {\n              return this._parseBuffer();\n            }\n        }\n      };\n      Parser.prototype._parseProperties = function () {\n        var length = this._parseVarByteNum();\n        var start = this._pos;\n        var end = start + length;\n        var result = {};\n        while (this._pos < end) {\n          var type = this._parseByte();\n          var name = constants.propertiesCodes[type];\n          if (!name) {\n            this._emitError(new Error('Unknown property'));\n            return false;\n          }\n          // user properties process\n          if (name === 'userProperties') {\n            if (!result[name]) {\n              result[name] = {};\n            }\n            var currentUserProperty = this._parseByType(constants.propertiesTypes[name]);\n            result[name][currentUserProperty.name] = currentUserProperty.value;\n            continue;\n          }\n          result[name] = this._parseByType(constants.propertiesTypes[name]);\n        }\n        return result;\n      };\n      Parser.prototype._newPacket = function () {\n        if (this.packet) {\n          this._list.consume(this.packet.length);\n          this.emit('packet', this.packet);\n        }\n        this.packet = new Packet();\n        this._pos = 0;\n        return true;\n      };\n      Parser.prototype._emitError = function (err) {\n        this.error = err;\n        this.emit('error', err);\n      };\n      module.exports = Parser;\n    }, {\n      \"./constants\": 90,\n      \"./packet\": 95,\n      \"bl\": 93,\n      \"events\": 83,\n      \"inherits\": 88\n    }],\n    97: [function (require, module, exports) {\n      'use strict';\n\n      var protocol = require('./constants');\n      var Buffer = require('safe-buffer').Buffer;\n      var empty = Buffer.allocUnsafe(0);\n      var zeroBuf = Buffer.from([0]);\n      var numbers = require('./numbers');\n      var nextTick = require('process-nextick-args').nextTick;\n      var numCache = numbers.cache;\n      var generateNumber = numbers.generateNumber;\n      var generateCache = numbers.generateCache;\n      var genBufVariableByteInt = numbers.genBufVariableByteInt;\n      var generate4ByteBuffer = numbers.generate4ByteBuffer;\n      var writeNumber = writeNumberCached;\n      var toGenerate = true;\n      function generate(packet, stream, opts) {\n        if (stream.cork) {\n          stream.cork();\n          nextTick(uncork, stream);\n        }\n        if (toGenerate) {\n          toGenerate = false;\n          generateCache();\n        }\n        switch (packet.cmd) {\n          case 'connect':\n            return connect(packet, stream, opts);\n          case 'connack':\n            return connack(packet, stream, opts);\n          case 'publish':\n            return publish(packet, stream, opts);\n          case 'puback':\n          case 'pubrec':\n          case 'pubrel':\n          case 'pubcomp':\n            return confirmation(packet, stream, opts);\n          case 'subscribe':\n            return subscribe(packet, stream, opts);\n          case 'suback':\n            return suback(packet, stream, opts);\n          case 'unsubscribe':\n            return unsubscribe(packet, stream, opts);\n          case 'unsuback':\n            return unsuback(packet, stream, opts);\n          case 'pingreq':\n          case 'pingresp':\n            return emptyPacket(packet, stream, opts);\n          case 'disconnect':\n            return disconnect(packet, stream, opts);\n          case 'auth':\n            return auth(packet, stream, opts);\n          default:\n            stream.emit('error', new Error('Unknown command'));\n            return false;\n        }\n      }\n      /**\n       * Controls numbers cache.\n       * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n       */\n      Object.defineProperty(generate, 'cacheNumbers', {\n        get: function get() {\n          return writeNumber === writeNumberCached;\n        },\n        set: function set(value) {\n          if (value) {\n            if (!numCache || Object.keys(numCache).length === 0) toGenerate = true;\n            writeNumber = writeNumberCached;\n          } else {\n            toGenerate = false;\n            writeNumber = writeNumberGenerated;\n          }\n        }\n      });\n      function uncork(stream) {\n        stream.uncork();\n      }\n      function connect(packet, stream, opts) {\n        var settings = packet || {};\n        var protocolId = settings.protocolId || 'MQTT';\n        var protocolVersion = settings.protocolVersion || 4;\n        var will = settings.will;\n        var clean = settings.clean;\n        var keepalive = settings.keepalive || 0;\n        var clientId = settings.clientId || '';\n        var username = settings.username;\n        var password = settings.password;\n        /* mqtt5 new oprions */\n        var properties = settings.properties;\n        if (clean === undefined) clean = true;\n        var length = 0;\n\n        // Must be a string and non-falsy\n        if (!protocolId || typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId)) {\n          stream.emit('error', new Error('Invalid protocolId'));\n          return false;\n        } else length += protocolId.length + 2;\n\n        // Must be 3 or 4 or 5\n        if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n          stream.emit('error', new Error('Invalid protocol version'));\n          return false;\n        } else length += 1;\n\n        // ClientId might be omitted in 3.1.1, but only if cleanSession is set to 1\n        if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) && (clientId || protocolVersion === 4) && (clientId || clean)) {\n          length += clientId.length + 2;\n        } else {\n          if (protocolVersion < 4) {\n            stream.emit('error', new Error('clientId must be supplied before 3.1.1'));\n            return false;\n          }\n          if (clean * 1 === 0) {\n            stream.emit('error', new Error('clientId must be given if cleanSession set to 0'));\n            return false;\n          }\n        }\n\n        // Must be a two byte number\n        if (typeof keepalive !== 'number' || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {\n          stream.emit('error', new Error('Invalid keepalive'));\n          return false;\n        } else length += 2;\n\n        // Connect flags\n        length += 1;\n\n        // Properties\n        if (protocolVersion === 5) {\n          var propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // If will exists...\n        if (will) {\n          // It must be an object\n          if (_typeof(will) !== 'object') {\n            stream.emit('error', new Error('Invalid will'));\n            return false;\n          }\n          // It must have topic typeof string\n          if (!will.topic || typeof will.topic !== 'string') {\n            stream.emit('error', new Error('Invalid will topic'));\n            return false;\n          } else {\n            length += Buffer.byteLength(will.topic) + 2;\n          }\n\n          // Payload\n          if (will.payload) {\n            if (will.payload.length >= 0) {\n              if (typeof will.payload === 'string') {\n                length += Buffer.byteLength(will.payload) + 2;\n              } else {\n                length += will.payload.length + 2;\n              }\n            } else {\n              stream.emit('error', new Error('Invalid will payload'));\n              return false;\n            }\n\n            // will properties\n            var willProperties = {};\n            if (protocolVersion === 5) {\n              willProperties = getProperties(stream, will.properties);\n              length += willProperties.length;\n            }\n          }\n        }\n\n        // Username\n        var providedUsername = false;\n        if (username != null) {\n          if (isStringOrBuffer(username)) {\n            providedUsername = true;\n            length += Buffer.byteLength(username) + 2;\n          } else {\n            stream.emit('error', new Error('Invalid username'));\n            return false;\n          }\n        }\n\n        // Password\n        if (password != null) {\n          if (!providedUsername) {\n            stream.emit('error', new Error('Username is required to use password'));\n            return false;\n          }\n          if (isStringOrBuffer(password)) {\n            length += byteLength(password) + 2;\n          } else {\n            stream.emit('error', new Error('Invalid password'));\n            return false;\n          }\n        }\n\n        // Generate header\n        stream.write(protocol.CONNECT_HEADER);\n\n        // Generate length\n        writeVarByteInt(stream, length);\n\n        // Generate protocol ID\n        writeStringOrBuffer(stream, protocolId);\n        stream.write(protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3);\n\n        // Connect flags\n        var flags = 0;\n        flags |= username != null ? protocol.USERNAME_MASK : 0;\n        flags |= password != null ? protocol.PASSWORD_MASK : 0;\n        flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;\n        flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;\n        flags |= will ? protocol.WILL_FLAG_MASK : 0;\n        flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;\n        stream.write(Buffer.from([flags]));\n\n        // Keepalive\n        writeNumber(stream, keepalive);\n\n        // Properties\n        if (protocolVersion === 5) {\n          propertiesData.write();\n        }\n\n        // Client ID\n        writeStringOrBuffer(stream, clientId);\n\n        // Will\n        if (will) {\n          if (protocolVersion === 5) {\n            willProperties.write();\n          }\n          writeString(stream, will.topic);\n          writeStringOrBuffer(stream, will.payload);\n        }\n\n        // Username and password\n        if (username != null) {\n          writeStringOrBuffer(stream, username);\n        }\n        if (password != null) {\n          writeStringOrBuffer(stream, password);\n        }\n        // This is a small packet that happens only once on a stream\n        // We assume the stream is always free to receive more data after this\n        return true;\n      }\n      function connack(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var rc = version === 5 ? settings.reasonCode : settings.returnCode;\n        var properties = settings.properties;\n        var length = 2; // length of rc and sessionHeader\n\n        // Check return code\n        if (typeof rc !== 'number') {\n          stream.emit('error', new Error('Invalid return code'));\n          return false;\n        }\n        // mqtt5 properties\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n        stream.write(protocol.CONNACK_HEADER);\n        // length\n        writeVarByteInt(stream, length);\n        stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);\n        stream.write(Buffer.from([rc]));\n        if (propertiesData != null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n      function publish(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var qos = settings.qos || 0;\n        var retain = settings.retain ? protocol.RETAIN_MASK : 0;\n        var topic = settings.topic;\n        var payload = settings.payload || empty;\n        var id = settings.messageId;\n        var properties = settings.properties;\n        var length = 0;\n\n        // Topic must be a non-empty string or Buffer\n        if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2;else if (Buffer.isBuffer(topic)) length += topic.length + 2;else {\n          stream.emit('error', new Error('Invalid topic'));\n          return false;\n        }\n\n        // Get the payload length\n        if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload);else length += payload.length;\n\n        // Message ID must a number if qos > 0\n        if (qos && typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else if (qos) length += 2;\n\n        // mqtt5 properties\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]);\n\n        // Remaining length\n        writeVarByteInt(stream, length);\n\n        // Topic\n        writeNumber(stream, byteLength(topic));\n        stream.write(topic);\n\n        // Message ID\n        if (qos > 0) writeNumber(stream, id);\n\n        // Properties\n        if (propertiesData != null) {\n          propertiesData.write();\n        }\n\n        // Payload\n        return stream.write(payload);\n      }\n\n      /* Puback, pubrec, pubrel and pubcomp */\n      function confirmation(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var type = settings.cmd || 'puback';\n        var id = settings.messageId;\n        var dup = settings.dup && type === 'pubrel' ? protocol.DUP_MASK : 0;\n        var qos = 0;\n        var reasonCode = settings.reasonCode;\n        var properties = settings.properties;\n        var length = version === 5 ? 3 : 2;\n        if (type === 'pubrel') qos = 1;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        }\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {\n            return false;\n          }\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.ACKS[type][qos][dup][0]);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // reason code in header\n        if (version === 5) {\n          stream.write(Buffer.from([reasonCode]));\n        }\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n      function subscribe(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var dup = settings.dup ? protocol.DUP_MASK : 0;\n        var id = settings.messageId;\n        var subs = settings.subscriptions;\n        var properties = settings.properties;\n        var length = 0;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else length += 2;\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // Check subscriptions\n        if (_typeof(subs) === 'object' && subs.length) {\n          for (var i = 0; i < subs.length; i += 1) {\n            var itopic = subs[i].topic;\n            var iqos = subs[i].qos;\n            if (typeof itopic !== 'string') {\n              stream.emit('error', new Error('Invalid subscriptions - invalid topic'));\n              return false;\n            }\n            if (typeof iqos !== 'number') {\n              stream.emit('error', new Error('Invalid subscriptions - invalid qos'));\n              return false;\n            }\n            if (version === 5) {\n              var nl = subs[i].nl || false;\n              if (typeof nl !== 'boolean') {\n                stream.emit('error', new Error('Invalid subscriptions - invalid No Local'));\n                return false;\n              }\n              var rap = subs[i].rap || false;\n              if (typeof rap !== 'boolean') {\n                stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'));\n                return false;\n              }\n              var rh = subs[i].rh || 0;\n              if (typeof rh !== 'number' || rh > 2) {\n                stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'));\n                return false;\n              }\n            }\n            length += Buffer.byteLength(itopic) + 2 + 1;\n          }\n        } else {\n          stream.emit('error', new Error('Invalid subscriptions'));\n          return false;\n        }\n\n        // Generate header\n        stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);\n\n        // Generate length\n        writeVarByteInt(stream, length);\n\n        // Generate message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n        var result = true;\n\n        // Generate subs\n        for (var j = 0; j < subs.length; j++) {\n          var sub = subs[j];\n          var jtopic = sub.topic;\n          var jqos = sub.qos;\n          var jnl = +sub.nl;\n          var jrap = +sub.rap;\n          var jrh = sub.rh;\n          var joptions;\n\n          // Write topic string\n          writeString(stream, jtopic);\n\n          // options process\n          joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];\n          if (version === 5) {\n            joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;\n            joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;\n            joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;\n          }\n          // Write options\n          result = stream.write(Buffer.from([joptions]));\n        }\n        return result;\n      }\n      function suback(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var id = settings.messageId;\n        var granted = settings.granted;\n        var properties = settings.properties;\n        var length = 0;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else length += 2;\n\n        // Check granted qos vector\n        if (_typeof(granted) === 'object' && granted.length) {\n          for (var i = 0; i < granted.length; i += 1) {\n            if (typeof granted[i] !== 'number') {\n              stream.emit('error', new Error('Invalid qos vector'));\n              return false;\n            }\n            length += 1;\n          }\n        } else {\n          stream.emit('error', new Error('Invalid qos vector'));\n          return false;\n        }\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {\n            return false;\n          }\n          length += propertiesData.length;\n        }\n\n        // header\n        stream.write(protocol.SUBACK_HEADER);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n        return stream.write(Buffer.from(granted));\n      }\n      function unsubscribe(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var id = settings.messageId;\n        var dup = settings.dup ? protocol.DUP_MASK : 0;\n        var unsubs = settings.unsubscriptions;\n        var properties = settings.properties;\n        var length = 0;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        } else {\n          length += 2;\n        }\n        // Check unsubs\n        if (_typeof(unsubs) === 'object' && unsubs.length) {\n          for (var i = 0; i < unsubs.length; i += 1) {\n            if (typeof unsubs[i] !== 'string') {\n              stream.emit('error', new Error('Invalid unsubscriptions'));\n              return false;\n            }\n            length += Buffer.byteLength(unsubs[i]) + 2;\n          }\n        } else {\n          stream.emit('error', new Error('Invalid unsubscriptions'));\n          return false;\n        }\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getProperties(stream, properties);\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        // Unsubs\n        var result = true;\n        for (var j = 0; j < unsubs.length; j++) {\n          result = writeString(stream, unsubs[j]);\n        }\n        return result;\n      }\n      function unsuback(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var id = settings.messageId;\n        var dup = settings.dup ? protocol.DUP_MASK : 0;\n        var granted = settings.granted;\n        var properties = settings.properties;\n        var type = settings.cmd;\n        var qos = 0;\n        var length = 2;\n\n        // Check message ID\n        if (typeof id !== 'number') {\n          stream.emit('error', new Error('Invalid messageId'));\n          return false;\n        }\n\n        // Check granted\n        if (version === 5) {\n          if (_typeof(granted) === 'object' && granted.length) {\n            for (var i = 0; i < granted.length; i += 1) {\n              if (typeof granted[i] !== 'number') {\n                stream.emit('error', new Error('Invalid qos vector'));\n                return false;\n              }\n              length += 1;\n            }\n          } else {\n            stream.emit('error', new Error('Invalid qos vector'));\n            return false;\n          }\n        }\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {\n            return false;\n          }\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(protocol.ACKS[type][qos][dup][0]);\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // Message ID\n        writeNumber(stream, id);\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n\n        // payload\n        if (version === 5) {\n          stream.write(Buffer.from(granted));\n        }\n        return true;\n      }\n      function emptyPacket(packet, stream, opts) {\n        return stream.write(protocol.EMPTY[packet.cmd]);\n      }\n      function disconnect(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var reasonCode = settings.reasonCode;\n        var properties = settings.properties;\n        var length = version === 5 ? 1 : 0;\n\n        // properies mqtt 5\n        var propertiesData = null;\n        if (version === 5) {\n          propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n          if (!propertiesData) {\n            return false;\n          }\n          length += propertiesData.length;\n        }\n\n        // Header\n        stream.write(Buffer.from([protocol.codes['disconnect'] << 4]));\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // reason code in header\n        if (version === 5) {\n          stream.write(Buffer.from([reasonCode]));\n        }\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n      function auth(packet, stream, opts) {\n        var version = opts ? opts.protocolVersion : 4;\n        var settings = packet || {};\n        var reasonCode = settings.reasonCode;\n        var properties = settings.properties;\n        var length = version === 5 ? 1 : 0;\n        if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'));\n\n        // properies mqtt 5\n        var propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n        if (!propertiesData) {\n          return false;\n        }\n        length += propertiesData.length;\n\n        // Header\n        stream.write(Buffer.from([protocol.codes['auth'] << 4]));\n\n        // Length\n        writeVarByteInt(stream, length);\n\n        // reason code in header\n        stream.write(Buffer.from([reasonCode]));\n\n        // properies mqtt 5\n        if (propertiesData !== null) {\n          propertiesData.write();\n        }\n        return true;\n      }\n\n      /**\n       * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n       *\n       * @param <Buffer> buffer - destination\n       * @param <Number> pos - offset\n       * @param <Number> length - length (>0)\n       * @returns <Number> number of bytes written\n       *\n       * @api private\n       */\n\n      var varByteIntCache = {};\n      function writeVarByteInt(stream, num) {\n        var buffer = varByteIntCache[num];\n        if (!buffer) {\n          buffer = genBufVariableByteInt(num).data;\n          if (num < 16384) varByteIntCache[num] = buffer;\n        }\n        stream.write(buffer);\n      }\n\n      /**\n       * writeString - write a utf8 string to the buffer\n       *\n       * @param <Buffer> buffer - destination\n       * @param <Number> pos - offset\n       * @param <String> string - string to write\n       * @return <Number> number of bytes written\n       *\n       * @api private\n       */\n\n      function writeString(stream, string) {\n        var strlen = Buffer.byteLength(string);\n        writeNumber(stream, strlen);\n        stream.write(string, 'utf8');\n      }\n\n      /**\n       * writeStringPair - write a utf8 string pairs to the buffer\n       *\n       * @param <Buffer> buffer - destination\n       * @param <String> name - string name to write\n       * @param <String> value - string value to write\n       * @return <Number> number of bytes written\n       *\n       * @api private\n       */\n      function writeStringPair(stream, name, value) {\n        writeString(stream, name);\n        writeString(stream, value);\n      }\n\n      /**\n       * writeNumber - write a two byte number to the buffer\n       *\n       * @param <Buffer> buffer - destination\n       * @param <Number> pos - offset\n       * @param <String> number - number to write\n       * @return <Number> number of bytes written\n       *\n       * @api private\n       */\n      function writeNumberCached(stream, number) {\n        return stream.write(numCache[number]);\n      }\n      function writeNumberGenerated(stream, number) {\n        return stream.write(generateNumber(number));\n      }\n      function write4ByteNumber(stream, number) {\n        return stream.write(generate4ByteBuffer(number));\n      }\n      /**\n       * writeStringOrBuffer - write a String or Buffer with the its length prefix\n       *\n       * @param <Buffer> buffer - destination\n       * @param <Number> pos - offset\n       * @param <String> toWrite - String or Buffer\n       * @return <Number> number of bytes written\n       */\n      function writeStringOrBuffer(stream, toWrite) {\n        if (typeof toWrite === 'string') {\n          writeString(stream, toWrite);\n        } else if (toWrite) {\n          writeNumber(stream, toWrite.length);\n          stream.write(toWrite);\n        } else writeNumber(stream, 0);\n      }\n      function getProperties(stream, properties) {\n        /* connect properties */\n        if (_typeof(properties) !== 'object' || properties.length != null) {\n          return {\n            length: 1,\n            write: function write() {\n              writeProperties(stream, {}, 0);\n            }\n          };\n        }\n        var propertiesLength = 0;\n        function getLengthProperty(name) {\n          var type = protocol.propertiesTypes[name];\n          var value = properties[name];\n          var length = 0;\n          switch (type) {\n            case 'byte':\n              {\n                if (typeof value !== 'boolean') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 1;\n                break;\n              }\n            case 'int8':\n              {\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 1;\n                break;\n              }\n            case 'binary':\n              {\n                if (value && value === null) {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + Buffer.byteLength(value) + 2;\n                break;\n              }\n            case 'int16':\n              {\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 2;\n                break;\n              }\n            case 'int32':\n              {\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 4;\n                break;\n              }\n            case 'var':\n              {\n                if (typeof value !== 'number') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + genBufVariableByteInt(value).length;\n                break;\n              }\n            case 'string':\n              {\n                if (typeof value !== 'string') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += 1 + 2 + Buffer.byteLength(value.toString());\n                break;\n              }\n            case 'pair':\n              {\n                if (_typeof(value) !== 'object') {\n                  stream.emit('error', new Error('Invalid ' + name));\n                  return false;\n                }\n                length += Object.getOwnPropertyNames(value).reduce(function (result, name) {\n                  result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString());\n                  return result;\n                }, 0);\n                break;\n              }\n            default:\n              {\n                stream.emit('error', new Error('Invalid property ' + name));\n                return false;\n              }\n          }\n          return length;\n        }\n        if (properties) {\n          for (var propName in properties) {\n            var propLength = getLengthProperty(propName);\n            if (!propLength) return false;\n            propertiesLength += propLength;\n          }\n        }\n        var propertiesLengthLength = genBufVariableByteInt(propertiesLength).length;\n        return {\n          length: propertiesLengthLength + propertiesLength,\n          write: function write() {\n            writeProperties(stream, properties, propertiesLength);\n          }\n        };\n      }\n      function getPropertiesByMaximumPacketSize(stream, properties, opts, length) {\n        var mayEmptyProps = ['reasonString', 'userProperties'];\n        var maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;\n        var propertiesData = getProperties(stream, properties);\n        if (maximumPacketSize) {\n          while (length + propertiesData.length > maximumPacketSize) {\n            var currentMayEmptyProp = mayEmptyProps.shift();\n            if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n              delete properties[currentMayEmptyProp];\n              propertiesData = getProperties(stream, properties);\n            } else {\n              return false;\n            }\n          }\n        }\n        return propertiesData;\n      }\n      function writeProperties(stream, properties, propertiesLength) {\n        /* write properties to stream */\n        writeVarByteInt(stream, propertiesLength);\n        for (var propName in properties) {\n          if (properties.hasOwnProperty(propName) && properties[propName] !== null) {\n            var value = properties[propName];\n            var type = protocol.propertiesTypes[propName];\n            switch (type) {\n              case 'byte':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([+value]));\n                  break;\n                }\n              case 'int8':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  stream.write(Buffer.from([value]));\n                  break;\n                }\n              case 'binary':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeStringOrBuffer(stream, value);\n                  break;\n                }\n              case 'int16':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeNumber(stream, value);\n                  break;\n                }\n              case 'int32':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  write4ByteNumber(stream, value);\n                  break;\n                }\n              case 'var':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeVarByteInt(stream, value);\n                  break;\n                }\n              case 'string':\n                {\n                  stream.write(Buffer.from([protocol.properties[propName]]));\n                  writeString(stream, value);\n                  break;\n                }\n              case 'pair':\n                {\n                  Object.getOwnPropertyNames(value).forEach(function (name) {\n                    stream.write(Buffer.from([protocol.properties[propName]]));\n                    writeStringPair(stream, name.toString(), value[name].toString());\n                  });\n                  break;\n                }\n              default:\n                {\n                  stream.emit('error', new Error('Invalid property ' + propName));\n                  return false;\n                }\n            }\n          }\n        }\n      }\n      function byteLength(bufOrString) {\n        if (!bufOrString) return 0;else if (bufOrString instanceof Buffer) return bufOrString.length;else return Buffer.byteLength(bufOrString);\n      }\n      function isStringOrBuffer(field) {\n        return typeof field === 'string' || field instanceof Buffer;\n      }\n      module.exports = generate;\n    }, {\n      \"./constants\": 90,\n      \"./numbers\": 94,\n      \"process-nextick-args\": 99,\n      \"safe-buffer\": 118\n    }],\n    98: [function (require, module, exports) {\n      var wrappy = require('wrappy');\n      module.exports = wrappy(once);\n      module.exports.strict = wrappy(onceStrict);\n      once.proto = once(function () {\n        Object.defineProperty(Function.prototype, 'once', {\n          value: function value() {\n            return once(this);\n          },\n          configurable: true\n        });\n        Object.defineProperty(Function.prototype, 'onceStrict', {\n          value: function value() {\n            return onceStrict(this);\n          },\n          configurable: true\n        });\n      });\n      function once(fn) {\n        var f = function f() {\n          if (f.called) return f.value;\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n        f.called = false;\n        return f;\n      }\n      function onceStrict(fn) {\n        var f = function f() {\n          if (f.called) throw new Error(f.onceError);\n          f.called = true;\n          return f.value = fn.apply(this, arguments);\n        };\n        var name = fn.name || 'Function wrapped with `once`';\n        f.onceError = name + \" shouldn't be called more than once\";\n        f.called = false;\n        return f;\n      }\n    }, {\n      \"wrappy\": 139\n    }],\n    99: [function (require, module, exports) {\n      (function (process) {\n        'use strict';\n\n        if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n          module.exports = {\n            nextTick: nextTick\n          };\n        } else {\n          module.exports = process;\n        }\n        function nextTick(fn, arg1, arg2, arg3) {\n          if (typeof fn !== 'function') {\n            throw new TypeError('\"callback\" argument must be a function');\n          }\n          var len = arguments.length;\n          var args, i;\n          switch (len) {\n            case 0:\n            case 1:\n              return process.nextTick(fn);\n            case 2:\n              return process.nextTick(function afterTickOne() {\n                fn.call(null, arg1);\n              });\n            case 3:\n              return process.nextTick(function afterTickTwo() {\n                fn.call(null, arg1, arg2);\n              });\n            case 4:\n              return process.nextTick(function afterTickThree() {\n                fn.call(null, arg1, arg2, arg3);\n              });\n            default:\n              args = new Array(len - 1);\n              i = 0;\n              while (i < args.length) {\n                args[i++] = arguments[i];\n              }\n              return process.nextTick(function afterTick() {\n                fn.apply(null, args);\n              });\n          }\n        }\n      }).call(this, require('_process'));\n    }, {\n      \"_process\": 100\n    }],\n    100: [function (require, module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {};\n\n      // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        }\n        // if setTimeout wasn't available but was latter defined\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        }\n        // if clearTimeout wasn't available but was latter defined\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n        draining = false;\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n          queueIndex = -1;\n          len = queue.length;\n        }\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n        queue.push(new Item(fun, args));\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      };\n\n      // v8 likes predictible objects\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n      process.versions = {};\n      function noop() {}\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n      process.listeners = function (name) {\n        return [];\n      };\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n      process.cwd = function () {\n        return '/';\n      };\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n      process.umask = function () {\n        return 0;\n      };\n    }, {}],\n    101: [function (require, module, exports) {\n      (function (global) {\n        /*! https://mths.be/punycode v1.4.1 by @mathias */\n        ;\n        (function (root) {\n          /** Detect free variables */\n          var freeExports = _typeof(exports) == 'object' && exports && !exports.nodeType && exports;\n          var freeModule = _typeof(module) == 'object' && module && !module.nodeType && module;\n          var freeGlobal = _typeof(global) == 'object' && global;\n          if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n            root = freeGlobal;\n          }\n\n          /**\n           * The `punycode` object.\n           * @name punycode\n           * @type Object\n           */\n          var punycode,\n            /** Highest positive signed 32-bit float value */\n            maxInt = 2147483647,\n            // aka. 0x7FFFFFFF or 2^31-1\n\n            /** Bootstring parameters */\n            base = 36,\n            tMin = 1,\n            tMax = 26,\n            skew = 38,\n            damp = 700,\n            initialBias = 72,\n            initialN = 128,\n            // 0x80\n            delimiter = '-',\n            // '\\x2D'\n\n            /** Regular expressions */\n            regexPunycode = /^xn--/,\n            regexNonASCII = /[^\\x20-\\x7E]/,\n            // unprintable ASCII chars + non-ASCII chars\n            regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n            // RFC 3490 separators\n\n            /** Error messages */\n            errors = {\n              'overflow': 'Overflow: input needs wider integers to process',\n              'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n              'invalid-input': 'Invalid input'\n            },\n            /** Convenience shortcuts */\n            baseMinusTMin = base - tMin,\n            floor = Math.floor,\n            stringFromCharCode = String.fromCharCode,\n            /** Temporary variable */\n            key;\n\n          /*--------------------------------------------------------------------------*/\n\n          /**\n           * A generic error utility function.\n           * @private\n           * @param {String} type The error type.\n           * @returns {Error} Throws a `RangeError` with the applicable error message.\n           */\n          function error(type) {\n            throw new RangeError(errors[type]);\n          }\n\n          /**\n           * A generic `Array#map` utility function.\n           * @private\n           * @param {Array} array The array to iterate over.\n           * @param {Function} callback The function that gets called for every array\n           * item.\n           * @returns {Array} A new array of values returned by the callback function.\n           */\n          function map(array, fn) {\n            var length = array.length;\n            var result = [];\n            while (length--) {\n              result[length] = fn(array[length]);\n            }\n            return result;\n          }\n\n          /**\n           * A simple `Array#map`-like wrapper to work with domain name strings or email\n           * addresses.\n           * @private\n           * @param {String} domain The domain name or email address.\n           * @param {Function} callback The function that gets called for every\n           * character.\n           * @returns {Array} A new string of characters returned by the callback\n           * function.\n           */\n          function mapDomain(string, fn) {\n            var parts = string.split('@');\n            var result = '';\n            if (parts.length > 1) {\n              // In email addresses, only the domain name should be punycoded. Leave\n              // the local part (i.e. everything up to `@`) intact.\n              result = parts[0] + '@';\n              string = parts[1];\n            }\n            // Avoid `split(regex)` for IE8 compatibility. See #17.\n            string = string.replace(regexSeparators, '\\x2E');\n            var labels = string.split('.');\n            var encoded = map(labels, fn).join('.');\n            return result + encoded;\n          }\n\n          /**\n           * Creates an array containing the numeric code points of each Unicode\n           * character in the string. While JavaScript uses UCS-2 internally,\n           * this function will convert a pair of surrogate halves (each of which\n           * UCS-2 exposes as separate characters) into a single code point,\n           * matching UTF-16.\n           * @see `punycode.ucs2.encode`\n           * @see <https://mathiasbynens.be/notes/javascript-encoding>\n           * @memberOf punycode.ucs2\n           * @name decode\n           * @param {String} string The Unicode input string (UCS-2).\n           * @returns {Array} The new array of code points.\n           */\n          function ucs2decode(string) {\n            var output = [],\n              counter = 0,\n              length = string.length,\n              value,\n              extra;\n            while (counter < length) {\n              value = string.charCodeAt(counter++);\n              if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                // high surrogate, and there is a next character\n                extra = string.charCodeAt(counter++);\n                if ((extra & 0xFC00) == 0xDC00) {\n                  // low surrogate\n                  output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                } else {\n                  // unmatched surrogate; only append this code unit, in case the next\n                  // code unit is the high surrogate of a surrogate pair\n                  output.push(value);\n                  counter--;\n                }\n              } else {\n                output.push(value);\n              }\n            }\n            return output;\n          }\n\n          /**\n           * Creates a string based on an array of numeric code points.\n           * @see `punycode.ucs2.decode`\n           * @memberOf punycode.ucs2\n           * @name encode\n           * @param {Array} codePoints The array of numeric code points.\n           * @returns {String} The new Unicode string (UCS-2).\n           */\n          function ucs2encode(array) {\n            return map(array, function (value) {\n              var output = '';\n              if (value > 0xFFFF) {\n                value -= 0x10000;\n                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                value = 0xDC00 | value & 0x3FF;\n              }\n              output += stringFromCharCode(value);\n              return output;\n            }).join('');\n          }\n\n          /**\n           * Converts a basic code point into a digit/integer.\n           * @see `digitToBasic()`\n           * @private\n           * @param {Number} codePoint The basic numeric code point value.\n           * @returns {Number} The numeric value of a basic code point (for use in\n           * representing integers) in the range `0` to `base - 1`, or `base` if\n           * the code point does not represent a value.\n           */\n          function basicToDigit(codePoint) {\n            if (codePoint - 48 < 10) {\n              return codePoint - 22;\n            }\n            if (codePoint - 65 < 26) {\n              return codePoint - 65;\n            }\n            if (codePoint - 97 < 26) {\n              return codePoint - 97;\n            }\n            return base;\n          }\n\n          /**\n           * Converts a digit/integer into a basic code point.\n           * @see `basicToDigit()`\n           * @private\n           * @param {Number} digit The numeric value of a basic code point.\n           * @returns {Number} The basic code point whose value (when used for\n           * representing integers) is `digit`, which needs to be in the range\n           * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n           * used; else, the lowercase form is used. The behavior is undefined\n           * if `flag` is non-zero and `digit` has no uppercase form.\n           */\n          function digitToBasic(digit, flag) {\n            //  0..25 map to ASCII a..z or A..Z\n            // 26..35 map to ASCII 0..9\n            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n          }\n\n          /**\n           * Bias adaptation function as per section 3.4 of RFC 3492.\n           * https://tools.ietf.org/html/rfc3492#section-3.4\n           * @private\n           */\n          function adapt(delta, numPoints, firstTime) {\n            var k = 0;\n            delta = firstTime ? floor(delta / damp) : delta >> 1;\n            delta += floor(delta / numPoints);\n            for /* no initialization */\n            (; delta > baseMinusTMin * tMax >> 1; k += base) {\n              delta = floor(delta / baseMinusTMin);\n            }\n            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n          }\n\n          /**\n           * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n           * symbols.\n           * @memberOf punycode\n           * @param {String} input The Punycode string of ASCII-only symbols.\n           * @returns {String} The resulting string of Unicode symbols.\n           */\n          function decode(input) {\n            // Don't use UCS-2\n            var output = [],\n              inputLength = input.length,\n              out,\n              i = 0,\n              n = initialN,\n              bias = initialBias,\n              basic,\n              j,\n              index,\n              oldi,\n              w,\n              k,\n              digit,\n              t,\n              /** Cached calculation results */\n              baseMinusT;\n\n            // Handle the basic code points: let `basic` be the number of input code\n            // points before the last delimiter, or `0` if there is none, then copy\n            // the first basic code points to the output.\n\n            basic = input.lastIndexOf(delimiter);\n            if (basic < 0) {\n              basic = 0;\n            }\n            for (j = 0; j < basic; ++j) {\n              // if it's not a basic code point\n              if (input.charCodeAt(j) >= 0x80) {\n                error('not-basic');\n              }\n              output.push(input.charCodeAt(j));\n            }\n\n            // Main decoding loop: start just after the last delimiter if any basic code\n            // points were copied; start at the beginning otherwise.\n\n            for /* no final expression */\n            (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {\n              // `index` is the index of the next character to be consumed.\n              // Decode a generalized variable-length integer into `delta`,\n              // which gets added to `i`. The overflow checking is easier\n              // if we increase `i` as we go, then subtract off its starting\n              // value at the end to obtain `delta`.\n              for /* no condition */\n              (oldi = i, w = 1, k = base;; k += base) {\n                if (index >= inputLength) {\n                  error('invalid-input');\n                }\n                digit = basicToDigit(input.charCodeAt(index++));\n                if (digit >= base || digit > floor((maxInt - i) / w)) {\n                  error('overflow');\n                }\n                i += digit * w;\n                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (digit < t) {\n                  break;\n                }\n                baseMinusT = base - t;\n                if (w > floor(maxInt / baseMinusT)) {\n                  error('overflow');\n                }\n                w *= baseMinusT;\n              }\n              out = output.length + 1;\n              bias = adapt(i - oldi, out, oldi == 0);\n\n              // `i` was supposed to wrap around from `out` to `0`,\n              // incrementing `n` each time, so we'll fix that now:\n              if (floor(i / out) > maxInt - n) {\n                error('overflow');\n              }\n              n += floor(i / out);\n              i %= out;\n\n              // Insert `n` at position `i` of the output\n              output.splice(i++, 0, n);\n            }\n            return ucs2encode(output);\n          }\n\n          /**\n           * Converts a string of Unicode symbols (e.g. a domain name label) to a\n           * Punycode string of ASCII-only symbols.\n           * @memberOf punycode\n           * @param {String} input The string of Unicode symbols.\n           * @returns {String} The resulting Punycode string of ASCII-only symbols.\n           */\n          function encode(input) {\n            var n,\n              delta,\n              handledCPCount,\n              basicLength,\n              bias,\n              j,\n              m,\n              q,\n              k,\n              t,\n              currentValue,\n              output = [],\n              /** `inputLength` will hold the number of code points in `input`. */\n              inputLength,\n              /** Cached calculation results */\n              handledCPCountPlusOne,\n              baseMinusT,\n              qMinusT;\n\n            // Convert the input in UCS-2 to Unicode\n            input = ucs2decode(input);\n\n            // Cache the length\n            inputLength = input.length;\n\n            // Initialize the state\n            n = initialN;\n            delta = 0;\n            bias = initialBias;\n\n            // Handle the basic code points\n            for (j = 0; j < inputLength; ++j) {\n              currentValue = input[j];\n              if (currentValue < 0x80) {\n                output.push(stringFromCharCode(currentValue));\n              }\n            }\n            handledCPCount = basicLength = output.length;\n\n            // `handledCPCount` is the number of code points that have been handled;\n            // `basicLength` is the number of basic code points.\n\n            // Finish the basic string - if it is not empty - with a delimiter\n            if (basicLength) {\n              output.push(delimiter);\n            }\n\n            // Main encoding loop:\n            while (handledCPCount < inputLength) {\n              // All non-basic code points < n have been handled already. Find the next\n              // larger one:\n              for (m = maxInt, j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n                if (currentValue >= n && currentValue < m) {\n                  m = currentValue;\n                }\n              }\n\n              // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n              // but guard against overflow\n              handledCPCountPlusOne = handledCPCount + 1;\n              if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                error('overflow');\n              }\n              delta += (m - n) * handledCPCountPlusOne;\n              n = m;\n              for (j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n                if (currentValue < n && ++delta > maxInt) {\n                  error('overflow');\n                }\n                if (currentValue == n) {\n                  // Represent delta as a generalized variable-length integer\n                  for /* no condition */\n                  (q = delta, k = base;; k += base) {\n                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                    if (q < t) {\n                      break;\n                    }\n                    qMinusT = q - t;\n                    baseMinusT = base - t;\n                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                    q = floor(qMinusT / baseMinusT);\n                  }\n                  output.push(stringFromCharCode(digitToBasic(q, 0)));\n                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                  delta = 0;\n                  ++handledCPCount;\n                }\n              }\n              ++delta;\n              ++n;\n            }\n            return output.join('');\n          }\n\n          /**\n           * Converts a Punycode string representing a domain name or an email address\n           * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n           * it doesn't matter if you call it on a string that has already been\n           * converted to Unicode.\n           * @memberOf punycode\n           * @param {String} input The Punycoded domain name or email address to\n           * convert to Unicode.\n           * @returns {String} The Unicode representation of the given Punycode\n           * string.\n           */\n          function toUnicode(input) {\n            return mapDomain(input, function (string) {\n              return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n            });\n          }\n\n          /**\n           * Converts a Unicode string representing a domain name or an email address to\n           * Punycode. Only the non-ASCII parts of the domain name will be converted,\n           * i.e. it doesn't matter if you call it with a domain that's already in\n           * ASCII.\n           * @memberOf punycode\n           * @param {String} input The domain name or email address to convert, as a\n           * Unicode string.\n           * @returns {String} The Punycode representation of the given domain name or\n           * email address.\n           */\n          function toASCII(input) {\n            return mapDomain(input, function (string) {\n              return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n            });\n          }\n\n          /*--------------------------------------------------------------------------*/\n\n          /** Define the public API */\n          punycode = {\n            /**\n             * A string representing the current Punycode.js version number.\n             * @memberOf punycode\n             * @type String\n             */\n            'version': '1.4.1',\n            /**\n             * An object of methods to convert from JavaScript's internal character\n             * representation (UCS-2) to Unicode code points, and back.\n             * @see <https://mathiasbynens.be/notes/javascript-encoding>\n             * @memberOf punycode\n             * @type Object\n             */\n            'ucs2': {\n              'decode': ucs2decode,\n              'encode': ucs2encode\n            },\n            'decode': decode,\n            'encode': encode,\n            'toASCII': toASCII,\n            'toUnicode': toUnicode\n          };\n\n          /** Expose `punycode` */\n          // Some AMD build optimizers, like r.js, check for specific condition patterns\n          // like the following:\n          if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {\n            define('punycode', function () {\n              return punycode;\n            });\n          } else if (freeExports && freeModule) {\n            if (module.exports == freeExports) {\n              // in Node.js, io.js, or RingoJS v0.8.0+\n              freeModule.exports = punycode;\n            } else {\n              // in Narwhal or RingoJS v0.7.0-\n              for (key in punycode) {\n                punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n              }\n            }\n          } else {\n            // in Rhino or a web browser\n            root.punycode = punycode;\n          }\n        })(this);\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    102: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      // If obj.hasOwnProperty has been overridden, then calling\n      // obj.hasOwnProperty(prop) will break.\n      // See: https://github.com/joyent/node/issues/1707\n      function hasOwnProperty(obj, prop) {\n        return Object.prototype.hasOwnProperty.call(obj, prop);\n      }\n      module.exports = function (qs, sep, eq, options) {\n        sep = sep || '&';\n        eq = eq || '=';\n        var obj = {};\n        if (typeof qs !== 'string' || qs.length === 0) {\n          return obj;\n        }\n        var regexp = /\\+/g;\n        qs = qs.split(sep);\n        var maxKeys = 1000;\n        if (options && typeof options.maxKeys === 'number') {\n          maxKeys = options.maxKeys;\n        }\n        var len = qs.length;\n        // maxKeys <= 0 means that we should not limit keys count\n        if (maxKeys > 0 && len > maxKeys) {\n          len = maxKeys;\n        }\n        for (var i = 0; i < len; ++i) {\n          var x = qs[i].replace(regexp, '%20'),\n            idx = x.indexOf(eq),\n            kstr,\n            vstr,\n            k,\n            v;\n          if (idx >= 0) {\n            kstr = x.substr(0, idx);\n            vstr = x.substr(idx + 1);\n          } else {\n            kstr = x;\n            vstr = '';\n          }\n          k = decodeURIComponent(kstr);\n          v = decodeURIComponent(vstr);\n          if (!hasOwnProperty(obj, k)) {\n            obj[k] = v;\n          } else if (isArray(obj[k])) {\n            obj[k].push(v);\n          } else {\n            obj[k] = [obj[k], v];\n          }\n        }\n        return obj;\n      };\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n    }, {}],\n    103: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      var stringifyPrimitive = function stringifyPrimitive(v) {\n        switch (_typeof(v)) {\n          case 'string':\n            return v;\n          case 'boolean':\n            return v ? 'true' : 'false';\n          case 'number':\n            return isFinite(v) ? v : '';\n          default:\n            return '';\n        }\n      };\n      module.exports = function (obj, sep, eq, name) {\n        sep = sep || '&';\n        eq = eq || '=';\n        if (obj === null) {\n          obj = undefined;\n        }\n        if (_typeof(obj) === 'object') {\n          return map(objectKeys(obj), function (k) {\n            var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n            if (isArray(obj[k])) {\n              return map(obj[k], function (v) {\n                return ks + encodeURIComponent(stringifyPrimitive(v));\n              }).join(sep);\n            } else {\n              return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n            }\n          }).join(sep);\n        }\n        if (!name) return '';\n        return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n      };\n      var isArray = Array.isArray || function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]';\n      };\n      function map(xs, f) {\n        if (xs.map) return xs.map(f);\n        var res = [];\n        for (var i = 0; i < xs.length; i++) {\n          res.push(f(xs[i], i));\n        }\n        return res;\n      }\n      var objectKeys = Object.keys || function (obj) {\n        var res = [];\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n        }\n        return res;\n      };\n    }, {}],\n    104: [function (require, module, exports) {\n      'use strict';\n\n      exports.decode = exports.parse = require('./decode');\n      exports.encode = exports.stringify = require('./encode');\n    }, {\n      \"./decode\": 102,\n      \"./encode\": 103\n    }],\n    105: [function (require, module, exports) {\n      module.exports = require('./lib/_stream_duplex.js');\n    }, {\n      \"./lib/_stream_duplex.js\": 106\n    }],\n    106: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      // a duplex stream is just a stream that is both readable and writable.\n      // Since JS doesn't have multiple prototypal inheritance, this class\n      // prototypally inherits from Readable, and then parasitically from\n      // Writable.\n\n      'use strict';\n\n      /*<replacement>*/\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n      /*<replacement>*/\n      var objectKeys = Object.keys || function (obj) {\n        var keys = [];\n        for (var key in obj) {\n          keys.push(key);\n        }\n        return keys;\n      };\n      /*</replacement>*/\n\n      module.exports = Duplex;\n\n      /*<replacement>*/\n      var util = require('core-util-is');\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      var Readable = require('./_stream_readable');\n      var Writable = require('./_stream_writable');\n      util.inherits(Duplex, Readable);\n      {\n        // avoid scope creep, the keys array can then be collected\n        var keys = objectKeys(Writable.prototype);\n        for (var v = 0; v < keys.length; v++) {\n          var method = keys[v];\n          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n        }\n      }\n      function Duplex(options) {\n        if (!(this instanceof Duplex)) return new Duplex(options);\n        Readable.call(this, options);\n        Writable.call(this, options);\n        if (options && options.readable === false) this.readable = false;\n        if (options && options.writable === false) this.writable = false;\n        this.allowHalfOpen = true;\n        if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n        this.once('end', onend);\n      }\n      Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n        // making it explicit this property is not enumerable\n        // because otherwise some prototype manipulation in\n        // userland will fail\n        enumerable: false,\n        get: function get() {\n          return this._writableState.highWaterMark;\n        }\n      });\n\n      // the no-half-open enforcer\n      function onend() {\n        // if we allow half-open state, or if the writable side ended,\n        // then we're ok.\n        if (this.allowHalfOpen || this._writableState.ended) return;\n\n        // no more data can be written.\n        // But allow more writes to happen in this tick.\n        pna.nextTick(onEndNT, this);\n      }\n      function onEndNT(self) {\n        self.end();\n      }\n      Object.defineProperty(Duplex.prototype, 'destroyed', {\n        get: function get() {\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return false;\n          }\n          return this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set: function set(value) {\n          // we ignore the value if the stream\n          // has not been initialized yet\n          if (this._readableState === undefined || this._writableState === undefined) {\n            return;\n          }\n\n          // backward compatibility, the user is explicitly\n          // managing destroyed\n          this._readableState.destroyed = value;\n          this._writableState.destroyed = value;\n        }\n      });\n      Duplex.prototype._destroy = function (err, cb) {\n        this.push(null);\n        this.end();\n        pna.nextTick(cb, err);\n      };\n    }, {\n      \"./_stream_readable\": 108,\n      \"./_stream_writable\": 110,\n      \"core-util-is\": 13,\n      \"inherits\": 88,\n      \"process-nextick-args\": 99\n    }],\n    107: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      // a passthrough stream.\n      // basically just the most minimal sort of Transform stream.\n      // Every written chunk gets output as-is.\n\n      'use strict';\n\n      module.exports = PassThrough;\n      var Transform = require('./_stream_transform');\n\n      /*<replacement>*/\n      var util = require('core-util-is');\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(PassThrough, Transform);\n      function PassThrough(options) {\n        if (!(this instanceof PassThrough)) return new PassThrough(options);\n        Transform.call(this, options);\n      }\n      PassThrough.prototype._transform = function (chunk, encoding, cb) {\n        cb(null, chunk);\n      };\n    }, {\n      \"./_stream_transform\": 109,\n      \"core-util-is\": 13,\n      \"inherits\": 88\n    }],\n    108: [function (require, module, exports) {\n      (function (process, global) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        'use strict';\n\n        /*<replacement>*/\n        var pna = require('process-nextick-args');\n        /*</replacement>*/\n\n        module.exports = Readable;\n\n        /*<replacement>*/\n        var isArray = require('isarray');\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Duplex;\n        /*</replacement>*/\n\n        Readable.ReadableState = ReadableState;\n\n        /*<replacement>*/\n        var EE = require('events').EventEmitter;\n        var EElistenerCount = function EElistenerCount(emitter, type) {\n          return emitter.listeners(type).length;\n        };\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Stream = require('./internal/streams/stream');\n        /*</replacement>*/\n\n        /*<replacement>*/\n\n        var Buffer = require('safe-buffer').Buffer;\n        var OurUint8Array = global.Uint8Array || function () {};\n        function _uint8ArrayToBuffer(chunk) {\n          return Buffer.from(chunk);\n        }\n        function _isUint8Array(obj) {\n          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n        }\n\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var util = require('core-util-is');\n        util.inherits = require('inherits');\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var debugUtil = require('util');\n        var debug = void 0;\n        if (debugUtil && debugUtil.debuglog) {\n          debug = debugUtil.debuglog('stream');\n        } else {\n          debug = function debug() {};\n        }\n        /*</replacement>*/\n\n        var BufferList = require('./internal/streams/BufferList');\n        var destroyImpl = require('./internal/streams/destroy');\n        var StringDecoder;\n        util.inherits(Readable, Stream);\n        var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n        function prependListener(emitter, event, fn) {\n          // Sadly this is not cacheable as some libraries bundle their own\n          // event emitter implementation with them.\n          if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n          // This is a hack to make sure that our error handler is attached before any\n          // userland ones.  NEVER DO THIS. This is here only because this code needs\n          // to continue to work with older versions of Node.js that do not include\n          // the prependListener() method. The goal is to eventually remove this hack.\n          if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n        }\n        function ReadableState(options, stream) {\n          Duplex = Duplex || require('./_stream_duplex');\n          options = options || {};\n\n          // Duplex streams are both readable and writable, but share\n          // the same options object.\n          // However, some cases require setting options to different\n          // values for the readable and the writable sides of the duplex stream.\n          // These options can be provided separately as readableXXX and writableXXX.\n          var isDuplex = stream instanceof Duplex;\n\n          // object stream flag. Used to make read(n) ignore n and to\n          // make all the buffer merging and length checks go away\n          this.objectMode = !!options.objectMode;\n          if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n          // the point at which it stops calling _read() to fill the buffer\n          // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n          var hwm = options.highWaterMark;\n          var readableHwm = options.readableHighWaterMark;\n          var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n          if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n          // cast to ints.\n          this.highWaterMark = Math.floor(this.highWaterMark);\n\n          // A linked list is used to store data chunks instead of an array because the\n          // linked list can remove elements from the beginning faster than\n          // array.shift()\n          this.buffer = new BufferList();\n          this.length = 0;\n          this.pipes = null;\n          this.pipesCount = 0;\n          this.flowing = null;\n          this.ended = false;\n          this.endEmitted = false;\n          this.reading = false;\n\n          // a flag to be able to tell if the event 'readable'/'data' is emitted\n          // immediately, or on a later tick.  We set this to true at first, because\n          // any actions that shouldn't happen until \"later\" should generally also\n          // not happen before the first read call.\n          this.sync = true;\n\n          // whenever we return null, then we set a flag to say\n          // that we're awaiting a 'readable' event emission.\n          this.needReadable = false;\n          this.emittedReadable = false;\n          this.readableListening = false;\n          this.resumeScheduled = false;\n\n          // has it been destroyed\n          this.destroyed = false;\n\n          // Crypto is kind of old and crusty.  Historically, its default string\n          // encoding is 'binary' so we have to make this configurable.\n          // Everything else in the universe uses 'utf8', though.\n          this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n          // the number of writers that are awaiting a drain event in .pipe()s\n          this.awaitDrain = 0;\n\n          // if true, a maybeReadMore has been scheduled\n          this.readingMore = false;\n          this.decoder = null;\n          this.encoding = null;\n          if (options.encoding) {\n            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n            this.decoder = new StringDecoder(options.encoding);\n            this.encoding = options.encoding;\n          }\n        }\n        function Readable(options) {\n          Duplex = Duplex || require('./_stream_duplex');\n          if (!(this instanceof Readable)) return new Readable(options);\n          this._readableState = new ReadableState(options, this);\n\n          // legacy\n          this.readable = true;\n          if (options) {\n            if (typeof options.read === 'function') this._read = options.read;\n            if (typeof options.destroy === 'function') this._destroy = options.destroy;\n          }\n          Stream.call(this);\n        }\n        Object.defineProperty(Readable.prototype, 'destroyed', {\n          get: function get() {\n            if (this._readableState === undefined) {\n              return false;\n            }\n            return this._readableState.destroyed;\n          },\n          set: function set(value) {\n            // we ignore the value if the stream\n            // has not been initialized yet\n            if (!this._readableState) {\n              return;\n            }\n\n            // backward compatibility, the user is explicitly\n            // managing destroyed\n            this._readableState.destroyed = value;\n          }\n        });\n        Readable.prototype.destroy = destroyImpl.destroy;\n        Readable.prototype._undestroy = destroyImpl.undestroy;\n        Readable.prototype._destroy = function (err, cb) {\n          this.push(null);\n          cb(err);\n        };\n\n        // Manually shove something into the read() buffer.\n        // This returns true if the highWaterMark has not been hit yet,\n        // similar to how Writable.write() returns true if you should\n        // write() some more.\n        Readable.prototype.push = function (chunk, encoding) {\n          var state = this._readableState;\n          var skipChunkCheck;\n          if (!state.objectMode) {\n            if (typeof chunk === 'string') {\n              encoding = encoding || state.defaultEncoding;\n              if (encoding !== state.encoding) {\n                chunk = Buffer.from(chunk, encoding);\n                encoding = '';\n              }\n              skipChunkCheck = true;\n            }\n          } else {\n            skipChunkCheck = true;\n          }\n          return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n        };\n\n        // Unshift should *always* be something directly out of read()\n        Readable.prototype.unshift = function (chunk) {\n          return readableAddChunk(this, chunk, null, true, false);\n        };\n        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n          var state = stream._readableState;\n          if (chunk === null) {\n            state.reading = false;\n            onEofChunk(stream, state);\n          } else {\n            var er;\n            if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n            if (er) {\n              stream.emit('error', er);\n            } else if (state.objectMode || chunk && chunk.length > 0) {\n              if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                chunk = _uint8ArrayToBuffer(chunk);\n              }\n              if (addToFront) {\n                if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n              } else if (state.ended) {\n                stream.emit('error', new Error('stream.push() after EOF'));\n              } else {\n                state.reading = false;\n                if (state.decoder && !encoding) {\n                  chunk = state.decoder.write(chunk);\n                  if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n                } else {\n                  addChunk(stream, state, chunk, false);\n                }\n              }\n            } else if (!addToFront) {\n              state.reading = false;\n            }\n          }\n          return needMoreData(state);\n        }\n        function addChunk(stream, state, chunk, addToFront) {\n          if (state.flowing && state.length === 0 && !state.sync) {\n            stream.emit('data', chunk);\n            stream.read(0);\n          } else {\n            // update the buffer info.\n            state.length += state.objectMode ? 1 : chunk.length;\n            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n            if (state.needReadable) emitReadable(stream);\n          }\n          maybeReadMore(stream, state);\n        }\n        function chunkInvalid(state, chunk) {\n          var er;\n          if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n            er = new TypeError('Invalid non-string/buffer chunk');\n          }\n          return er;\n        }\n\n        // if it's past the high water mark, we can push in some more.\n        // Also, if we have no data yet, we can stand some\n        // more bytes.  This is to work around cases where hwm=0,\n        // such as the repl.  Also, if the push() triggered a\n        // readable event, and the user called read(largeNumber) such that\n        // needReadable was set, then we ought to push more, so that another\n        // 'readable' event will be triggered.\n        function needMoreData(state) {\n          return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n        }\n        Readable.prototype.isPaused = function () {\n          return this._readableState.flowing === false;\n        };\n\n        // backwards compatibility.\n        Readable.prototype.setEncoding = function (enc) {\n          if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n          this._readableState.decoder = new StringDecoder(enc);\n          this._readableState.encoding = enc;\n          return this;\n        };\n\n        // Don't raise the hwm > 8MB\n        var MAX_HWM = 0x800000;\n        function computeNewHighWaterMark(n) {\n          if (n >= MAX_HWM) {\n            n = MAX_HWM;\n          } else {\n            // Get the next highest power of 2 to prevent increasing hwm excessively in\n            // tiny amounts\n            n--;\n            n |= n >>> 1;\n            n |= n >>> 2;\n            n |= n >>> 4;\n            n |= n >>> 8;\n            n |= n >>> 16;\n            n++;\n          }\n          return n;\n        }\n\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function howMuchToRead(n, state) {\n          if (n <= 0 || state.length === 0 && state.ended) return 0;\n          if (state.objectMode) return 1;\n          if (n !== n) {\n            // Only flow one buffer at a time\n            if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n          }\n          // If we're asking for more than the current hwm, then raise the hwm.\n          if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n          if (n <= state.length) return n;\n          // Don't have enough\n          if (!state.ended) {\n            state.needReadable = true;\n            return 0;\n          }\n          return state.length;\n        }\n\n        // you can override either this method, or the async _read(n) below.\n        Readable.prototype.read = function (n) {\n          debug('read', n);\n          n = parseInt(n, 10);\n          var state = this._readableState;\n          var nOrig = n;\n          if (n !== 0) state.emittedReadable = false;\n\n          // if we're doing read(0) to trigger a readable event, but we\n          // already have a bunch of data in the buffer, then just trigger\n          // the 'readable' event and move on.\n          if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n            debug('read: emitReadable', state.length, state.ended);\n            if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n            return null;\n          }\n          n = howMuchToRead(n, state);\n\n          // if we've ended, and we're now clear, then finish it up.\n          if (n === 0 && state.ended) {\n            if (state.length === 0) endReadable(this);\n            return null;\n          }\n\n          // All the actual chunk generation logic needs to be\n          // *below* the call to _read.  The reason is that in certain\n          // synthetic stream cases, such as passthrough streams, _read\n          // may be a completely synchronous operation which may change\n          // the state of the read buffer, providing enough data when\n          // before there was *not* enough.\n          //\n          // So, the steps are:\n          // 1. Figure out what the state of things will be after we do\n          // a read from the buffer.\n          //\n          // 2. If that resulting state will trigger a _read, then call _read.\n          // Note that this may be asynchronous, or synchronous.  Yes, it is\n          // deeply ugly to write APIs this way, but that still doesn't mean\n          // that the Readable class should behave improperly, as streams are\n          // designed to be sync/async agnostic.\n          // Take note if the _read call is sync or async (ie, if the read call\n          // has returned yet), so that we know whether or not it's safe to emit\n          // 'readable' etc.\n          //\n          // 3. Actually pull the requested chunks out of the buffer and return.\n\n          // if we need a readable event, then we need to do some reading.\n          var doRead = state.needReadable;\n          debug('need readable', doRead);\n\n          // if we currently have less than the highWaterMark, then also read some\n          if (state.length === 0 || state.length - n < state.highWaterMark) {\n            doRead = true;\n            debug('length less than watermark', doRead);\n          }\n\n          // however, if we've ended, then there's no point, and if we're already\n          // reading, then it's unnecessary.\n          if (state.ended || state.reading) {\n            doRead = false;\n            debug('reading or ended', doRead);\n          } else if (doRead) {\n            debug('do read');\n            state.reading = true;\n            state.sync = true;\n            // if the length is currently zero, then we *need* a readable event.\n            if (state.length === 0) state.needReadable = true;\n            // call internal read method\n            this._read(state.highWaterMark);\n            state.sync = false;\n            // If _read pushed data synchronously, then `reading` will be false,\n            // and we need to re-evaluate how much data we can return to the user.\n            if (!state.reading) n = howMuchToRead(nOrig, state);\n          }\n          var ret;\n          if (n > 0) ret = fromList(n, state);else ret = null;\n          if (ret === null) {\n            state.needReadable = true;\n            n = 0;\n          } else {\n            state.length -= n;\n          }\n          if (state.length === 0) {\n            // If we have nothing in the buffer, then we want to know\n            // as soon as we *do* get something into the buffer.\n            if (!state.ended) state.needReadable = true;\n\n            // If we tried to read() past the EOF, then emit end on the next tick.\n            if (nOrig !== n && state.ended) endReadable(this);\n          }\n          if (ret !== null) this.emit('data', ret);\n          return ret;\n        };\n        function onEofChunk(stream, state) {\n          if (state.ended) return;\n          if (state.decoder) {\n            var chunk = state.decoder.end();\n            if (chunk && chunk.length) {\n              state.buffer.push(chunk);\n              state.length += state.objectMode ? 1 : chunk.length;\n            }\n          }\n          state.ended = true;\n\n          // emit 'readable' now to make sure it gets picked up.\n          emitReadable(stream);\n        }\n\n        // Don't emit readable right away in sync mode, because this can trigger\n        // another read() call => stack overflow.  This way, it might trigger\n        // a nextTick recursion warning, but that's not so bad.\n        function emitReadable(stream) {\n          var state = stream._readableState;\n          state.needReadable = false;\n          if (!state.emittedReadable) {\n            debug('emitReadable', state.flowing);\n            state.emittedReadable = true;\n            if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n          }\n        }\n        function emitReadable_(stream) {\n          debug('emit readable');\n          stream.emit('readable');\n          flow(stream);\n        }\n\n        // at this point, the user has presumably seen the 'readable' event,\n        // and called read() to consume some data.  that may have triggered\n        // in turn another _read(n) call, in which case reading = true if\n        // it's in progress.\n        // However, if we're not ended, or reading, and the length < hwm,\n        // then go ahead and try to read some more preemptively.\n        function maybeReadMore(stream, state) {\n          if (!state.readingMore) {\n            state.readingMore = true;\n            pna.nextTick(maybeReadMore_, stream, state);\n          }\n        }\n        function maybeReadMore_(stream, state) {\n          var len = state.length;\n          while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n            debug('maybeReadMore read 0');\n            stream.read(0);\n            if (len === state.length)\n              // didn't get any data, stop spinning.\n              break;else len = state.length;\n          }\n          state.readingMore = false;\n        }\n\n        // abstract method.  to be overridden in specific implementation classes.\n        // call cb(er, data) where data is <= n in length.\n        // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n        // arbitrary, and perhaps not very meaningful.\n        Readable.prototype._read = function (n) {\n          this.emit('error', new Error('_read() is not implemented'));\n        };\n        Readable.prototype.pipe = function (dest, pipeOpts) {\n          var src = this;\n          var state = this._readableState;\n          switch (state.pipesCount) {\n            case 0:\n              state.pipes = dest;\n              break;\n            case 1:\n              state.pipes = [state.pipes, dest];\n              break;\n            default:\n              state.pipes.push(dest);\n              break;\n          }\n          state.pipesCount += 1;\n          debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n          var endFn = doEnd ? onend : unpipe;\n          if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n          dest.on('unpipe', onunpipe);\n          function onunpipe(readable, unpipeInfo) {\n            debug('onunpipe');\n            if (readable === src) {\n              if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                unpipeInfo.hasUnpiped = true;\n                cleanup();\n              }\n            }\n          }\n          function onend() {\n            debug('onend');\n            dest.end();\n          }\n\n          // when the dest drains, it reduces the awaitDrain counter\n          // on the source.  This would be more elegant with a .once()\n          // handler in flow(), but adding and removing repeatedly is\n          // too slow.\n          var ondrain = pipeOnDrain(src);\n          dest.on('drain', ondrain);\n          var cleanedUp = false;\n          function cleanup() {\n            debug('cleanup');\n            // cleanup event handlers once the pipe is broken\n            dest.removeListener('close', onclose);\n            dest.removeListener('finish', onfinish);\n            dest.removeListener('drain', ondrain);\n            dest.removeListener('error', onerror);\n            dest.removeListener('unpipe', onunpipe);\n            src.removeListener('end', onend);\n            src.removeListener('end', unpipe);\n            src.removeListener('data', ondata);\n            cleanedUp = true;\n\n            // if the reader is waiting for a drain event from this\n            // specific writer, then it would cause it to never start\n            // flowing again.\n            // So, if this is awaiting a drain, then we just call it now.\n            // If we don't know, then assume that we are waiting for one.\n            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n          }\n\n          // If the user pushes more data while we're writing to dest then we'll end up\n          // in ondata again. However, we only want to increase awaitDrain once because\n          // dest will only emit one 'drain' event for the multiple writes.\n          // => Introduce a guard on increasing awaitDrain.\n          var increasedAwaitDrain = false;\n          src.on('data', ondata);\n          function ondata(chunk) {\n            debug('ondata');\n            increasedAwaitDrain = false;\n            var ret = dest.write(chunk);\n            if (false === ret && !increasedAwaitDrain) {\n              // If the user unpiped during `dest.write()`, it is possible\n              // to get stuck in a permanently paused state if that write\n              // also returned false.\n              // => Check whether `dest` is still a piping destination.\n              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n                debug('false write response, pause', src._readableState.awaitDrain);\n                src._readableState.awaitDrain++;\n                increasedAwaitDrain = true;\n              }\n              src.pause();\n            }\n          }\n\n          // if the dest has an error, then stop piping into it.\n          // however, don't suppress the throwing behavior for this.\n          function onerror(er) {\n            debug('onerror', er);\n            unpipe();\n            dest.removeListener('error', onerror);\n            if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n          }\n\n          // Make sure our error handler is attached before userland ones.\n          prependListener(dest, 'error', onerror);\n\n          // Both close and finish should trigger unpipe, but only once.\n          function onclose() {\n            dest.removeListener('finish', onfinish);\n            unpipe();\n          }\n          dest.once('close', onclose);\n          function onfinish() {\n            debug('onfinish');\n            dest.removeListener('close', onclose);\n            unpipe();\n          }\n          dest.once('finish', onfinish);\n          function unpipe() {\n            debug('unpipe');\n            src.unpipe(dest);\n          }\n\n          // tell the dest that it's being piped to\n          dest.emit('pipe', src);\n\n          // start the flow if it hasn't been started already.\n          if (!state.flowing) {\n            debug('pipe resume');\n            src.resume();\n          }\n          return dest;\n        };\n        function pipeOnDrain(src) {\n          return function () {\n            var state = src._readableState;\n            debug('pipeOnDrain', state.awaitDrain);\n            if (state.awaitDrain) state.awaitDrain--;\n            if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n              state.flowing = true;\n              flow(src);\n            }\n          };\n        }\n        Readable.prototype.unpipe = function (dest) {\n          var state = this._readableState;\n          var unpipeInfo = {\n            hasUnpiped: false\n          };\n\n          // if we're not piping anywhere, then do nothing.\n          if (state.pipesCount === 0) return this;\n\n          // just one destination.  most common case.\n          if (state.pipesCount === 1) {\n            // passed in one, but it's not the right one.\n            if (dest && dest !== state.pipes) return this;\n            if (!dest) dest = state.pipes;\n\n            // got a match.\n            state.pipes = null;\n            state.pipesCount = 0;\n            state.flowing = false;\n            if (dest) dest.emit('unpipe', this, unpipeInfo);\n            return this;\n          }\n\n          // slow case. multiple pipe destinations.\n\n          if (!dest) {\n            // remove all.\n            var dests = state.pipes;\n            var len = state.pipesCount;\n            state.pipes = null;\n            state.pipesCount = 0;\n            state.flowing = false;\n            for (var i = 0; i < len; i++) {\n              dests[i].emit('unpipe', this, unpipeInfo);\n            }\n            return this;\n          }\n\n          // try to find the right one.\n          var index = indexOf(state.pipes, dest);\n          if (index === -1) return this;\n          state.pipes.splice(index, 1);\n          state.pipesCount -= 1;\n          if (state.pipesCount === 1) state.pipes = state.pipes[0];\n          dest.emit('unpipe', this, unpipeInfo);\n          return this;\n        };\n\n        // set up data events if they are asked for\n        // Ensure readable listeners eventually get something\n        Readable.prototype.on = function (ev, fn) {\n          var res = Stream.prototype.on.call(this, ev, fn);\n          if (ev === 'data') {\n            // Start flowing on next tick if stream isn't explicitly paused\n            if (this._readableState.flowing !== false) this.resume();\n          } else if (ev === 'readable') {\n            var state = this._readableState;\n            if (!state.endEmitted && !state.readableListening) {\n              state.readableListening = state.needReadable = true;\n              state.emittedReadable = false;\n              if (!state.reading) {\n                pna.nextTick(nReadingNextTick, this);\n              } else if (state.length) {\n                emitReadable(this);\n              }\n            }\n          }\n          return res;\n        };\n        Readable.prototype.addListener = Readable.prototype.on;\n        function nReadingNextTick(self) {\n          debug('readable nexttick read 0');\n          self.read(0);\n        }\n\n        // pause() and resume() are remnants of the legacy readable stream API\n        // If the user uses them, then switch into old mode.\n        Readable.prototype.resume = function () {\n          var state = this._readableState;\n          if (!state.flowing) {\n            debug('resume');\n            state.flowing = true;\n            resume(this, state);\n          }\n          return this;\n        };\n        function resume(stream, state) {\n          if (!state.resumeScheduled) {\n            state.resumeScheduled = true;\n            pna.nextTick(resume_, stream, state);\n          }\n        }\n        function resume_(stream, state) {\n          if (!state.reading) {\n            debug('resume read 0');\n            stream.read(0);\n          }\n          state.resumeScheduled = false;\n          state.awaitDrain = 0;\n          stream.emit('resume');\n          flow(stream);\n          if (state.flowing && !state.reading) stream.read(0);\n        }\n        Readable.prototype.pause = function () {\n          debug('call pause flowing=%j', this._readableState.flowing);\n          if (false !== this._readableState.flowing) {\n            debug('pause');\n            this._readableState.flowing = false;\n            this.emit('pause');\n          }\n          return this;\n        };\n        function flow(stream) {\n          var state = stream._readableState;\n          debug('flow', state.flowing);\n          while (state.flowing && stream.read() !== null) {}\n        }\n\n        // wrap an old-style stream as the async data source.\n        // This is *not* part of the readable stream interface.\n        // It is an ugly unfortunate mess of history.\n        Readable.prototype.wrap = function (stream) {\n          var _this = this;\n          var state = this._readableState;\n          var paused = false;\n          stream.on('end', function () {\n            debug('wrapped end');\n            if (state.decoder && !state.ended) {\n              var chunk = state.decoder.end();\n              if (chunk && chunk.length) _this.push(chunk);\n            }\n            _this.push(null);\n          });\n          stream.on('data', function (chunk) {\n            debug('wrapped data');\n            if (state.decoder) chunk = state.decoder.write(chunk);\n\n            // don't skip over falsy values in objectMode\n            if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n            var ret = _this.push(chunk);\n            if (!ret) {\n              paused = true;\n              stream.pause();\n            }\n          });\n\n          // proxy all the other methods.\n          // important when wrapping filters and duplexes.\n          for (var i in stream) {\n            if (this[i] === undefined && typeof stream[i] === 'function') {\n              this[i] = function (method) {\n                return function () {\n                  return stream[method].apply(stream, arguments);\n                };\n              }(i);\n            }\n          }\n\n          // proxy certain important events.\n          for (var n = 0; n < kProxyEvents.length; n++) {\n            stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n          }\n\n          // when we try to consume some more bytes, simply unpause the\n          // underlying stream.\n          this._read = function (n) {\n            debug('wrapped _read', n);\n            if (paused) {\n              paused = false;\n              stream.resume();\n            }\n          };\n          return this;\n        };\n        Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n          // making it explicit this property is not enumerable\n          // because otherwise some prototype manipulation in\n          // userland will fail\n          enumerable: false,\n          get: function get() {\n            return this._readableState.highWaterMark;\n          }\n        });\n\n        // exposed for testing purposes only.\n        Readable._fromList = fromList;\n\n        // Pluck off n bytes from an array of buffers.\n        // Length is the combined lengths of all the buffers in the list.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function fromList(n, state) {\n          // nothing buffered\n          if (state.length === 0) return null;\n          var ret;\n          if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n            // read it all, truncate the list\n            if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n            state.buffer.clear();\n          } else {\n            // read part of list\n            ret = fromListPartial(n, state.buffer, state.decoder);\n          }\n          return ret;\n        }\n\n        // Extracts only enough buffered data to satisfy the amount requested.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function fromListPartial(n, list, hasStrings) {\n          var ret;\n          if (n < list.head.data.length) {\n            // slice is the same for buffers and strings\n            ret = list.head.data.slice(0, n);\n            list.head.data = list.head.data.slice(n);\n          } else if (n === list.head.data.length) {\n            // first chunk is a perfect match\n            ret = list.shift();\n          } else {\n            // result spans more than one buffer\n            ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n          }\n          return ret;\n        }\n\n        // Copies a specified amount of characters from the list of buffered data\n        // chunks.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function copyFromBufferString(n, list) {\n          var p = list.head;\n          var c = 1;\n          var ret = p.data;\n          n -= ret.length;\n          while (p = p.next) {\n            var str = p.data;\n            var nb = n > str.length ? str.length : n;\n            if (nb === str.length) ret += str;else ret += str.slice(0, n);\n            n -= nb;\n            if (n === 0) {\n              if (nb === str.length) {\n                ++c;\n                if (p.next) list.head = p.next;else list.head = list.tail = null;\n              } else {\n                list.head = p;\n                p.data = str.slice(nb);\n              }\n              break;\n            }\n            ++c;\n          }\n          list.length -= c;\n          return ret;\n        }\n\n        // Copies a specified amount of bytes from the list of buffered data chunks.\n        // This function is designed to be inlinable, so please take care when making\n        // changes to the function body.\n        function copyFromBuffer(n, list) {\n          var ret = Buffer.allocUnsafe(n);\n          var p = list.head;\n          var c = 1;\n          p.data.copy(ret);\n          n -= p.data.length;\n          while (p = p.next) {\n            var buf = p.data;\n            var nb = n > buf.length ? buf.length : n;\n            buf.copy(ret, ret.length - n, 0, nb);\n            n -= nb;\n            if (n === 0) {\n              if (nb === buf.length) {\n                ++c;\n                if (p.next) list.head = p.next;else list.head = list.tail = null;\n              } else {\n                list.head = p;\n                p.data = buf.slice(nb);\n              }\n              break;\n            }\n            ++c;\n          }\n          list.length -= c;\n          return ret;\n        }\n        function endReadable(stream) {\n          var state = stream._readableState;\n\n          // If we get here before consuming all the bytes, then that is a\n          // bug in node.  Should never happen.\n          if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n          if (!state.endEmitted) {\n            state.ended = true;\n            pna.nextTick(endReadableNT, state, stream);\n          }\n        }\n        function endReadableNT(state, stream) {\n          // Check that we didn't get one last unshift.\n          if (!state.endEmitted && state.length === 0) {\n            state.endEmitted = true;\n            stream.readable = false;\n            stream.emit('end');\n          }\n        }\n        function indexOf(xs, x) {\n          for (var i = 0, l = xs.length; i < l; i++) {\n            if (xs[i] === x) return i;\n          }\n          return -1;\n        }\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./_stream_duplex\": 106,\n      \"./internal/streams/BufferList\": 111,\n      \"./internal/streams/destroy\": 112,\n      \"./internal/streams/stream\": 113,\n      \"_process\": 100,\n      \"core-util-is\": 13,\n      \"events\": 83,\n      \"inherits\": 88,\n      \"isarray\": 114,\n      \"process-nextick-args\": 99,\n      \"safe-buffer\": 118,\n      \"string_decoder/\": 115,\n      \"util\": 11\n    }],\n    109: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      // a transform stream is a readable/writable stream where you do\n      // something with the data.  Sometimes it's called a \"filter\",\n      // but that's not a great name for it, since that implies a thing where\n      // some bits pass through, and others are simply ignored.  (That would\n      // be a valid example of a transform, of course.)\n      //\n      // While the output is causally related to the input, it's not a\n      // necessarily symmetric or synchronous transformation.  For example,\n      // a zlib stream might take multiple plain-text writes(), and then\n      // emit a single compressed chunk some time in the future.\n      //\n      // Here's how this works:\n      //\n      // The Transform stream has all the aspects of the readable and writable\n      // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n      // internally, and returns false if there's a lot of pending writes\n      // buffered up.  When you call read(), that calls _read(n) until\n      // there's enough pending readable data buffered up.\n      //\n      // In a transform stream, the written data is placed in a buffer.  When\n      // _read(n) is called, it transforms the queued up data, calling the\n      // buffered _write cb's as it consumes chunks.  If consuming a single\n      // written chunk would result in multiple output chunks, then the first\n      // outputted bit calls the readcb, and subsequent chunks just go into\n      // the read buffer, and will cause it to emit 'readable' if necessary.\n      //\n      // This way, back-pressure is actually determined by the reading side,\n      // since _read has to be called to start processing a new chunk.  However,\n      // a pathological inflate type of transform can cause excessive buffering\n      // here.  For example, imagine a stream where every byte of input is\n      // interpreted as an integer from 0-255, and then results in that many\n      // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n      // 1kb of data being output.  In this case, you could write a very small\n      // amount of input, and end up with a very large amount of output.  In\n      // such a pathological inflating mechanism, there'd be no way to tell\n      // the system to stop doing the transform.  A single 4MB write could\n      // cause the system to run out of memory.\n      //\n      // However, even in such a pathological case, only a single written chunk\n      // would be consumed, and then the rest would wait (un-transformed) until\n      // the results of the previous transformed chunk were consumed.\n\n      'use strict';\n\n      module.exports = Transform;\n      var Duplex = require('./_stream_duplex');\n\n      /*<replacement>*/\n      var util = require('core-util-is');\n      util.inherits = require('inherits');\n      /*</replacement>*/\n\n      util.inherits(Transform, Duplex);\n      function afterTransform(er, data) {\n        var ts = this._transformState;\n        ts.transforming = false;\n        var cb = ts.writecb;\n        if (!cb) {\n          return this.emit('error', new Error('write callback called multiple times'));\n        }\n        ts.writechunk = null;\n        ts.writecb = null;\n        if (data != null)\n          // single equals check for both `null` and `undefined`\n          this.push(data);\n        cb(er);\n        var rs = this._readableState;\n        rs.reading = false;\n        if (rs.needReadable || rs.length < rs.highWaterMark) {\n          this._read(rs.highWaterMark);\n        }\n      }\n      function Transform(options) {\n        if (!(this instanceof Transform)) return new Transform(options);\n        Duplex.call(this, options);\n        this._transformState = {\n          afterTransform: afterTransform.bind(this),\n          needTransform: false,\n          transforming: false,\n          writecb: null,\n          writechunk: null,\n          writeencoding: null\n        };\n\n        // start out asking for a readable event once data is transformed.\n        this._readableState.needReadable = true;\n\n        // we have implemented the _read method, and done the other things\n        // that Readable wants before the first _read call, so unset the\n        // sync guard flag.\n        this._readableState.sync = false;\n        if (options) {\n          if (typeof options.transform === 'function') this._transform = options.transform;\n          if (typeof options.flush === 'function') this._flush = options.flush;\n        }\n\n        // When the writable side finishes, then flush out anything remaining.\n        this.on('prefinish', prefinish);\n      }\n      function prefinish() {\n        var _this = this;\n        if (typeof this._flush === 'function') {\n          this._flush(function (er, data) {\n            done(_this, er, data);\n          });\n        } else {\n          done(this, null, null);\n        }\n      }\n      Transform.prototype.push = function (chunk, encoding) {\n        this._transformState.needTransform = false;\n        return Duplex.prototype.push.call(this, chunk, encoding);\n      };\n\n      // This is the part where you do stuff!\n      // override this function in implementation classes.\n      // 'chunk' is an input chunk.\n      //\n      // Call `push(newChunk)` to pass along transformed output\n      // to the readable side.  You may call 'push' zero or more times.\n      //\n      // Call `cb(err)` when you are done with this chunk.  If you pass\n      // an error, then that'll put the hurt on the whole operation.  If you\n      // never call cb(), then you'll never get another chunk.\n      Transform.prototype._transform = function (chunk, encoding, cb) {\n        throw new Error('_transform() is not implemented');\n      };\n      Transform.prototype._write = function (chunk, encoding, cb) {\n        var ts = this._transformState;\n        ts.writecb = cb;\n        ts.writechunk = chunk;\n        ts.writeencoding = encoding;\n        if (!ts.transforming) {\n          var rs = this._readableState;\n          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n        }\n      };\n\n      // Doesn't matter what the args are here.\n      // _transform does all the work.\n      // That we got here means that the readable side wants more data.\n      Transform.prototype._read = function (n) {\n        var ts = this._transformState;\n        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n          ts.transforming = true;\n          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n        } else {\n          // mark that we need a transform, so that any data that comes in\n          // will get processed, now that we've asked for it.\n          ts.needTransform = true;\n        }\n      };\n      Transform.prototype._destroy = function (err, cb) {\n        var _this2 = this;\n        Duplex.prototype._destroy.call(this, err, function (err2) {\n          cb(err2);\n          _this2.emit('close');\n        });\n      };\n      function done(stream, er, data) {\n        if (er) return stream.emit('error', er);\n        if (data != null)\n          // single equals check for both `null` and `undefined`\n          stream.push(data);\n\n        // if there's nothing in the write buffer, then that means\n        // that nothing more will ever be provided\n        if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n        if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n        return stream.push(null);\n      }\n    }, {\n      \"./_stream_duplex\": 106,\n      \"core-util-is\": 13,\n      \"inherits\": 88\n    }],\n    110: [function (require, module, exports) {\n      (function (process, global, setImmediate) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        // A bit simpler than readable streams.\n        // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n        // the drain event emission and buffering.\n\n        'use strict';\n\n        /*<replacement>*/\n        var pna = require('process-nextick-args');\n        /*</replacement>*/\n\n        module.exports = Writable;\n\n        /* <replacement> */\n        function WriteReq(chunk, encoding, cb) {\n          this.chunk = chunk;\n          this.encoding = encoding;\n          this.callback = cb;\n          this.next = null;\n        }\n\n        // It seems a linked list but it is not\n        // there will be only 2 of these for each stream\n        function CorkedRequest(state) {\n          var _this = this;\n          this.next = null;\n          this.entry = null;\n          this.finish = function () {\n            onCorkedFinish(_this, state);\n          };\n        }\n        /* </replacement> */\n\n        /*<replacement>*/\n        var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Duplex;\n        /*</replacement>*/\n\n        Writable.WritableState = WritableState;\n\n        /*<replacement>*/\n        var util = require('core-util-is');\n        util.inherits = require('inherits');\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var internalUtil = {\n          deprecate: require('util-deprecate')\n        };\n        /*</replacement>*/\n\n        /*<replacement>*/\n        var Stream = require('./internal/streams/stream');\n        /*</replacement>*/\n\n        /*<replacement>*/\n\n        var Buffer = require('safe-buffer').Buffer;\n        var OurUint8Array = global.Uint8Array || function () {};\n        function _uint8ArrayToBuffer(chunk) {\n          return Buffer.from(chunk);\n        }\n        function _isUint8Array(obj) {\n          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n        }\n\n        /*</replacement>*/\n\n        var destroyImpl = require('./internal/streams/destroy');\n        util.inherits(Writable, Stream);\n        function nop() {}\n        function WritableState(options, stream) {\n          Duplex = Duplex || require('./_stream_duplex');\n          options = options || {};\n\n          // Duplex streams are both readable and writable, but share\n          // the same options object.\n          // However, some cases require setting options to different\n          // values for the readable and the writable sides of the duplex stream.\n          // These options can be provided separately as readableXXX and writableXXX.\n          var isDuplex = stream instanceof Duplex;\n\n          // object stream flag to indicate whether or not this stream\n          // contains buffers or objects.\n          this.objectMode = !!options.objectMode;\n          if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n          // the point at which write() starts returning false\n          // Note: 0 is a valid value, means that we always return false if\n          // the entire buffer is not flushed immediately on write()\n          var hwm = options.highWaterMark;\n          var writableHwm = options.writableHighWaterMark;\n          var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n          if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n          // cast to ints.\n          this.highWaterMark = Math.floor(this.highWaterMark);\n\n          // if _final has been called\n          this.finalCalled = false;\n\n          // drain event flag.\n          this.needDrain = false;\n          // at the start of calling end()\n          this.ending = false;\n          // when end() has been called, and returned\n          this.ended = false;\n          // when 'finish' is emitted\n          this.finished = false;\n\n          // has it been destroyed\n          this.destroyed = false;\n\n          // should we decode strings into buffers before passing to _write?\n          // this is here so that some node-core streams can optimize string\n          // handling at a lower level.\n          var noDecode = options.decodeStrings === false;\n          this.decodeStrings = !noDecode;\n\n          // Crypto is kind of old and crusty.  Historically, its default string\n          // encoding is 'binary' so we have to make this configurable.\n          // Everything else in the universe uses 'utf8', though.\n          this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n          // not an actual buffer we keep track of, but a measurement\n          // of how much we're waiting to get pushed to some underlying\n          // socket or file.\n          this.length = 0;\n\n          // a flag to see when we're in the middle of a write.\n          this.writing = false;\n\n          // when true all writes will be buffered until .uncork() call\n          this.corked = 0;\n\n          // a flag to be able to tell if the onwrite cb is called immediately,\n          // or on a later tick.  We set this to true at first, because any\n          // actions that shouldn't happen until \"later\" should generally also\n          // not happen before the first write call.\n          this.sync = true;\n\n          // a flag to know if we're processing previously buffered items, which\n          // may call the _write() callback in the same tick, so that we don't\n          // end up in an overlapped onwrite situation.\n          this.bufferProcessing = false;\n\n          // the callback that's passed to _write(chunk,cb)\n          this.onwrite = function (er) {\n            onwrite(stream, er);\n          };\n\n          // the callback that the user supplies to write(chunk,encoding,cb)\n          this.writecb = null;\n\n          // the amount that is being written when _write is called.\n          this.writelen = 0;\n          this.bufferedRequest = null;\n          this.lastBufferedRequest = null;\n\n          // number of pending user-supplied write callbacks\n          // this must be 0 before 'finish' can be emitted\n          this.pendingcb = 0;\n\n          // emit prefinish if the only thing we're waiting for is _write cbs\n          // This is relevant for synchronous Transform streams\n          this.prefinished = false;\n\n          // True if the error was already emitted and should not be thrown again\n          this.errorEmitted = false;\n\n          // count buffered requests\n          this.bufferedRequestCount = 0;\n\n          // allocate the first CorkedRequest, there is always\n          // one allocated and free to use, and we maintain at most two\n          this.corkedRequestsFree = new CorkedRequest(this);\n        }\n        WritableState.prototype.getBuffer = function getBuffer() {\n          var current = this.bufferedRequest;\n          var out = [];\n          while (current) {\n            out.push(current);\n            current = current.next;\n          }\n          return out;\n        };\n        (function () {\n          try {\n            Object.defineProperty(WritableState.prototype, 'buffer', {\n              get: internalUtil.deprecate(function () {\n                return this.getBuffer();\n              }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n            });\n          } catch (_) {}\n        })();\n\n        // Test _writableState for inheritance to account for Duplex streams,\n        // whose prototype chain only points to Readable.\n        var realHasInstance;\n        if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n          realHasInstance = Function.prototype[Symbol.hasInstance];\n          Object.defineProperty(Writable, Symbol.hasInstance, {\n            value: function value(object) {\n              if (realHasInstance.call(this, object)) return true;\n              if (this !== Writable) return false;\n              return object && object._writableState instanceof WritableState;\n            }\n          });\n        } else {\n          realHasInstance = function realHasInstance(object) {\n            return object instanceof this;\n          };\n        }\n        function Writable(options) {\n          Duplex = Duplex || require('./_stream_duplex');\n\n          // Writable ctor is applied to Duplexes, too.\n          // `realHasInstance` is necessary because using plain `instanceof`\n          // would return false, as no `_writableState` property is attached.\n\n          // Trying to use the custom `instanceof` for Writable here will also break the\n          // Node.js LazyTransform implementation, which has a non-trivial getter for\n          // `_writableState` that would lead to infinite recursion.\n          if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n            return new Writable(options);\n          }\n          this._writableState = new WritableState(options, this);\n\n          // legacy.\n          this.writable = true;\n          if (options) {\n            if (typeof options.write === 'function') this._write = options.write;\n            if (typeof options.writev === 'function') this._writev = options.writev;\n            if (typeof options.destroy === 'function') this._destroy = options.destroy;\n            if (typeof options.final === 'function') this._final = options.final;\n          }\n          Stream.call(this);\n        }\n\n        // Otherwise people can pipe Writable streams, which is just wrong.\n        Writable.prototype.pipe = function () {\n          this.emit('error', new Error('Cannot pipe, not readable'));\n        };\n        function writeAfterEnd(stream, cb) {\n          var er = new Error('write after end');\n          // TODO: defer error events consistently everywhere, not just the cb\n          stream.emit('error', er);\n          pna.nextTick(cb, er);\n        }\n\n        // Checks that a user-supplied chunk is valid, especially for the particular\n        // mode the stream is in. Currently this means that `null` is never accepted\n        // and undefined/non-string values are only allowed in object mode.\n        function validChunk(stream, state, chunk, cb) {\n          var valid = true;\n          var er = false;\n          if (chunk === null) {\n            er = new TypeError('May not write null values to stream');\n          } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n            er = new TypeError('Invalid non-string/buffer chunk');\n          }\n          if (er) {\n            stream.emit('error', er);\n            pna.nextTick(cb, er);\n            valid = false;\n          }\n          return valid;\n        }\n        Writable.prototype.write = function (chunk, encoding, cb) {\n          var state = this._writableState;\n          var ret = false;\n          var isBuf = !state.objectMode && _isUint8Array(chunk);\n          if (isBuf && !Buffer.isBuffer(chunk)) {\n            chunk = _uint8ArrayToBuffer(chunk);\n          }\n          if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = null;\n          }\n          if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n          if (typeof cb !== 'function') cb = nop;\n          if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n            state.pendingcb++;\n            ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n          }\n          return ret;\n        };\n        Writable.prototype.cork = function () {\n          var state = this._writableState;\n          state.corked++;\n        };\n        Writable.prototype.uncork = function () {\n          var state = this._writableState;\n          if (state.corked) {\n            state.corked--;\n            if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n          }\n        };\n        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n          // node::ParseEncoding() requires lower case.\n          if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n          if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n          this._writableState.defaultEncoding = encoding;\n          return this;\n        };\n        function decodeChunk(state, chunk, encoding) {\n          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n          }\n          return chunk;\n        }\n        Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n          // making it explicit this property is not enumerable\n          // because otherwise some prototype manipulation in\n          // userland will fail\n          enumerable: false,\n          get: function get() {\n            return this._writableState.highWaterMark;\n          }\n        });\n\n        // if we're already writing something, then just put this\n        // in the queue, and wait our turn.  Otherwise, call _write\n        // If we return false, then we need a drain event, so set that flag.\n        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n          if (!isBuf) {\n            var newChunk = decodeChunk(state, chunk, encoding);\n            if (chunk !== newChunk) {\n              isBuf = true;\n              encoding = 'buffer';\n              chunk = newChunk;\n            }\n          }\n          var len = state.objectMode ? 1 : chunk.length;\n          state.length += len;\n          var ret = state.length < state.highWaterMark;\n          // we must ensure that previous needDrain will not be reset to false.\n          if (!ret) state.needDrain = true;\n          if (state.writing || state.corked) {\n            var last = state.lastBufferedRequest;\n            state.lastBufferedRequest = {\n              chunk: chunk,\n              encoding: encoding,\n              isBuf: isBuf,\n              callback: cb,\n              next: null\n            };\n            if (last) {\n              last.next = state.lastBufferedRequest;\n            } else {\n              state.bufferedRequest = state.lastBufferedRequest;\n            }\n            state.bufferedRequestCount += 1;\n          } else {\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n          }\n          return ret;\n        }\n        function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n          state.writelen = len;\n          state.writecb = cb;\n          state.writing = true;\n          state.sync = true;\n          if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n          state.sync = false;\n        }\n        function onwriteError(stream, state, sync, er, cb) {\n          --state.pendingcb;\n          if (sync) {\n            // defer the callback if we are being called synchronously\n            // to avoid piling up things on the stack\n            pna.nextTick(cb, er);\n            // this can emit finish, and it will always happen\n            // after error\n            pna.nextTick(finishMaybe, stream, state);\n            stream._writableState.errorEmitted = true;\n            stream.emit('error', er);\n          } else {\n            // the caller expect this to happen before if\n            // it is async\n            cb(er);\n            stream._writableState.errorEmitted = true;\n            stream.emit('error', er);\n            // this can emit finish, but finish must\n            // always follow error\n            finishMaybe(stream, state);\n          }\n        }\n        function onwriteStateUpdate(state) {\n          state.writing = false;\n          state.writecb = null;\n          state.length -= state.writelen;\n          state.writelen = 0;\n        }\n        function onwrite(stream, er) {\n          var state = stream._writableState;\n          var sync = state.sync;\n          var cb = state.writecb;\n          onwriteStateUpdate(state);\n          if (er) onwriteError(stream, state, sync, er, cb);else {\n            // Check if we're actually ready to finish, but don't emit yet\n            var finished = needFinish(state);\n            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n              clearBuffer(stream, state);\n            }\n            if (sync) {\n              /*<replacement>*/\n              asyncWrite(afterWrite, stream, state, finished, cb);\n              /*</replacement>*/\n            } else {\n              afterWrite(stream, state, finished, cb);\n            }\n          }\n        }\n        function afterWrite(stream, state, finished, cb) {\n          if (!finished) onwriteDrain(stream, state);\n          state.pendingcb--;\n          cb();\n          finishMaybe(stream, state);\n        }\n\n        // Must force callback to be called on nextTick, so that we don't\n        // emit 'drain' before the write() consumer gets the 'false' return\n        // value, and has a chance to attach a 'drain' listener.\n        function onwriteDrain(stream, state) {\n          if (state.length === 0 && state.needDrain) {\n            state.needDrain = false;\n            stream.emit('drain');\n          }\n        }\n\n        // if there's something in the buffer waiting, then process it\n        function clearBuffer(stream, state) {\n          state.bufferProcessing = true;\n          var entry = state.bufferedRequest;\n          if (stream._writev && entry && entry.next) {\n            // Fast case, write everything using _writev()\n            var l = state.bufferedRequestCount;\n            var buffer = new Array(l);\n            var holder = state.corkedRequestsFree;\n            holder.entry = entry;\n            var count = 0;\n            var allBuffers = true;\n            while (entry) {\n              buffer[count] = entry;\n              if (!entry.isBuf) allBuffers = false;\n              entry = entry.next;\n              count += 1;\n            }\n            buffer.allBuffers = allBuffers;\n            doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n            // doWrite is almost always async, defer these to save a bit of time\n            // as the hot path ends with doWrite\n            state.pendingcb++;\n            state.lastBufferedRequest = null;\n            if (holder.next) {\n              state.corkedRequestsFree = holder.next;\n              holder.next = null;\n            } else {\n              state.corkedRequestsFree = new CorkedRequest(state);\n            }\n            state.bufferedRequestCount = 0;\n          } else {\n            // Slow case, write chunks one-by-one\n            while (entry) {\n              var chunk = entry.chunk;\n              var encoding = entry.encoding;\n              var cb = entry.callback;\n              var len = state.objectMode ? 1 : chunk.length;\n              doWrite(stream, state, false, len, chunk, encoding, cb);\n              entry = entry.next;\n              state.bufferedRequestCount--;\n              // if we didn't call the onwrite immediately, then\n              // it means that we need to wait until it does.\n              // also, that means that the chunk and cb are currently\n              // being processed, so move the buffer counter past them.\n              if (state.writing) {\n                break;\n              }\n            }\n            if (entry === null) state.lastBufferedRequest = null;\n          }\n          state.bufferedRequest = entry;\n          state.bufferProcessing = false;\n        }\n        Writable.prototype._write = function (chunk, encoding, cb) {\n          cb(new Error('_write() is not implemented'));\n        };\n        Writable.prototype._writev = null;\n        Writable.prototype.end = function (chunk, encoding, cb) {\n          var state = this._writableState;\n          if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = null;\n            encoding = null;\n          } else if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = null;\n          }\n          if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n          // .end() fully uncorks\n          if (state.corked) {\n            state.corked = 1;\n            this.uncork();\n          }\n\n          // ignore unnecessary end() calls.\n          if (!state.ending && !state.finished) endWritable(this, state, cb);\n        };\n        function needFinish(state) {\n          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n        }\n        function callFinal(stream, state) {\n          stream._final(function (err) {\n            state.pendingcb--;\n            if (err) {\n              stream.emit('error', err);\n            }\n            state.prefinished = true;\n            stream.emit('prefinish');\n            finishMaybe(stream, state);\n          });\n        }\n        function prefinish(stream, state) {\n          if (!state.prefinished && !state.finalCalled) {\n            if (typeof stream._final === 'function') {\n              state.pendingcb++;\n              state.finalCalled = true;\n              pna.nextTick(callFinal, stream, state);\n            } else {\n              state.prefinished = true;\n              stream.emit('prefinish');\n            }\n          }\n        }\n        function finishMaybe(stream, state) {\n          var need = needFinish(state);\n          if (need) {\n            prefinish(stream, state);\n            if (state.pendingcb === 0) {\n              state.finished = true;\n              stream.emit('finish');\n            }\n          }\n          return need;\n        }\n        function endWritable(stream, state, cb) {\n          state.ending = true;\n          finishMaybe(stream, state);\n          if (cb) {\n            if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n          }\n          state.ended = true;\n          stream.writable = false;\n        }\n        function onCorkedFinish(corkReq, state, err) {\n          var entry = corkReq.entry;\n          corkReq.entry = null;\n          while (entry) {\n            var cb = entry.callback;\n            state.pendingcb--;\n            cb(err);\n            entry = entry.next;\n          }\n          if (state.corkedRequestsFree) {\n            state.corkedRequestsFree.next = corkReq;\n          } else {\n            state.corkedRequestsFree = corkReq;\n          }\n        }\n        Object.defineProperty(Writable.prototype, 'destroyed', {\n          get: function get() {\n            if (this._writableState === undefined) {\n              return false;\n            }\n            return this._writableState.destroyed;\n          },\n          set: function set(value) {\n            // we ignore the value if the stream\n            // has not been initialized yet\n            if (!this._writableState) {\n              return;\n            }\n\n            // backward compatibility, the user is explicitly\n            // managing destroyed\n            this._writableState.destroyed = value;\n          }\n        });\n        Writable.prototype.destroy = destroyImpl.destroy;\n        Writable.prototype._undestroy = destroyImpl.undestroy;\n        Writable.prototype._destroy = function (err, cb) {\n          this.end();\n          cb(err);\n        };\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {}, require(\"timers\").setImmediate);\n    }, {\n      \"./_stream_duplex\": 106,\n      \"./internal/streams/destroy\": 112,\n      \"./internal/streams/stream\": 113,\n      \"_process\": 100,\n      \"core-util-is\": 13,\n      \"inherits\": 88,\n      \"process-nextick-args\": 99,\n      \"safe-buffer\": 118,\n      \"timers\": 120,\n      \"util-deprecate\": 134\n    }],\n    111: [function (require, module, exports) {\n      'use strict';\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      var Buffer = require('safe-buffer').Buffer;\n      var util = require('util');\n      function copyBuffer(src, target, offset) {\n        src.copy(target, offset);\n      }\n      module.exports = function () {\n        function BufferList() {\n          _classCallCheck(this, BufferList);\n          this.head = null;\n          this.tail = null;\n          this.length = 0;\n        }\n        BufferList.prototype.push = function push(v) {\n          var entry = {\n            data: v,\n            next: null\n          };\n          if (this.length > 0) this.tail.next = entry;else this.head = entry;\n          this.tail = entry;\n          ++this.length;\n        };\n        BufferList.prototype.unshift = function unshift(v) {\n          var entry = {\n            data: v,\n            next: this.head\n          };\n          if (this.length === 0) this.tail = entry;\n          this.head = entry;\n          ++this.length;\n        };\n        BufferList.prototype.shift = function shift() {\n          if (this.length === 0) return;\n          var ret = this.head.data;\n          if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n          --this.length;\n          return ret;\n        };\n        BufferList.prototype.clear = function clear() {\n          this.head = this.tail = null;\n          this.length = 0;\n        };\n        BufferList.prototype.join = function join(s) {\n          if (this.length === 0) return '';\n          var p = this.head;\n          var ret = '' + p.data;\n          while (p = p.next) {\n            ret += s + p.data;\n          }\n          return ret;\n        };\n        BufferList.prototype.concat = function concat(n) {\n          if (this.length === 0) return Buffer.alloc(0);\n          if (this.length === 1) return this.head.data;\n          var ret = Buffer.allocUnsafe(n >>> 0);\n          var p = this.head;\n          var i = 0;\n          while (p) {\n            copyBuffer(p.data, ret, i);\n            i += p.data.length;\n            p = p.next;\n          }\n          return ret;\n        };\n        return BufferList;\n      }();\n      if (util && util.inspect && util.inspect.custom) {\n        module.exports.prototype[util.inspect.custom] = function () {\n          var obj = util.inspect({\n            length: this.length\n          });\n          return this.constructor.name + ' ' + obj;\n        };\n      }\n    }, {\n      \"safe-buffer\": 118,\n      \"util\": 11\n    }],\n    112: [function (require, module, exports) {\n      'use strict';\n\n      /*<replacement>*/\n      var pna = require('process-nextick-args');\n      /*</replacement>*/\n\n      // undocumented cb() API, needed for core, not for public API\n      function destroy(err, cb) {\n        var _this = this;\n        var readableDestroyed = this._readableState && this._readableState.destroyed;\n        var writableDestroyed = this._writableState && this._writableState.destroyed;\n        if (readableDestroyed || writableDestroyed) {\n          if (cb) {\n            cb(err);\n          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n            pna.nextTick(emitErrorNT, this, err);\n          }\n          return this;\n        }\n\n        // we set destroyed to true before firing error callbacks in order\n        // to make it re-entrance safe in case destroy() is called within callbacks\n\n        if (this._readableState) {\n          this._readableState.destroyed = true;\n        }\n\n        // if this is a duplex stream mark the writable part as destroyed as well\n        if (this._writableState) {\n          this._writableState.destroyed = true;\n        }\n        this._destroy(err || null, function (err) {\n          if (!cb && err) {\n            pna.nextTick(emitErrorNT, _this, err);\n            if (_this._writableState) {\n              _this._writableState.errorEmitted = true;\n            }\n          } else if (cb) {\n            cb(err);\n          }\n        });\n        return this;\n      }\n      function undestroy() {\n        if (this._readableState) {\n          this._readableState.destroyed = false;\n          this._readableState.reading = false;\n          this._readableState.ended = false;\n          this._readableState.endEmitted = false;\n        }\n        if (this._writableState) {\n          this._writableState.destroyed = false;\n          this._writableState.ended = false;\n          this._writableState.ending = false;\n          this._writableState.finished = false;\n          this._writableState.errorEmitted = false;\n        }\n      }\n      function emitErrorNT(self, err) {\n        self.emit('error', err);\n      }\n      module.exports = {\n        destroy: destroy,\n        undestroy: undestroy\n      };\n    }, {\n      \"process-nextick-args\": 99\n    }],\n    113: [function (require, module, exports) {\n      module.exports = require('events').EventEmitter;\n    }, {\n      \"events\": 83\n    }],\n    114: [function (require, module, exports) {\n      var toString = {}.toString;\n      module.exports = Array.isArray || function (arr) {\n        return toString.call(arr) == '[object Array]';\n      };\n    }, {}],\n    115: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      /*<replacement>*/\n      var Buffer = require('safe-buffer').Buffer;\n      /*</replacement>*/\n\n      var isEncoding = Buffer.isEncoding || function (encoding) {\n        encoding = '' + encoding;\n        switch (encoding && encoding.toLowerCase()) {\n          case 'hex':\n          case 'utf8':\n          case 'utf-8':\n          case 'ascii':\n          case 'binary':\n          case 'base64':\n          case 'ucs2':\n          case 'ucs-2':\n          case 'utf16le':\n          case 'utf-16le':\n          case 'raw':\n            return true;\n          default:\n            return false;\n        }\n      };\n      function _normalizeEncoding(enc) {\n        if (!enc) return 'utf8';\n        var retried;\n        while (true) {\n          switch (enc) {\n            case 'utf8':\n            case 'utf-8':\n              return 'utf8';\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return 'utf16le';\n            case 'latin1':\n            case 'binary':\n              return 'latin1';\n            case 'base64':\n            case 'ascii':\n            case 'hex':\n              return enc;\n            default:\n              if (retried) return; // undefined\n              enc = ('' + enc).toLowerCase();\n              retried = true;\n          }\n        }\n      }\n      ;\n\n      // Do not cache `Buffer.isEncoding` when checking encoding names as some\n      // modules monkey-patch it to support additional encodings\n      function normalizeEncoding(enc) {\n        var nenc = _normalizeEncoding(enc);\n        if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n        return nenc || enc;\n      }\n\n      // StringDecoder provides an interface for efficiently splitting a series of\n      // buffers into a series of JS strings without breaking apart multi-byte\n      // characters.\n      exports.StringDecoder = StringDecoder;\n      function StringDecoder(encoding) {\n        this.encoding = normalizeEncoding(encoding);\n        var nb;\n        switch (this.encoding) {\n          case 'utf16le':\n            this.text = utf16Text;\n            this.end = utf16End;\n            nb = 4;\n            break;\n          case 'utf8':\n            this.fillLast = utf8FillLast;\n            nb = 4;\n            break;\n          case 'base64':\n            this.text = base64Text;\n            this.end = base64End;\n            nb = 3;\n            break;\n          default:\n            this.write = simpleWrite;\n            this.end = simpleEnd;\n            return;\n        }\n        this.lastNeed = 0;\n        this.lastTotal = 0;\n        this.lastChar = Buffer.allocUnsafe(nb);\n      }\n      StringDecoder.prototype.write = function (buf) {\n        if (buf.length === 0) return '';\n        var r;\n        var i;\n        if (this.lastNeed) {\n          r = this.fillLast(buf);\n          if (r === undefined) return '';\n          i = this.lastNeed;\n          this.lastNeed = 0;\n        } else {\n          i = 0;\n        }\n        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n        return r || '';\n      };\n      StringDecoder.prototype.end = utf8End;\n\n      // Returns only complete characters in a Buffer\n      StringDecoder.prototype.text = utf8Text;\n\n      // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n      StringDecoder.prototype.fillLast = function (buf) {\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n        this.lastNeed -= buf.length;\n      };\n\n      // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n      // continuation byte. If an invalid byte is detected, -2 is returned.\n      function utf8CheckByte(byte) {\n        if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n        return byte >> 6 === 0x02 ? -1 : -2;\n      }\n\n      // Checks at most 3 bytes at the end of a Buffer in order to detect an\n      // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n      // needed to complete the UTF-8 character (if applicable) are returned.\n      function utf8CheckIncomplete(self, buf, i) {\n        var j = buf.length - 1;\n        if (j < i) return 0;\n        var nb = utf8CheckByte(buf[j]);\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 1;\n          return nb;\n        }\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n        if (nb >= 0) {\n          if (nb > 0) self.lastNeed = nb - 2;\n          return nb;\n        }\n        if (--j < i || nb === -2) return 0;\n        nb = utf8CheckByte(buf[j]);\n        if (nb >= 0) {\n          if (nb > 0) {\n            if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n          }\n          return nb;\n        }\n        return 0;\n      }\n\n      // Validates as many continuation bytes for a multi-byte UTF-8 character as\n      // needed or are available. If we see a non-continuation byte where we expect\n      // one, we \"replace\" the validated continuation bytes we've seen so far with\n      // a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n      // behavior. The continuation byte check is included three times in the case\n      // where all of the continuation bytes for a character exist in the same buffer.\n      // It is also done this way as a slight performance increase instead of using a\n      // loop.\n      function utf8CheckExtraBytes(self, buf, p) {\n        if ((buf[0] & 0xC0) !== 0x80) {\n          self.lastNeed = 0;\n          return \"\\uFFFD\";\n        }\n        if (self.lastNeed > 1 && buf.length > 1) {\n          if ((buf[1] & 0xC0) !== 0x80) {\n            self.lastNeed = 1;\n            return \"\\uFFFD\";\n          }\n          if (self.lastNeed > 2 && buf.length > 2) {\n            if ((buf[2] & 0xC0) !== 0x80) {\n              self.lastNeed = 2;\n              return \"\\uFFFD\";\n            }\n          }\n        }\n      }\n\n      // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n      function utf8FillLast(buf) {\n        var p = this.lastTotal - this.lastNeed;\n        var r = utf8CheckExtraBytes(this, buf, p);\n        if (r !== undefined) return r;\n        if (this.lastNeed <= buf.length) {\n          buf.copy(this.lastChar, p, 0, this.lastNeed);\n          return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n        }\n        buf.copy(this.lastChar, p, 0, buf.length);\n        this.lastNeed -= buf.length;\n      }\n\n      // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n      // partial character, the character's bytes are buffered until the required\n      // number of bytes are available.\n      function utf8Text(buf, i) {\n        var total = utf8CheckIncomplete(this, buf, i);\n        if (!this.lastNeed) return buf.toString('utf8', i);\n        this.lastTotal = total;\n        var end = buf.length - (total - this.lastNeed);\n        buf.copy(this.lastChar, 0, end);\n        return buf.toString('utf8', i, end);\n      }\n\n      // For UTF-8, a replacement character is added when ending on a partial\n      // character.\n      function utf8End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + \"\\uFFFD\";\n        return r;\n      }\n\n      // UTF-16LE typically needs two bytes per character, but even if we have an even\n      // number of bytes available, we need to check if we end on a leading/high\n      // surrogate. In that case, we need to wait for the next two bytes in order to\n      // decode the last character properly.\n      function utf16Text(buf, i) {\n        if ((buf.length - i) % 2 === 0) {\n          var r = buf.toString('utf16le', i);\n          if (r) {\n            var c = r.charCodeAt(r.length - 1);\n            if (c >= 0xD800 && c <= 0xDBFF) {\n              this.lastNeed = 2;\n              this.lastTotal = 4;\n              this.lastChar[0] = buf[buf.length - 2];\n              this.lastChar[1] = buf[buf.length - 1];\n              return r.slice(0, -1);\n            }\n          }\n          return r;\n        }\n        this.lastNeed = 1;\n        this.lastTotal = 2;\n        this.lastChar[0] = buf[buf.length - 1];\n        return buf.toString('utf16le', i, buf.length - 1);\n      }\n\n      // For UTF-16LE we do not explicitly append special replacement characters if we\n      // end on a partial character, we simply let v8 handle that.\n      function utf16End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) {\n          var end = this.lastTotal - this.lastNeed;\n          return r + this.lastChar.toString('utf16le', 0, end);\n        }\n        return r;\n      }\n      function base64Text(buf, i) {\n        var n = (buf.length - i) % 3;\n        if (n === 0) return buf.toString('base64', i);\n        this.lastNeed = 3 - n;\n        this.lastTotal = 3;\n        if (n === 1) {\n          this.lastChar[0] = buf[buf.length - 1];\n        } else {\n          this.lastChar[0] = buf[buf.length - 2];\n          this.lastChar[1] = buf[buf.length - 1];\n        }\n        return buf.toString('base64', i, buf.length - n);\n      }\n      function base64End(buf) {\n        var r = buf && buf.length ? this.write(buf) : '';\n        if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n        return r;\n      }\n\n      // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n      function simpleWrite(buf) {\n        return buf.toString(this.encoding);\n      }\n      function simpleEnd(buf) {\n        return buf && buf.length ? this.write(buf) : '';\n      }\n    }, {\n      \"safe-buffer\": 118\n    }],\n    116: [function (require, module, exports) {\n      exports = module.exports = require('./lib/_stream_readable.js');\n      exports.Stream = exports;\n      exports.Readable = exports;\n      exports.Writable = require('./lib/_stream_writable.js');\n      exports.Duplex = require('./lib/_stream_duplex.js');\n      exports.Transform = require('./lib/_stream_transform.js');\n      exports.PassThrough = require('./lib/_stream_passthrough.js');\n    }, {\n      \"./lib/_stream_duplex.js\": 106,\n      \"./lib/_stream_passthrough.js\": 107,\n      \"./lib/_stream_readable.js\": 108,\n      \"./lib/_stream_transform.js\": 109,\n      \"./lib/_stream_writable.js\": 110\n    }],\n    117: [function (require, module, exports) {\n      'use strict';\n\n      function ReInterval(callback, interval, args) {\n        var self = this;\n        this._callback = callback;\n        this._args = args;\n        this._interval = setInterval(callback, interval, this._args);\n        this.reschedule = function (interval) {\n          // if no interval entered, use the interval passed in on creation\n          if (!interval) interval = self._interval;\n          if (self._interval) clearInterval(self._interval);\n          self._interval = setInterval(self._callback, interval, self._args);\n        };\n        this.clear = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n            self._interval = undefined;\n          }\n        };\n        this.destroy = function () {\n          if (self._interval) {\n            clearInterval(self._interval);\n          }\n          self._callback = undefined;\n          self._interval = undefined;\n          self._args = undefined;\n        };\n      }\n      function reInterval() {\n        if (typeof arguments[0] !== 'function') throw new Error('callback needed');\n        if (typeof arguments[1] !== 'number') throw new Error('interval needed');\n        var args;\n        if (arguments.length > 0) {\n          args = new Array(arguments.length - 2);\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i + 2];\n          }\n        }\n        return new ReInterval(arguments[0], arguments[1], args);\n      }\n      module.exports = reInterval;\n    }, {}],\n    118: [function (require, module, exports) {\n      /* eslint-disable node/no-deprecated-api */\n      var buffer = require('buffer');\n      var Buffer = buffer.Buffer;\n\n      // alternative to using Object.keys for old browsers\n      function copyProps(src, dst) {\n        for (var key in src) {\n          dst[key] = src[key];\n        }\n      }\n      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n        module.exports = buffer;\n      } else {\n        // Copy properties from require('buffer')\n        copyProps(buffer, exports);\n        exports.Buffer = SafeBuffer;\n      }\n      function SafeBuffer(arg, encodingOrOffset, length) {\n        return Buffer(arg, encodingOrOffset, length);\n      }\n\n      // Copy static methods from Buffer\n      copyProps(Buffer, SafeBuffer);\n      SafeBuffer.from = function (arg, encodingOrOffset, length) {\n        if (typeof arg === 'number') {\n          throw new TypeError('Argument must not be a number');\n        }\n        return Buffer(arg, encodingOrOffset, length);\n      };\n      SafeBuffer.alloc = function (size, fill, encoding) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n        var buf = Buffer(size);\n        if (fill !== undefined) {\n          if (typeof encoding === 'string') {\n            buf.fill(fill, encoding);\n          } else {\n            buf.fill(fill);\n          }\n        } else {\n          buf.fill(0);\n        }\n        return buf;\n      };\n      SafeBuffer.allocUnsafe = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n        return Buffer(size);\n      };\n      SafeBuffer.allocUnsafeSlow = function (size) {\n        if (typeof size !== 'number') {\n          throw new TypeError('Argument must be a number');\n        }\n        return buffer.SlowBuffer(size);\n      };\n    }, {\n      \"buffer\": 12\n    }],\n    119: [function (require, module, exports) {\n      module.exports = shift;\n      function shift(stream) {\n        var rs = stream._readableState;\n        if (!rs) return null;\n        return rs.objectMode || typeof stream._duplexState === 'number' ? stream.read() : stream.read(getStateLength(rs));\n      }\n      function getStateLength(state) {\n        if (state.buffer.length) {\n          // Since node 6.3.0 state.buffer is a BufferList not an array\n          if (state.buffer.head) {\n            return state.buffer.head.data.length;\n          }\n          return state.buffer[0].length;\n        }\n        return state.length;\n      }\n    }, {}],\n    120: [function (require, module, exports) {\n      (function (setImmediate, clearImmediate) {\n        var nextTick = require('process/browser.js').nextTick;\n        var apply = Function.prototype.apply;\n        var slice = Array.prototype.slice;\n        var immediateIds = {};\n        var nextImmediateId = 0;\n\n        // DOM APIs, for completeness\n\n        exports.setTimeout = function () {\n          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n        };\n        exports.setInterval = function () {\n          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n        };\n        exports.clearTimeout = exports.clearInterval = function (timeout) {\n          timeout.close();\n        };\n        function Timeout(id, clearFn) {\n          this._id = id;\n          this._clearFn = clearFn;\n        }\n        Timeout.prototype.unref = Timeout.prototype.ref = function () {};\n        Timeout.prototype.close = function () {\n          this._clearFn.call(window, this._id);\n        };\n\n        // Does not start the time, just sets up the members needed.\n        exports.enroll = function (item, msecs) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = msecs;\n        };\n        exports.unenroll = function (item) {\n          clearTimeout(item._idleTimeoutId);\n          item._idleTimeout = -1;\n        };\n        exports._unrefActive = exports.active = function (item) {\n          clearTimeout(item._idleTimeoutId);\n          var msecs = item._idleTimeout;\n          if (msecs >= 0) {\n            item._idleTimeoutId = setTimeout(function onTimeout() {\n              if (item._onTimeout) item._onTimeout();\n            }, msecs);\n          }\n        };\n\n        // That's not how node.js implements it but the exposed api is the same.\n        exports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function (fn) {\n          var id = nextImmediateId++;\n          var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n          immediateIds[id] = true;\n          nextTick(function onNextTick() {\n            if (immediateIds[id]) {\n              // fn.call() is faster so we optimize for the common use-case\n              // @see http://jsperf.com/call-apply-segu\n              if (args) {\n                fn.apply(null, args);\n              } else {\n                fn.call(null);\n              }\n              // Prevent ids from leaking\n              exports.clearImmediate(id);\n            }\n          });\n          return id;\n        };\n        exports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function (id) {\n          delete immediateIds[id];\n        };\n      }).call(this, require(\"timers\").setImmediate, require(\"timers\").clearImmediate);\n    }, {\n      \"process/browser.js\": 100,\n      \"timers\": 120\n    }],\n    121: [function (require, module, exports) {\n      \"use strict\";\n\n      var isPrototype = require(\"../prototype/is\");\n      module.exports = function (value) {\n        if (typeof value !== \"function\") return false;\n        if (!hasOwnProperty.call(value, \"length\")) return false;\n        try {\n          if (typeof value.length !== \"number\") return false;\n          if (typeof value.call !== \"function\") return false;\n          if (typeof value.apply !== \"function\") return false;\n        } catch (error) {\n          return false;\n        }\n        return !isPrototype(value);\n      };\n    }, {\n      \"../prototype/is\": 128\n    }],\n    122: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"../value/is\"),\n        isObject = require(\"../object/is\"),\n        stringCoerce = require(\"../string/coerce\"),\n        toShortString = require(\"./to-short-string\");\n      var resolveMessage = function resolveMessage(message, value) {\n        return message.replace(\"%v\", toShortString(value));\n      };\n      module.exports = function (value, defaultMessage, inputOptions) {\n        if (!isObject(inputOptions)) throw new TypeError(resolveMessage(defaultMessage, value));\n        if (!isValue(value)) {\n          if (\"default\" in inputOptions) return inputOptions[\"default\"];\n          if (inputOptions.isOptional) return null;\n        }\n        var errorMessage = stringCoerce(inputOptions.errorMessage);\n        if (!isValue(errorMessage)) errorMessage = defaultMessage;\n        throw new TypeError(resolveMessage(errorMessage, value));\n      };\n    }, {\n      \"../object/is\": 125,\n      \"../string/coerce\": 129,\n      \"../value/is\": 131,\n      \"./to-short-string\": 124\n    }],\n    123: [function (require, module, exports) {\n      \"use strict\";\n\n      module.exports = function (value) {\n        try {\n          return value.toString();\n        } catch (error) {\n          try {\n            return String(value);\n          } catch (error2) {\n            return null;\n          }\n        }\n      };\n    }, {}],\n    124: [function (require, module, exports) {\n      \"use strict\";\n\n      var safeToString = require(\"./safe-to-string\");\n      var reNewLine = /[\\n\\r\\u2028\\u2029]/g;\n      module.exports = function (value) {\n        var string = safeToString(value);\n        if (string === null) return \"<Non-coercible to string value>\";\n        // Trim if too long\n        if (string.length > 100) string = string.slice(0, 99) + \"…\";\n        // Replace eventual new lines\n        string = string.replace(reNewLine, function (char) {\n          switch (char) {\n            case \"\\n\":\n              return \"\\\\n\";\n            case \"\\r\":\n              return \"\\\\r\";\n            case \"\\u2028\":\n              return \"\\\\u2028\";\n            case \"\\u2029\":\n              return \"\\\\u2029\";\n            /* istanbul ignore next */\n            default:\n              throw new Error(\"Unexpected character\");\n          }\n        });\n        return string;\n      };\n    }, {\n      \"./safe-to-string\": 123\n    }],\n    125: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"../value/is\");\n\n      // prettier-ignore\n      var possibleTypes = {\n        \"object\": true,\n        \"function\": true,\n        \"undefined\": true /* document.all */\n      };\n\n      module.exports = function (value) {\n        if (!isValue(value)) return false;\n        return hasOwnProperty.call(possibleTypes, _typeof(value));\n      };\n    }, {\n      \"../value/is\": 131\n    }],\n    126: [function (require, module, exports) {\n      \"use strict\";\n\n      var resolveException = require(\"../lib/resolve-exception\"),\n        is = require(\"./is\");\n      module.exports = function (value /*, options*/) {\n        if (is(value)) return value;\n        return resolveException(value, \"%v is not a plain function\", arguments[1]);\n      };\n    }, {\n      \"../lib/resolve-exception\": 122,\n      \"./is\": 127\n    }],\n    127: [function (require, module, exports) {\n      \"use strict\";\n\n      var isFunction = require(\"../function/is\");\n      var classRe = /^\\s*class[\\s{/}]/,\n        functionToString = Function.prototype.toString;\n      module.exports = function (value) {\n        if (!isFunction(value)) return false;\n        if (classRe.test(functionToString.call(value))) return false;\n        return true;\n      };\n    }, {\n      \"../function/is\": 121\n    }],\n    128: [function (require, module, exports) {\n      \"use strict\";\n\n      var isObject = require(\"../object/is\");\n      module.exports = function (value) {\n        if (!isObject(value)) return false;\n        try {\n          if (!value.constructor) return false;\n          return value.constructor.prototype === value;\n        } catch (error) {\n          return false;\n        }\n      };\n    }, {\n      \"../object/is\": 125\n    }],\n    129: [function (require, module, exports) {\n      \"use strict\";\n\n      var isValue = require(\"../value/is\"),\n        isObject = require(\"../object/is\");\n      var objectToString = Object.prototype.toString;\n      module.exports = function (value) {\n        if (!isValue(value)) return null;\n        if (isObject(value)) {\n          // Reject Object.prototype.toString coercion\n          var valueToString = value.toString;\n          if (typeof valueToString !== \"function\") return null;\n          if (valueToString === objectToString) return null;\n          // Note: It can be object coming from other realm, still as there's no ES3 and CSP compliant\n          // way to resolve its realm's Object.prototype.toString it's left as not addressed edge case\n        }\n\n        try {\n          return \"\" + value; // Ensure implicit coercion\n        } catch (error) {\n          return null;\n        }\n      };\n    }, {\n      \"../object/is\": 125,\n      \"../value/is\": 131\n    }],\n    130: [function (require, module, exports) {\n      \"use strict\";\n\n      var resolveException = require(\"../lib/resolve-exception\"),\n        is = require(\"./is\");\n      module.exports = function (value /*, options*/) {\n        if (is(value)) return value;\n        return resolveException(value, \"Cannot use %v\", arguments[1]);\n      };\n    }, {\n      \"../lib/resolve-exception\": 122,\n      \"./is\": 131\n    }],\n    131: [function (require, module, exports) {\n      \"use strict\";\n\n      // ES3 safe\n      var _undefined = void 0;\n      module.exports = function (value) {\n        return value !== _undefined && value !== null;\n      };\n    }, {}],\n    132: [function (require, module, exports) {\n      // Copyright Joyent, Inc. and other Node contributors.\n      //\n      // Permission is hereby granted, free of charge, to any person obtaining a\n      // copy of this software and associated documentation files (the\n      // \"Software\"), to deal in the Software without restriction, including\n      // without limitation the rights to use, copy, modify, merge, publish,\n      // distribute, sublicense, and/or sell copies of the Software, and to permit\n      // persons to whom the Software is furnished to do so, subject to the\n      // following conditions:\n      //\n      // The above copyright notice and this permission notice shall be included\n      // in all copies or substantial portions of the Software.\n      //\n      // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n      // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n      'use strict';\n\n      var punycode = require('punycode');\n      var util = require('./util');\n      exports.parse = urlParse;\n      exports.resolve = urlResolve;\n      exports.resolveObject = urlResolveObject;\n      exports.format = urlFormat;\n      exports.Url = Url;\n      function Url() {\n        this.protocol = null;\n        this.slashes = null;\n        this.auth = null;\n        this.host = null;\n        this.port = null;\n        this.hostname = null;\n        this.hash = null;\n        this.search = null;\n        this.query = null;\n        this.pathname = null;\n        this.path = null;\n        this.href = null;\n      }\n\n      // Reference: RFC 3986, RFC 1808, RFC 2396\n\n      // define these here so at least they only have to be\n      // compiled once on the first module load.\n      var protocolPattern = /^([a-z0-9.+-]+:)/i,\n        portPattern = /:[0-9]*$/,\n        // Special case for a simple path URL\n        simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n        // RFC 2396: characters reserved for delimiting URLs.\n        // We actually just auto-escape these.\n        delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n        // RFC 2396: characters not allowed for various reasons.\n        unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n        // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n        autoEscape = ['\\''].concat(unwise),\n        // Characters that are never ever allowed in a hostname.\n        // Note that any invalid chars are also handled, but these\n        // are the ones that are *expected* to be seen, so we fast-path\n        // them.\n        nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n        hostEndingChars = ['/', '?', '#'],\n        hostnameMaxLen = 255,\n        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n        // protocols that can allow \"unsafe\" and \"unwise\" chars.\n        unsafeProtocol = {\n          'javascript': true,\n          'javascript:': true\n        },\n        // protocols that never have a hostname.\n        hostlessProtocol = {\n          'javascript': true,\n          'javascript:': true\n        },\n        // protocols that always contain a // bit.\n        slashedProtocol = {\n          'http': true,\n          'https': true,\n          'ftp': true,\n          'gopher': true,\n          'file': true,\n          'http:': true,\n          'https:': true,\n          'ftp:': true,\n          'gopher:': true,\n          'file:': true\n        },\n        querystring = require('querystring');\n      function urlParse(url, parseQueryString, slashesDenoteHost) {\n        if (url && util.isObject(url) && url instanceof Url) return url;\n        var u = new Url();\n        u.parse(url, parseQueryString, slashesDenoteHost);\n        return u;\n      }\n      Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n        if (!util.isString(url)) {\n          throw new TypeError(\"Parameter 'url' must be a string, not \" + _typeof(url));\n        }\n\n        // Copy chrome, IE, opera backslash-handling behavior.\n        // Back slashes before the query string get converted to forward slashes\n        // See: https://code.google.com/p/chromium/issues/detail?id=25916\n        var queryIndex = url.indexOf('?'),\n          splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n          uSplit = url.split(splitter),\n          slashRegex = /\\\\/g;\n        uSplit[0] = uSplit[0].replace(slashRegex, '/');\n        url = uSplit.join(splitter);\n        var rest = url;\n\n        // trim before proceeding.\n        // This is to support parse stuff like \"  http://foo.com  \\n\"\n        rest = rest.trim();\n        if (!slashesDenoteHost && url.split('#').length === 1) {\n          // Try fast path regexp\n          var simplePath = simplePathPattern.exec(rest);\n          if (simplePath) {\n            this.path = rest;\n            this.href = rest;\n            this.pathname = simplePath[1];\n            if (simplePath[2]) {\n              this.search = simplePath[2];\n              if (parseQueryString) {\n                this.query = querystring.parse(this.search.substr(1));\n              } else {\n                this.query = this.search.substr(1);\n              }\n            } else if (parseQueryString) {\n              this.search = '';\n              this.query = {};\n            }\n            return this;\n          }\n        }\n        var proto = protocolPattern.exec(rest);\n        if (proto) {\n          proto = proto[0];\n          var lowerProto = proto.toLowerCase();\n          this.protocol = lowerProto;\n          rest = rest.substr(proto.length);\n        }\n\n        // figure out if it's got a host\n        // user@server is *always* interpreted as a hostname, and url\n        // resolution will treat //foo/bar as host=foo,path=bar because that's\n        // how the browser resolves relative URLs.\n        if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n          var slashes = rest.substr(0, 2) === '//';\n          if (slashes && !(proto && hostlessProtocol[proto])) {\n            rest = rest.substr(2);\n            this.slashes = true;\n          }\n        }\n        if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n          // there's a hostname.\n          // the first instance of /, ?, ;, or # ends the host.\n          //\n          // If there is an @ in the hostname, then non-host chars *are* allowed\n          // to the left of the last @ sign, unless some host-ending character\n          // comes *before* the @-sign.\n          // URLs are obnoxious.\n          //\n          // ex:\n          // http://a@b@c/ => user:a@b host:c\n          // http://a@b?@c => user:a host:c path:/?@c\n\n          // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n          // Review our test case against browsers more comprehensively.\n\n          // find the first instance of any hostEndingChars\n          var hostEnd = -1;\n          for (var i = 0; i < hostEndingChars.length; i++) {\n            var hec = rest.indexOf(hostEndingChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n          }\n\n          // at this point, either we have an explicit point where the\n          // auth portion cannot go past, or the last @ char is the decider.\n          var auth, atSign;\n          if (hostEnd === -1) {\n            // atSign can be anywhere.\n            atSign = rest.lastIndexOf('@');\n          } else {\n            // atSign must be in auth portion.\n            // http://a@b/c@d => host:b auth:a path:/c@d\n            atSign = rest.lastIndexOf('@', hostEnd);\n          }\n\n          // Now we have a portion which is definitely the auth.\n          // Pull that off.\n          if (atSign !== -1) {\n            auth = rest.slice(0, atSign);\n            rest = rest.slice(atSign + 1);\n            this.auth = decodeURIComponent(auth);\n          }\n\n          // the host is the remaining to the left of the first non-host char\n          hostEnd = -1;\n          for (var i = 0; i < nonHostChars.length; i++) {\n            var hec = rest.indexOf(nonHostChars[i]);\n            if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n          }\n          // if we still have not hit it, then the entire thing is a host.\n          if (hostEnd === -1) hostEnd = rest.length;\n          this.host = rest.slice(0, hostEnd);\n          rest = rest.slice(hostEnd);\n\n          // pull out port.\n          this.parseHost();\n\n          // we've indicated that there is a hostname,\n          // so even if it's empty, it has to be present.\n          this.hostname = this.hostname || '';\n\n          // if hostname begins with [ and ends with ]\n          // assume that it's an IPv6 address.\n          var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n          // validate a little.\n          if (!ipv6Hostname) {\n            var hostparts = this.hostname.split(/\\./);\n            for (var i = 0, l = hostparts.length; i < l; i++) {\n              var part = hostparts[i];\n              if (!part) continue;\n              if (!part.match(hostnamePartPattern)) {\n                var newpart = '';\n                for (var j = 0, k = part.length; j < k; j++) {\n                  if (part.charCodeAt(j) > 127) {\n                    // we replace non-ASCII char with a temporary placeholder\n                    // we need this to make sure size of hostname is not\n                    // broken by replacing non-ASCII by nothing\n                    newpart += 'x';\n                  } else {\n                    newpart += part[j];\n                  }\n                }\n                // we test again with ASCII char only\n                if (!newpart.match(hostnamePartPattern)) {\n                  var validParts = hostparts.slice(0, i);\n                  var notHost = hostparts.slice(i + 1);\n                  var bit = part.match(hostnamePartStart);\n                  if (bit) {\n                    validParts.push(bit[1]);\n                    notHost.unshift(bit[2]);\n                  }\n                  if (notHost.length) {\n                    rest = '/' + notHost.join('.') + rest;\n                  }\n                  this.hostname = validParts.join('.');\n                  break;\n                }\n              }\n            }\n          }\n          if (this.hostname.length > hostnameMaxLen) {\n            this.hostname = '';\n          } else {\n            // hostnames are always lower case.\n            this.hostname = this.hostname.toLowerCase();\n          }\n          if (!ipv6Hostname) {\n            // IDNA Support: Returns a punycoded representation of \"domain\".\n            // It only converts parts of the domain name that\n            // have non-ASCII characters, i.e. it doesn't matter if\n            // you call it with a domain that already is ASCII-only.\n            this.hostname = punycode.toASCII(this.hostname);\n          }\n          var p = this.port ? ':' + this.port : '';\n          var h = this.hostname || '';\n          this.host = h + p;\n          this.href += this.host;\n\n          // strip [ and ] from the hostname\n          // the host field still retains them, though\n          if (ipv6Hostname) {\n            this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n            if (rest[0] !== '/') {\n              rest = '/' + rest;\n            }\n          }\n        }\n\n        // now rest is set to the post-host stuff.\n        // chop off any delim chars.\n        if (!unsafeProtocol[lowerProto]) {\n          // First, make 100% sure that any \"autoEscape\" chars get\n          // escaped, even if encodeURIComponent doesn't think they\n          // need to be.\n          for (var i = 0, l = autoEscape.length; i < l; i++) {\n            var ae = autoEscape[i];\n            if (rest.indexOf(ae) === -1) continue;\n            var esc = encodeURIComponent(ae);\n            if (esc === ae) {\n              esc = escape(ae);\n            }\n            rest = rest.split(ae).join(esc);\n          }\n        }\n\n        // chop off from the tail first.\n        var hash = rest.indexOf('#');\n        if (hash !== -1) {\n          // got a fragment string.\n          this.hash = rest.substr(hash);\n          rest = rest.slice(0, hash);\n        }\n        var qm = rest.indexOf('?');\n        if (qm !== -1) {\n          this.search = rest.substr(qm);\n          this.query = rest.substr(qm + 1);\n          if (parseQueryString) {\n            this.query = querystring.parse(this.query);\n          }\n          rest = rest.slice(0, qm);\n        } else if (parseQueryString) {\n          // no query string, but parseQueryString still requested\n          this.search = '';\n          this.query = {};\n        }\n        if (rest) this.pathname = rest;\n        if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n          this.pathname = '/';\n        }\n\n        //to support http.request\n        if (this.pathname || this.search) {\n          var p = this.pathname || '';\n          var s = this.search || '';\n          this.path = p + s;\n        }\n\n        // finally, reconstruct the href based on what has been validated.\n        this.href = this.format();\n        return this;\n      };\n\n      // format a parsed object into a url string\n      function urlFormat(obj) {\n        // ensure it's an object, and not a string url.\n        // If it's an obj, this is a no-op.\n        // this way, you can call url_format() on strings\n        // to clean up potentially wonky urls.\n        if (util.isString(obj)) obj = urlParse(obj);\n        if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n        return obj.format();\n      }\n      Url.prototype.format = function () {\n        var auth = this.auth || '';\n        if (auth) {\n          auth = encodeURIComponent(auth);\n          auth = auth.replace(/%3A/i, ':');\n          auth += '@';\n        }\n        var protocol = this.protocol || '',\n          pathname = this.pathname || '',\n          hash = this.hash || '',\n          host = false,\n          query = '';\n        if (this.host) {\n          host = auth + this.host;\n        } else if (this.hostname) {\n          host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n          if (this.port) {\n            host += ':' + this.port;\n          }\n        }\n        if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n          query = querystring.stringify(this.query);\n        }\n        var search = this.search || query && '?' + query || '';\n        if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n        // unless they had them to begin with.\n        if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n          host = '//' + (host || '');\n          if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n        } else if (!host) {\n          host = '';\n        }\n        if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n        if (search && search.charAt(0) !== '?') search = '?' + search;\n        pathname = pathname.replace(/[?#]/g, function (match) {\n          return encodeURIComponent(match);\n        });\n        search = search.replace('#', '%23');\n        return protocol + host + pathname + search + hash;\n      };\n      function urlResolve(source, relative) {\n        return urlParse(source, false, true).resolve(relative);\n      }\n      Url.prototype.resolve = function (relative) {\n        return this.resolveObject(urlParse(relative, false, true)).format();\n      };\n      function urlResolveObject(source, relative) {\n        if (!source) return relative;\n        return urlParse(source, false, true).resolveObject(relative);\n      }\n      Url.prototype.resolveObject = function (relative) {\n        if (util.isString(relative)) {\n          var rel = new Url();\n          rel.parse(relative, false, true);\n          relative = rel;\n        }\n        var result = new Url();\n        var tkeys = Object.keys(this);\n        for (var tk = 0; tk < tkeys.length; tk++) {\n          var tkey = tkeys[tk];\n          result[tkey] = this[tkey];\n        }\n\n        // hash is always overridden, no matter what.\n        // even href=\"\" will remove it.\n        result.hash = relative.hash;\n\n        // if the relative url is empty, then there's nothing left to do here.\n        if (relative.href === '') {\n          result.href = result.format();\n          return result;\n        }\n\n        // hrefs like //foo/bar always cut to the protocol.\n        if (relative.slashes && !relative.protocol) {\n          // take everything except the protocol from relative\n          var rkeys = Object.keys(relative);\n          for (var rk = 0; rk < rkeys.length; rk++) {\n            var rkey = rkeys[rk];\n            if (rkey !== 'protocol') result[rkey] = relative[rkey];\n          }\n\n          //urlParse appends trailing / to urls like http://www.example.com\n          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n            result.path = result.pathname = '/';\n          }\n          result.href = result.format();\n          return result;\n        }\n        if (relative.protocol && relative.protocol !== result.protocol) {\n          // if it's a known url protocol, then changing\n          // the protocol does weird things\n          // first, if it's not file:, then we MUST have a host,\n          // and if there was a path\n          // to begin with, then we MUST have a path.\n          // if it is file:, then the host is dropped,\n          // because that's known to be hostless.\n          // anything else is assumed to be absolute.\n          if (!slashedProtocol[relative.protocol]) {\n            var keys = Object.keys(relative);\n            for (var v = 0; v < keys.length; v++) {\n              var k = keys[v];\n              result[k] = relative[k];\n            }\n            result.href = result.format();\n            return result;\n          }\n          result.protocol = relative.protocol;\n          if (!relative.host && !hostlessProtocol[relative.protocol]) {\n            var relPath = (relative.pathname || '').split('/');\n            while (relPath.length && !(relative.host = relPath.shift())) {\n              ;\n            }\n            if (!relative.host) relative.host = '';\n            if (!relative.hostname) relative.hostname = '';\n            if (relPath[0] !== '') relPath.unshift('');\n            if (relPath.length < 2) relPath.unshift('');\n            result.pathname = relPath.join('/');\n          } else {\n            result.pathname = relative.pathname;\n          }\n          result.search = relative.search;\n          result.query = relative.query;\n          result.host = relative.host || '';\n          result.auth = relative.auth;\n          result.hostname = relative.hostname || relative.host;\n          result.port = relative.port;\n          // to support http.request\n          if (result.pathname || result.search) {\n            var p = result.pathname || '';\n            var s = result.search || '';\n            result.path = p + s;\n          }\n          result.slashes = result.slashes || relative.slashes;\n          result.href = result.format();\n          return result;\n        }\n        var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n          isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n          mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n          removeAllDots = mustEndAbs,\n          srcPath = result.pathname && result.pathname.split('/') || [],\n          relPath = relative.pathname && relative.pathname.split('/') || [],\n          psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n        // if the url is a non-slashed url, then relative\n        // links like ../.. should be able\n        // to crawl up to the hostname, as well.  This is strange.\n        // result.protocol has already been set by now.\n        // Later on, put the first path part into the host field.\n        if (psychotic) {\n          result.hostname = '';\n          result.port = null;\n          if (result.host) {\n            if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n          }\n          result.host = '';\n          if (relative.protocol) {\n            relative.hostname = null;\n            relative.port = null;\n            if (relative.host) {\n              if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n            }\n            relative.host = null;\n          }\n          mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n        }\n        if (isRelAbs) {\n          // it's absolute.\n          result.host = relative.host || relative.host === '' ? relative.host : result.host;\n          result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n          result.search = relative.search;\n          result.query = relative.query;\n          srcPath = relPath;\n          // fall through to the dot-handling below.\n        } else if (relPath.length) {\n          // it's relative\n          // throw away the existing file, and take the new path instead.\n          if (!srcPath) srcPath = [];\n          srcPath.pop();\n          srcPath = srcPath.concat(relPath);\n          result.search = relative.search;\n          result.query = relative.query;\n        } else if (!util.isNullOrUndefined(relative.search)) {\n          // just pull out the search.\n          // like href='?foo'.\n          // Put this after the other two cases because it simplifies the booleans\n          if (psychotic) {\n            result.hostname = result.host = srcPath.shift();\n            //occationaly the auth can get stuck only in host\n            //this especially happens in cases like\n            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n            var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n            if (authInHost) {\n              result.auth = authInHost.shift();\n              result.host = result.hostname = authInHost.shift();\n            }\n          }\n          result.search = relative.search;\n          result.query = relative.query;\n          //to support http.request\n          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n            result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n          }\n          result.href = result.format();\n          return result;\n        }\n        if (!srcPath.length) {\n          // no path at all.  easy.\n          // we've already handled the other stuff above.\n          result.pathname = null;\n          //to support http.request\n          if (result.search) {\n            result.path = '/' + result.search;\n          } else {\n            result.path = null;\n          }\n          result.href = result.format();\n          return result;\n        }\n\n        // if a url ENDs in . or .., then it must get a trailing slash.\n        // however, if it ends in anything else non-slashy,\n        // then it must NOT get a trailing slash.\n        var last = srcPath.slice(-1)[0];\n        var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';\n\n        // strip single dots, resolve double dots to parent dir\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = srcPath.length; i >= 0; i--) {\n          last = srcPath[i];\n          if (last === '.') {\n            srcPath.splice(i, 1);\n          } else if (last === '..') {\n            srcPath.splice(i, 1);\n            up++;\n          } else if (up) {\n            srcPath.splice(i, 1);\n            up--;\n          }\n        }\n\n        // if the path is allowed to go above the root, restore leading ..s\n        if (!mustEndAbs && !removeAllDots) {\n          for (; up--; up) {\n            srcPath.unshift('..');\n          }\n        }\n        if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n          srcPath.unshift('');\n        }\n        if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n          srcPath.push('');\n        }\n        var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';\n\n        // put the host back\n        if (psychotic) {\n          result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n          //occationaly the auth can get stuck only in host\n          //this especially happens in cases like\n          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n          var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n          if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n          }\n        }\n        mustEndAbs = mustEndAbs || result.host && srcPath.length;\n        if (mustEndAbs && !isAbsolute) {\n          srcPath.unshift('');\n        }\n        if (!srcPath.length) {\n          result.pathname = null;\n          result.path = null;\n        } else {\n          result.pathname = srcPath.join('/');\n        }\n\n        //to support request.http\n        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n          result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n        }\n        result.auth = relative.auth || result.auth;\n        result.slashes = result.slashes || relative.slashes;\n        result.href = result.format();\n        return result;\n      };\n      Url.prototype.parseHost = function () {\n        var host = this.host;\n        var port = portPattern.exec(host);\n        if (port) {\n          port = port[0];\n          if (port !== ':') {\n            this.port = port.substr(1);\n          }\n          host = host.substr(0, host.length - port.length);\n        }\n        if (host) this.hostname = host;\n      };\n    }, {\n      \"./util\": 133,\n      \"punycode\": 101,\n      \"querystring\": 104\n    }],\n    133: [function (require, module, exports) {\n      'use strict';\n\n      module.exports = {\n        isString: function isString(arg) {\n          return typeof arg === 'string';\n        },\n        isObject: function isObject(arg) {\n          return _typeof(arg) === 'object' && arg !== null;\n        },\n        isNull: function isNull(arg) {\n          return arg === null;\n        },\n        isNullOrUndefined: function isNullOrUndefined(arg) {\n          return arg == null;\n        }\n      };\n    }, {}],\n    134: [function (require, module, exports) {\n      (function (global) {\n        /**\n         * Module exports.\n         */\n\n        module.exports = deprecate;\n\n        /**\n         * Mark that a method should not be used.\n         * Returns a modified function which warns once by default.\n         *\n         * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n         *\n         * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n         * will throw an Error when invoked.\n         *\n         * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n         * will invoke `console.trace()` instead of `console.error()`.\n         *\n         * @param {Function} fn - the function to deprecate\n         * @param {String} msg - the string to print to the console when `fn` is invoked\n         * @returns {Function} a new \"deprecated\" version of `fn`\n         * @api public\n         */\n\n        function deprecate(fn, msg) {\n          if (config('noDeprecation')) {\n            return fn;\n          }\n          var warned = false;\n          function deprecated() {\n            if (!warned) {\n              if (config('throwDeprecation')) {\n                throw new Error(msg);\n              } else if (config('traceDeprecation')) {\n                console.trace(msg);\n              } else {\n                __f__(\"warn\", msg, \" at mqtt.js:14843\");\n              }\n              warned = true;\n            }\n            return fn.apply(this, arguments);\n          }\n          return deprecated;\n        }\n\n        /**\n         * Checks `localStorage` for boolean values for the given `name`.\n         *\n         * @param {String} name\n         * @returns {Boolean}\n         * @api private\n         */\n\n        function config(name) {\n          // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n          try {\n            if (!global.localStorage) return false;\n          } catch (_) {\n            return false;\n          }\n          var val = global.localStorage[name];\n          if (null == val) return false;\n          return String(val).toLowerCase() === 'true';\n        }\n      }).call(this, typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {}],\n    135: [function (require, module, exports) {\n      module.exports = function isBuffer(arg) {\n        return arg && _typeof(arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';\n      };\n    }, {}],\n    136: [function (require, module, exports) {\n      (function (process, global) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n        var formatRegExp = /%[sdj%]/g;\n        exports.format = function (f) {\n          if (!isString(f)) {\n            var objects = [];\n            for (var i = 0; i < arguments.length; i++) {\n              objects.push(inspect(arguments[i]));\n            }\n            return objects.join(' ');\n          }\n          var i = 1;\n          var args = arguments;\n          var len = args.length;\n          var str = String(f).replace(formatRegExp, function (x) {\n            if (x === '%%') return '%';\n            if (i >= len) return x;\n            switch (x) {\n              case '%s':\n                return String(args[i++]);\n              case '%d':\n                return Number(args[i++]);\n              case '%j':\n                try {\n                  return JSON.stringify(args[i++]);\n                } catch (_) {\n                  return '[Circular]';\n                }\n              default:\n                return x;\n            }\n          });\n          for (var x = args[i]; i < len; x = args[++i]) {\n            if (isNull(x) || !isObject(x)) {\n              str += ' ' + x;\n            } else {\n              str += ' ' + inspect(x);\n            }\n          }\n          return str;\n        };\n\n        // Mark that a method should not be used.\n        // Returns a modified function which warns once by default.\n        // If --no-deprecation is set, then it is a no-op.\n        exports.deprecate = function (fn, msg) {\n          // Allow for deprecating things in the process of starting up.\n          if (isUndefined(global.process)) {\n            return function () {\n              return exports.deprecate(fn, msg).apply(this, arguments);\n            };\n          }\n          if (process.noDeprecation === true) {\n            return fn;\n          }\n          var warned = false;\n          function deprecated() {\n            if (!warned) {\n              if (process.throwDeprecation) {\n                throw new Error(msg);\n              } else if (process.traceDeprecation) {\n                console.trace(msg);\n              } else {\n                __f__(\"error\", msg, \" at mqtt.js:14967\");\n              }\n              warned = true;\n            }\n            return fn.apply(this, arguments);\n          }\n          return deprecated;\n        };\n        var debugs = {};\n        var debugEnviron;\n        exports.debuglog = function (set) {\n          if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';\n          set = set.toUpperCase();\n          if (!debugs[set]) {\n            if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n              var pid = process.pid;\n              debugs[set] = function () {\n                var msg = exports.format.apply(exports, arguments);\n                __f__(\"error\", '%s %d: %s', set, pid, msg, \" at mqtt.js:14989\");\n              };\n            } else {\n              debugs[set] = function () {};\n            }\n          }\n          return debugs[set];\n        };\n\n        /**\n         * Echos the value of a value. Trys to print the value out\n         * in the best way possible given the different types.\n         *\n         * @param {Object} obj The object to print out.\n         * @param {Object} opts Optional options object that alters the output.\n         */\n        /* legacy: obj, showHidden, depth, colors*/\n        function inspect(obj, opts) {\n          // default options\n          var ctx = {\n            seen: [],\n            stylize: stylizeNoColor\n          };\n          // legacy...\n          if (arguments.length >= 3) ctx.depth = arguments[2];\n          if (arguments.length >= 4) ctx.colors = arguments[3];\n          if (isBoolean(opts)) {\n            // legacy...\n            ctx.showHidden = opts;\n          } else if (opts) {\n            // got an \"options\" object\n            exports._extend(ctx, opts);\n          }\n          // set default options\n          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n          if (isUndefined(ctx.depth)) ctx.depth = 2;\n          if (isUndefined(ctx.colors)) ctx.colors = false;\n          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n          if (ctx.colors) ctx.stylize = stylizeWithColor;\n          return formatValue(ctx, obj, ctx.depth);\n        }\n        exports.inspect = inspect;\n\n        // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n        inspect.colors = {\n          'bold': [1, 22],\n          'italic': [3, 23],\n          'underline': [4, 24],\n          'inverse': [7, 27],\n          'white': [37, 39],\n          'grey': [90, 39],\n          'black': [30, 39],\n          'blue': [34, 39],\n          'cyan': [36, 39],\n          'green': [32, 39],\n          'magenta': [35, 39],\n          'red': [31, 39],\n          'yellow': [33, 39]\n        };\n\n        // Don't use 'blue' not visible on cmd.exe\n        inspect.styles = {\n          'special': 'cyan',\n          'number': 'yellow',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red'\n        };\n        function stylizeWithColor(str, styleType) {\n          var style = inspect.styles[styleType];\n          if (style) {\n            return \"\\x1B[\" + inspect.colors[style][0] + 'm' + str + \"\\x1B[\" + inspect.colors[style][1] + 'm';\n          } else {\n            return str;\n          }\n        }\n        function stylizeNoColor(str, styleType) {\n          return str;\n        }\n        function arrayToHash(array) {\n          var hash = {};\n          array.forEach(function (val, idx) {\n            hash[val] = true;\n          });\n          return hash;\n        }\n        function formatValue(ctx, value, recurseTimes) {\n          // Provide a hook for user-specified inspect functions.\n          // Check that value is an object with an inspect function on it\n          if (ctx.customInspect && value && isFunction(value.inspect) &&\n          // Filter out the util module, it's inspect function is special\n          value.inspect !== exports.inspect &&\n          // Also filter out any prototype objects using the circular check.\n          !(value.constructor && value.constructor.prototype === value)) {\n            var ret = value.inspect(recurseTimes, ctx);\n            if (!isString(ret)) {\n              ret = formatValue(ctx, ret, recurseTimes);\n            }\n            return ret;\n          }\n\n          // Primitive types cannot have properties\n          var primitive = formatPrimitive(ctx, value);\n          if (primitive) {\n            return primitive;\n          }\n\n          // Look up the keys of the object.\n          var keys = Object.keys(value);\n          var visibleKeys = arrayToHash(keys);\n          if (ctx.showHidden) {\n            keys = Object.getOwnPropertyNames(value);\n          }\n\n          // IE doesn't make error fields non-enumerable\n          // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n          if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n            return formatError(value);\n          }\n\n          // Some type of object without properties can be shortcutted.\n          if (keys.length === 0) {\n            if (isFunction(value)) {\n              var name = value.name ? ': ' + value.name : '';\n              return ctx.stylize('[Function' + name + ']', 'special');\n            }\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            }\n            if (isDate(value)) {\n              return ctx.stylize(Date.prototype.toString.call(value), 'date');\n            }\n            if (isError(value)) {\n              return formatError(value);\n            }\n          }\n          var base = '',\n            array = false,\n            braces = ['{', '}'];\n\n          // Make Array say that they are Array\n          if (isArray(value)) {\n            array = true;\n            braces = ['[', ']'];\n          }\n\n          // Make functions say that they are functions\n          if (isFunction(value)) {\n            var n = value.name ? ': ' + value.name : '';\n            base = ' [Function' + n + ']';\n          }\n\n          // Make RegExps say that they are RegExps\n          if (isRegExp(value)) {\n            base = ' ' + RegExp.prototype.toString.call(value);\n          }\n\n          // Make dates with properties first say the date\n          if (isDate(value)) {\n            base = ' ' + Date.prototype.toUTCString.call(value);\n          }\n\n          // Make error with message first say the error\n          if (isError(value)) {\n            base = ' ' + formatError(value);\n          }\n          if (keys.length === 0 && (!array || value.length == 0)) {\n            return braces[0] + base + braces[1];\n          }\n          if (recurseTimes < 0) {\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            } else {\n              return ctx.stylize('[Object]', 'special');\n            }\n          }\n          ctx.seen.push(value);\n          var output;\n          if (array) {\n            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n          } else {\n            output = keys.map(function (key) {\n              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n            });\n          }\n          ctx.seen.pop();\n          return reduceToSingleString(output, base, braces);\n        }\n        function formatPrimitive(ctx, value) {\n          if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n          if (isString(value)) {\n            var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n            return ctx.stylize(simple, 'string');\n          }\n          if (isNumber(value)) return ctx.stylize('' + value, 'number');\n          if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');\n          // For some reason typeof null is \"object\", so special case here.\n          if (isNull(value)) return ctx.stylize('null', 'null');\n        }\n        function formatError(value) {\n          return '[' + Error.prototype.toString.call(value) + ']';\n        }\n        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n          var output = [];\n          for (var i = 0, l = value.length; i < l; ++i) {\n            if (hasOwnProperty(value, String(i))) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n            } else {\n              output.push('');\n            }\n          }\n          keys.forEach(function (key) {\n            if (!key.match(/^\\d+$/)) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n            }\n          });\n          return output;\n        }\n        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n          var name, str, desc;\n          desc = Object.getOwnPropertyDescriptor(value, key) || {\n            value: value[key]\n          };\n          if (desc.get) {\n            if (desc.set) {\n              str = ctx.stylize('[Getter/Setter]', 'special');\n            } else {\n              str = ctx.stylize('[Getter]', 'special');\n            }\n          } else {\n            if (desc.set) {\n              str = ctx.stylize('[Setter]', 'special');\n            }\n          }\n          if (!hasOwnProperty(visibleKeys, key)) {\n            name = '[' + key + ']';\n          }\n          if (!str) {\n            if (ctx.seen.indexOf(desc.value) < 0) {\n              if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n              } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n              }\n              if (str.indexOf('\\n') > -1) {\n                if (array) {\n                  str = str.split('\\n').map(function (line) {\n                    return '  ' + line;\n                  }).join('\\n').substr(2);\n                } else {\n                  str = '\\n' + str.split('\\n').map(function (line) {\n                    return '   ' + line;\n                  }).join('\\n');\n                }\n              }\n            } else {\n              str = ctx.stylize('[Circular]', 'special');\n            }\n          }\n          if (isUndefined(name)) {\n            if (array && key.match(/^\\d+$/)) {\n              return str;\n            }\n            name = JSON.stringify('' + key);\n            if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n              name = name.substr(1, name.length - 2);\n              name = ctx.stylize(name, 'name');\n            } else {\n              name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n              name = ctx.stylize(name, 'string');\n            }\n          }\n          return name + ': ' + str;\n        }\n        function reduceToSingleString(output, base, braces) {\n          var numLinesEst = 0;\n          var length = output.reduce(function (prev, cur) {\n            numLinesEst++;\n            if (cur.indexOf('\\n') >= 0) numLinesEst++;\n            return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n          }, 0);\n          if (length > 60) {\n            return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n          }\n          return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n        }\n\n        // NOTE: These type checking functions intentionally don't use `instanceof`\n        // because it is fragile and can be easily faked with `Object.create()`.\n        function isArray(ar) {\n          return Array.isArray(ar);\n        }\n        exports.isArray = isArray;\n        function isBoolean(arg) {\n          return typeof arg === 'boolean';\n        }\n        exports.isBoolean = isBoolean;\n        function isNull(arg) {\n          return arg === null;\n        }\n        exports.isNull = isNull;\n        function isNullOrUndefined(arg) {\n          return arg == null;\n        }\n        exports.isNullOrUndefined = isNullOrUndefined;\n        function isNumber(arg) {\n          return typeof arg === 'number';\n        }\n        exports.isNumber = isNumber;\n        function isString(arg) {\n          return typeof arg === 'string';\n        }\n        exports.isString = isString;\n        function isSymbol(arg) {\n          return _typeof(arg) === 'symbol';\n        }\n        exports.isSymbol = isSymbol;\n        function isUndefined(arg) {\n          return arg === void 0;\n        }\n        exports.isUndefined = isUndefined;\n        function isRegExp(re) {\n          return isObject(re) && objectToString(re) === '[object RegExp]';\n        }\n        exports.isRegExp = isRegExp;\n        function isObject(arg) {\n          return _typeof(arg) === 'object' && arg !== null;\n        }\n        exports.isObject = isObject;\n        function isDate(d) {\n          return isObject(d) && objectToString(d) === '[object Date]';\n        }\n        exports.isDate = isDate;\n        function isError(e) {\n          return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);\n        }\n        exports.isError = isError;\n        function isFunction(arg) {\n          return typeof arg === 'function';\n        }\n        exports.isFunction = isFunction;\n        function isPrimitive(arg) {\n          return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' ||\n          // ES6 symbol\n          typeof arg === 'undefined';\n        }\n        exports.isPrimitive = isPrimitive;\n        exports.isBuffer = require('./support/isBuffer');\n        function objectToString(o) {\n          return Object.prototype.toString.call(o);\n        }\n        function pad(n) {\n          return n < 10 ? '0' + n.toString(10) : n.toString(10);\n        }\n        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n        // 26 Feb 16:19:34\n        function timestamp() {\n          var d = new Date();\n          var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');\n          return [d.getDate(), months[d.getMonth()], time].join(' ');\n        }\n\n        // log is just a thin wrapper to console.log that prepends a timestamp\n        exports.log = function () {\n          __f__(\"log\", '%s - %s', timestamp(), exports.format.apply(exports, arguments), \" at mqtt.js:15435\");\n        };\n\n        /**\n         * Inherit the prototype methods from one constructor into another.\n         *\n         * The Function.prototype.inherits from lang.js rewritten as a standalone\n         * function (not on Function.prototype). NOTE: If this file is to be loaded\n         * during bootstrapping this function needs to be rewritten using some native\n         * functions as prototype setup using normal JavaScript does not work as\n         * expected during bootstrapping (see mirror.js in r114903).\n         *\n         * @param {function} ctor Constructor function which needs to inherit the\n         *     prototype.\n         * @param {function} superCtor Constructor function to inherit prototype from.\n         */\n        exports.inherits = require('inherits');\n        exports._extend = function (origin, add) {\n          // Don't do anything if add isn't an object\n          if (!add || !isObject(add)) return origin;\n          var keys = Object.keys(add);\n          var i = keys.length;\n          while (i--) {\n            origin[keys[i]] = add[keys[i]];\n          }\n          return origin;\n        };\n        function hasOwnProperty(obj, prop) {\n          return Object.prototype.hasOwnProperty.call(obj, prop);\n        }\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"./support/isBuffer\": 135,\n      \"_process\": 100,\n      \"inherits\": 88\n    }],\n    137: [function (require, module, exports) {\n      (function (process, global) {\n        'use strict';\n\n        var Transform = require('readable-stream').Transform;\n        var duplexify = require('duplexify');\n        var WS = require('ws');\n        var Buffer = require('safe-buffer').Buffer;\n        module.exports = WebSocketStream;\n        function buildProxy(options, socketWrite, socketEnd) {\n          var proxy = new Transform({\n            objectMode: options.objectMode\n          });\n          proxy._write = socketWrite;\n          proxy._flush = socketEnd;\n          return proxy;\n        }\n        function WebSocketStream(target, protocols, options) {\n          var stream, socket;\n          var isBrowser = process.title === 'browser';\n          var isNative = !!global.WebSocket;\n          var socketWrite = isBrowser ? socketWriteBrowser : socketWriteNode;\n          if (protocols && !Array.isArray(protocols) && 'object' === _typeof(protocols)) {\n            // accept the \"options\" Object as the 2nd argument\n            options = protocols;\n            protocols = null;\n            if (typeof options.protocol === 'string' || Array.isArray(options.protocol)) {\n              protocols = options.protocol;\n            }\n          }\n          if (!options) options = {};\n          if (options.objectMode === undefined) {\n            options.objectMode = !(options.binary === true || options.binary === undefined);\n          }\n          var proxy = buildProxy(options, socketWrite, socketEnd);\n          if (!options.objectMode) {\n            proxy._writev = writev;\n          }\n\n          // browser only: sets the maximum socket buffer size before throttling\n          var bufferSize = options.browserBufferSize || 1024 * 512;\n\n          // browser only: how long to wait when throttling\n          var bufferTimeout = options.browserBufferTimeout || 1000;\n\n          // use existing WebSocket object that was passed in\n          if (_typeof(target) === 'object') {\n            socket = target;\n            // otherwise make a new one\n          } else {\n            // special constructor treatment for native websockets in browsers, see\n            // https://github.com/maxogden/websocket-stream/issues/82\n            if (isNative && isBrowser) {\n              socket = new WS(target, protocols);\n            } else {\n              socket = new WS(target, protocols, options);\n            }\n            socket.binaryType = 'arraybuffer';\n          }\n\n          // was already open when passed in\n          if (socket.readyState === socket.OPEN) {\n            stream = proxy;\n          } else {\n            stream = duplexify.obj();\n            socket.onopen = onopen;\n          }\n          stream.socket = socket;\n          socket.onclose = onclose;\n          socket.onerror = onerror;\n          socket.onmessage = onmessage;\n          proxy.on('close', destroy);\n          var coerceToBuffer = !options.objectMode;\n          function socketWriteNode(chunk, enc, next) {\n            // avoid errors, this never happens unless\n            // destroy() is called\n            if (socket.readyState !== socket.OPEN) {\n              next();\n              return;\n            }\n            if (coerceToBuffer && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, 'utf8');\n            }\n            socket.send(chunk, next);\n          }\n          function socketWriteBrowser(chunk, enc, next) {\n            if (socket.bufferedAmount > bufferSize) {\n              setTimeout(socketWriteBrowser, bufferTimeout, chunk, enc, next);\n              return;\n            }\n            if (coerceToBuffer && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, 'utf8');\n            }\n            try {\n              socket.send(chunk);\n            } catch (err) {\n              return next(err);\n            }\n            next();\n          }\n          function socketEnd(done) {\n            socket.close();\n            done();\n          }\n          function onopen() {\n            stream.setReadable(proxy);\n            stream.setWritable(proxy);\n            stream.emit('connect');\n          }\n          function onclose() {\n            stream.end();\n            stream.destroy();\n          }\n          function onerror(err) {\n            stream.destroy(err);\n          }\n          function onmessage(event) {\n            var data = event.data;\n            if (data instanceof ArrayBuffer) data = Buffer.from(data);else data = Buffer.from(data, 'utf8');\n            proxy.push(data);\n          }\n          function destroy() {\n            socket.close();\n          }\n\n          // this is to be enabled only if objectMode is false\n          function writev(chunks, cb) {\n            var buffers = new Array(chunks.length);\n            for (var i = 0; i < chunks.length; i++) {\n              if (typeof chunks[i].chunk === 'string') {\n                buffers[i] = Buffer.from(chunks[i], 'utf8');\n              } else {\n                buffers[i] = chunks[i].chunk;\n              }\n            }\n            this._write(Buffer.concat(buffers), 'binary', cb);\n          }\n          return stream;\n        }\n      }).call(this, require('_process'), typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {});\n    }, {\n      \"_process\": 100,\n      \"duplexify\": 19,\n      \"readable-stream\": 116,\n      \"safe-buffer\": 118,\n      \"ws\": 138\n    }],\n    138: [function (require, module, exports) {\n      var ws = null;\n      if (typeof WebSocket !== 'undefined') {\n        ws = WebSocket;\n      } else if (typeof MozWebSocket !== 'undefined') {\n        ws = MozWebSocket;\n      } else if (typeof window !== 'undefined') {\n        ws = window.WebSocket || window.MozWebSocket;\n      }\n      module.exports = ws;\n    }, {}],\n    139: [function (require, module, exports) {\n      // Returns a wrapper function that returns a wrapped callback\n      // The wrapper function should do some stuff, and return a\n      // presumably different callback function.\n      // This makes sure that own properties are retained, so that\n      // decorations and such are not lost along the way.\n      module.exports = wrappy;\n      function wrappy(fn, cb) {\n        if (fn && cb) return wrappy(fn)(cb);\n        if (typeof fn !== 'function') throw new TypeError('need wrapper function');\n        Object.keys(fn).forEach(function (k) {\n          wrapper[k] = fn[k];\n        });\n        return wrapper;\n        function wrapper() {\n          var args = new Array(arguments.length);\n          for (var i = 0; i < args.length; i++) {\n            args[i] = arguments[i];\n          }\n          var ret = fn.apply(this, args);\n          var cb = args[args.length - 1];\n          if (typeof ret === 'function' && ret !== cb) {\n            Object.keys(cb).forEach(function (k) {\n              ret[k] = cb[k];\n            });\n          }\n          return ret;\n        }\n      }\n    }, {}],\n    140: [function (require, module, exports) {\n      module.exports = extend;\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n      function extend() {\n        var target = {};\n        for (var i = 0; i < arguments.length; i++) {\n          var source = arguments[i];\n          for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n        return target;\n      }\n    }, {}]\n  }, {}, [9])(9);\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! (webpack)/buildin/global.js */ 14), __webpack_require__(/*! @dcloudio/uni-mp-weixin/dist/mp.js */ 15)[\"default\"], __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js */ 12)[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vbXF0dC5qcyJdLCJuYW1lcyI6WyJmIiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsInIiLCJlIiwibiIsInQiLCJvIiwiaSIsImMiLCJyZXF1aXJlIiwidSIsImEiLCJFcnJvciIsImNvZGUiLCJwIiwiY2FsbCIsImxlbmd0aCIsInByb2Nlc3MiLCJnbG9iYWwiLCJFdmVudEVtaXR0ZXIiLCJTdG9yZSIsIm1xdHRQYWNrZXQiLCJXcml0YWJsZSIsImluaGVyaXRzIiwicmVJbnRlcnZhbCIsInZhbGlkYXRpb25zIiwieHRlbmQiLCJkZWJ1ZyIsInNldEltbWVkaWF0ZSIsImNhbGxiYWNrIiwibmV4dFRpY2siLCJkZWZhdWx0Q29ubmVjdE9wdGlvbnMiLCJrZWVwYWxpdmUiLCJyZXNjaGVkdWxlUGluZ3MiLCJwcm90b2NvbElkIiwicHJvdG9jb2xWZXJzaW9uIiwicmVjb25uZWN0UGVyaW9kIiwiY29ubmVjdFRpbWVvdXQiLCJjbGVhbiIsInJlc3Vic2NyaWJlIiwic29ja2V0RXJyb3JzIiwiZXJyb3JzIiwiZGVmYXVsdElkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwic2VuZFBhY2tldCIsImNsaWVudCIsInBhY2tldCIsImNiIiwiZW1pdCIsInJlc3VsdCIsIndyaXRlVG9TdHJlYW0iLCJzdHJlYW0iLCJvcHRpb25zIiwib25jZSIsImZsdXNoIiwicXVldWUiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsIm1lc3NhZ2VJZCIsImZsdXNoVm9sYXRpbGUiLCJ2b2xhdGlsZSIsInN0b3JlQW5kU2VuZCIsImNiU3RvcmVQdXQiLCJjbWQiLCJvdXRnb2luZ1N0b3JlIiwicHV0Iiwic3RvcmVkUGFja2V0IiwiZXJyIiwibm9wIiwiZXJyb3IiLCJNcXR0Q2xpZW50Iiwic3RyZWFtQnVpbGRlciIsImsiLCJ0aGF0IiwicHJvdG9jb2wiLCJ1c2VybmFtZSIsInJlamVjdFVuYXV0aG9yaXplZCIsImNsaWVudElkIiwiY3VzdG9tSGFuZGxlQWNrcyIsImFyZ3VtZW50cyIsImluY29taW5nU3RvcmUiLCJxdWV1ZVFvU1plcm8iLCJ1bmRlZmluZWQiLCJfcmVzdWJzY3JpYmVUb3BpY3MiLCJtZXNzYWdlSWRUb1RvcGljIiwicGluZ1RpbWVyIiwiY29ubmVjdGVkIiwiZGlzY29ubmVjdGluZyIsImNvbm5hY2tUaW1lciIsInJlY29ubmVjdFRpbWVyIiwiX3N0b3JlUHJvY2Vzc2luZyIsIl9wYWNrZXRJZHNEdXJpbmdTdG9yZVByb2Nlc3NpbmciLCJuZXh0SWQiLCJtYXgiLCJmbG9vciIsIm91dGdvaW5nIiwiX2ZpcnN0Q29ubmVjdGlvbiIsIm9uIiwiZGVsaXZlciIsImVudHJ5Iiwic2hpZnQiLCJfc2VuZFBhY2tldCIsImNsZWFyVGltZW91dCIsImNsZWFyIiwiX3NldHVwUmVjb25uZWN0IiwiX3NldHVwU3RyZWFtIiwicHJvdG90eXBlIiwiY29ubmVjdFBhY2tldCIsIndyaXRhYmxlIiwicGFyc2VyIiwiY29tcGxldGVQYXJzZSIsInBhY2tldHMiLCJfY2xlYXJSZWNvbm5lY3QiLCJwdXNoIiwibmV4dFRpY2tXb3JrIiwid29yayIsImRvbmUiLCJfaGFuZGxlUGFja2V0IiwiX3dyaXRlIiwiYnVmIiwiZW5jIiwicGFyc2UiLCJzdHJlYW1FcnJvckhhbmRsZXIiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJwaXBlIiwiY3JlYXRlIiwiYmluZCIsInByb3BlcnRpZXMiLCJhdXRoZW50aWNhdGlvbk1ldGhvZCIsImF1dGhlbnRpY2F0aW9uRGF0YSIsImVuZCIsImF1dGhQYWNrZXQiLCJyZWFzb25Db2RlIiwic2V0TWF4TGlzdGVuZXJzIiwic2V0VGltZW91dCIsIl9jbGVhblVwIiwibWF4aW11bVBhY2tldFNpemUiLCJyZWFzb25TdHJpbmciLCJfaGFuZGxlUHVibGlzaCIsIl9oYW5kbGVBY2siLCJfaGFuZGxlUHVicmVsIiwiX2hhbmRsZUNvbm5hY2siLCJfaGFuZGxlUGluZ3Jlc3AiLCJfaGFuZGxlRGlzY29ubmVjdCIsIl9jaGVja0Rpc2Nvbm5lY3RpbmciLCJwdWJsaXNoIiwidG9waWMiLCJvcHRzIiwiZGVmYXVsdE9wdHMiLCJxb3MiLCJyZXRhaW4iLCJkdXAiLCJwYXlsb2FkIiwiX25leHRJZCIsInRvcGljQWxpYXMiLCJ0b3BpY0FsaWFzTWF4aW11bSIsIl9zdG9yZVBhY2tldCIsInN1YnNjcmliZSIsImFyZ3MiLCJBcnJheSIsInN1YnMiLCJvYmoiLCJwb3AiLCJpbnZhbGlkVG9waWMiLCJ2ZXJzaW9uIiwidmFsaWRhdGVUb3BpY3MiLCJubCIsInJhcCIsInJoIiwiaXNBcnJheSIsImhhc093blByb3BlcnR5IiwiY3VycmVudE9wdHMiLCJzdWJzY3JpcHRpb25zIiwidG9waWNzIiwic3ViIiwiZ3JhbnRlZCIsInVuc3Vic2NyaWJlIiwidW5zdWJzY3JpcHRpb25zIiwiZm9yY2UiLCJjbG9zZVN0b3JlcyIsImRpc2Nvbm5lY3RlZCIsImNsb3NlIiwiX2RlZmVycmVkUmVjb25uZWN0IiwiZmluaXNoIiwicmVtb3ZlT3V0Z29pbmdNZXNzYWdlIiwiZGVsIiwicmVjb25uZWN0IiwiX3JlY29ubmVjdCIsInJlY29ubmVjdGluZyIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImZvcmNlZCIsImRlc3Ryb3kiLCJyZW1vdmVMaXN0ZW5lciIsIl9zaGlmdFBpbmdJbnRlcnZhbCIsIl9zZXR1cFBpbmdUaW1lciIsInBpbmdSZXNwIiwiX2NoZWNrUGluZyIsInJlc2NoZWR1bGUiLCJyYyIsInJldHVybkNvZGUiLCJzZXJ2ZXJLZWVwQWxpdmUiLCJfb25Db25uZWN0IiwidmFsaWRSZWFzb25Db2RlcyIsImluZGV4T2YiLCJoYW5kbGVNZXNzYWdlIiwidHlwZSIsInJlc3BvbnNlIiwicHViYWNrUkMiLCJwdWJyZWNSQyIsImdyYW50ZWRJIiwiY29tcCIsImdldCIsInB1YiIsImlkIiwiZ2V0TGFzdE1lc3NhZ2VJZCIsIl9yZXN1YnNjcmliZSIsImNvbm5hY2siLCJfcmVzdWJzY3JpYmVUb3BpY3NLZXlzIiwic2Vzc2lvblByZXNlbnQiLCJ0b3BpY0kiLCJyZXN1YnNjcmliZVRvcGljIiwic3RhcnRTdHJlYW1Qcm9jZXNzIiwib3V0U3RvcmUiLCJjcmVhdGVTdHJlYW0iLCJjbGVhclN0b3JlUHJvY2Vzc2luZyIsInJlbW92ZSIsInN0b3JlRGVsaXZlciIsInJlYWQiLCJzdGF0dXMiLCJhbGxQcm9jZXNzZWQiLCJzZWxmIiwid2luZG93IiwiQnVmZmVyIiwiVHJhbnNmb3JtIiwiZHVwbGV4aWZ5IiwiYmFzZTY0IiwibXkiLCJwcm94eSIsImlzSW5pdGlhbGl6ZWQiLCJidWlsZFByb3h5IiwiY2h1bmsiLCJlbmNvZGluZyIsIm5leHQiLCJzZW5kU29ja2V0TWVzc2FnZSIsImRhdGEiLCJidWZmZXIiLCJzdWNjZXNzIiwiZmFpbCIsIl9mbHVzaCIsInNvY2tldEVuZCIsImNsb3NlU29ja2V0Iiwic2V0RGVmYXVsdE9wdHMiLCJob3N0bmFtZSIsInBhdGgiLCJ3c09wdGlvbnMiLCJidWlsZFVybCIsInVybCIsInBvcnQiLCJ0cmFuc2Zvcm1Xc1VybCIsImJpbmRFdmVudEhhbmRsZXIiLCJvblNvY2tldE9wZW4iLCJzZXRSZWFkYWJsZSIsInNldFdyaXRhYmxlIiwib25Tb2NrZXRNZXNzYWdlIiwicmVzIiwiYXJyYXkiLCJ0b0J5dGVBcnJheSIsImZyb20iLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIkFycmF5QnVmZmVyIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJvblNvY2tldENsb3NlIiwib25Tb2NrZXRFcnJvciIsImJ1aWxkU3RyZWFtIiwiaG9zdCIsIndlYnNvY2tldFN1YlByb3RvY29sIiwiY29ubmVjdFNvY2tldCIsInByb3RvY29scyIsIm5ldCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJ0bHMiLCJidWlsZEJ1aWxkZXIiLCJtcXR0Q2xpZW50IiwiY29ubmVjdGlvbiIsInNlcnZlcm5hbWUiLCJjb25uZWN0IiwiYXV0aG9yaXplZCIsImhhbmRsZVRMU2Vycm9ycyIsIndlYnNvY2tldCIsInVybE1vZHVsZSIsIldTU19PUFRJT05TIiwiSVNfQlJPV1NFUiIsInRpdGxlIiwicHJvcCIsImNyZWF0ZVdlYlNvY2tldCIsImJyb3dzZXJTdHJlYW1CdWlsZGVyIiwiZG9jdW1lbnQiLCJwYXJzZWQiLCJVUkwiLCJzb2NrZXRUYXNrIiwic2VuZCIsImVyck1zZyIsIm9uT3BlbiIsIm9uTWVzc2FnZSIsIm9uQ2xvc2UiLCJvbkVycm9yIiwid3giLCJfZGVzdHJveSIsImRlc3Ryb3lSZWYiLCJSZWFkYWJsZSIsInN0cmVhbXNPcHRzIiwib2JqZWN0TW9kZSIsImRlZmF1bHRTdG9yZU9wdGlvbnMiLCJNYXAiLCJfaW5mbGlnaHRzIiwic2V0IiwiZGVzdHJveWVkIiwidmFsdWVzIiwidmFsdWUiLCJrZXkiLCJfcmVhZCIsImRlbGV0ZSIsInZhbGlkYXRlVG9waWMiLCJwYXJ0cyIsInNwbGl0IiwibXF0dCIsInRjcCIsInNzbCIsIm1xdHRzIiwid3hzIiwiYWxpIiwiYWxpcyIsIndzIiwid3NzIiwicGFyc2VBdXRoT3B0aW9ucyIsIm1hdGNoZXMiLCJhdXRoIiwibWF0Y2giLCJwYXNzd29yZCIsImJyb2tlclVybCIsIk51bWJlciIsInJlcGxhY2UiLCJxdWVyeSIsImNlcnQiLCJpc1NlY3VyZSIsImZpbHRlciIsImluZGV4IiwiZGVmYXVsdFByb3RvY29sIiwid3JhcHBlciIsInNlcnZlcnMiLCJfcmVjb25uZWN0Q291bnQiLCJieXRlTGVuZ3RoIiwiZnJvbUJ5dGVBcnJheSIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsIlVpbnQ4QXJyYXkiLCJsZW4iLCJjaGFyQ29kZUF0IiwiZ2V0TGVucyIsImI2NCIsInZhbGlkTGVuIiwicGxhY2VIb2xkZXJzTGVuIiwibGVucyIsIl9ieXRlTGVuZ3RoIiwidG1wIiwiYXJyIiwiY3VyQnl0ZSIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJzdGFydCIsIm91dHB1dCIsImpvaW4iLCJleHRyYUJ5dGVzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiaWVlZTc1NCIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIktfTUFYX0xFTkdUSCIsImtNYXhMZW5ndGgiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJjb25zb2xlIiwiX19wcm90b19fIiwiZm9vIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiaXNCdWZmZXIiLCJieXRlT2Zmc2V0IiwiY3JlYXRlQnVmZmVyIiwiUmFuZ2VFcnJvciIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJUeXBlRXJyb3IiLCJhbGxvY1Vuc2FmZSIsIlN5bWJvbCIsInNwZWNpZXMiLCJjb25maWd1cmFibGUiLCJwb29sU2l6ZSIsImZyb21TdHJpbmciLCJpc1ZpZXciLCJmcm9tQXJyYXlMaWtlIiwiaXNJbnN0YW5jZSIsImZyb21BcnJheUJ1ZmZlciIsInZhbHVlT2YiLCJiIiwiZnJvbU9iamVjdCIsInRvUHJpbWl0aXZlIiwiYXNzZXJ0U2l6ZSIsInNpemUiLCJhbGxvYyIsImZpbGwiLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwic2xpY2UiLCJjb3B5IiwibnVtYmVySXNOYU4iLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwib2Zmc2V0IiwieCIsInkiLCJtaW4iLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImxpc3QiLCJwb3MiLCJtdXN0TWF0Y2giLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwibSIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImFwcGx5IiwidG9Mb2NhbGVTdHJpbmciLCJlcXVhbHMiLCJpbnNwZWN0Iiwic3RyIiwidHJpbSIsInRhcmdldCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsInZhbCIsImRpciIsImFycmF5SW5kZXhPZiIsImxhc3RJbmRleE9mIiwiaW5kZXhTaXplIiwiYXJyTGVuZ3RoIiwidmFsTGVuZ3RoIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaiIsImhleFdyaXRlIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VJbnQiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwidG9KU09OIiwiX2FyciIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJvdXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic3ViYXJyYXkiLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsImxpdHRsZUVuZGlhbiIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsImNvcHlXaXRoaW4iLCJJTlZBTElEX0JBU0U2NF9SRSIsImJhc2U2NGNsZWFuIiwidW5pdHMiLCJJbmZpbml0eSIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJoaSIsImxvIiwic3JjIiwiZHN0IiwiY29uc3RydWN0b3IiLCJuYW1lIiwib2JqZWN0VG9TdHJpbmciLCJpc0Jvb2xlYW4iLCJpc051bGwiLCJpc051bGxPclVuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwiaXNSZWdFeHAiLCJyZSIsImlzT2JqZWN0IiwiaXNEYXRlIiwiZCIsImlzRXJyb3IiLCJpc0Z1bmN0aW9uIiwiaXNQcmltaXRpdmUiLCJpc1ZhbHVlIiwiZW5zdXJlVmFsdWUiLCJlbnN1cmVQbGFpbkZ1bmN0aW9uIiwibm9ybWFsaXplT3B0aW9ucyIsIm1hcCIsIkZ1bmN0aW9uIiwiZGVzYyIsImRncyIsIm92ZXJ3cml0ZURlZmluaXRpb24iLCJyZXNvbHZlQ29udGV4dCIsInByb3BzIiwiaXNQbGFpbkZ1bmN0aW9uIiwiYXNzaWduIiwibm9ybWFsaXplT3B0cyIsImNvbnRhaW5zIiwiZHNjciIsInciLCJncyIsInMiLCJoIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsIkpTT04iLCJzdHJpbmdpZnkiLCJleGVjIiwicGFyc2VGbG9hdCIsIm1zIiwibXNBYnMiLCJhYnMiLCJyb3VuZCIsInBsdXJhbCIsImlzUGx1cmFsIiwibG9nIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2Fsc3RvcmFnZSIsImNvbG9ycyIsIl9fbndqcyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwiV2Via2l0QXBwZWFyYW5jZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsIlJlZ0V4cCIsIiQxIiwibmFtZXNwYWNlIiwiaHVtYW5pemUiLCJkaWZmIiwiY29sb3IiLCJzcGxpY2UiLCJsYXN0QyIsIm5hbWVzcGFjZXMiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImdldEl0ZW0iLCJlbnYiLCJERUJVRyIsImxvY2FsU3RvcmFnZSIsImZvcm1hdHRlcnMiLCJ2Iiwic2V0dXAiLCJjcmVhdGVEZWJ1ZyIsImRlZmF1bHQiLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiZW5hYmxlZCIsImluc3RhbmNlcyIsIm5hbWVzIiwic2tpcHMiLCJzZWxlY3RDb2xvciIsImhhc2giLCJwcmV2VGltZSIsImN1cnIiLCJEYXRlIiwicHJldiIsInVuc2hpZnQiLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJsb2dGbiIsImV4dGVuZCIsImluaXQiLCJkZWxpbWl0ZXIiLCJuZXdEZWJ1ZyIsImluc3RhbmNlIiwidG9OYW1lc3BhY2UiLCJ0ZXN0IiwicmVnZXhwIiwic3Vic3RyaW5nIiwic3RhY2siLCJlb3MiLCJTSUdOQUxfRkxVU0giLCJvbnVuY29yayIsImZuIiwiX2NvcmtlZCIsImF1dG9EZXN0cm95IiwiX2F1dG9EZXN0cm95IiwiZGVzdHJveWVyIiwiX2VuZGVkIiwiX3dyaXRhYmxlU3RhdGUiLCJmaW5pc2hlZCIsInRvU3RyZWFtczIiLCJycyIsImhpZ2hXYXRlck1hcmsiLCJ3cmFwIiwiRHVwbGV4aWZ5IiwicmVhZGFibGUiLCJEdXBsZXgiLCJfd3JpdGFibGUiLCJfcmVhZGFibGUiLCJfcmVhZGFibGUyIiwiX2ZvcndhcmREZXN0cm95IiwiX2ZvcndhcmRFbmQiLCJfb25kcmFpbiIsIl9kcmFpbmVkIiwiX2ZvcndhcmRpbmciLCJfdW53cml0ZSIsIl91bnJlYWQiLCJjb3JrIiwidW5jb3JrIiwidW5lbmQiLCJvbmRyYWluIiwicmVzdW1lIiwib25yZWFkYWJsZSIsIl9mb3J3YXJkIiwib25lbmQiLCJfcmVhZGFibGVTdGF0ZSIsIl9maW5pc2giLCJwcmVmaW5pc2hlZCIsImVuZGluZyIsIm5vb3AiLCJpc1JlcXVlc3QiLCJzZXRIZWFkZXIiLCJhYm9ydCIsImlzQ2hpbGRQcm9jZXNzIiwic3RkaW8iLCJvbmxlZ2FjeWZpbmlzaCIsIm9uZmluaXNoIiwib25leGl0IiwiZXhpdENvZGUiLCJvbmVycm9yIiwib25jbG9zZSIsImVuZGVkIiwib25yZXF1ZXN0IiwicmVxIiwidG9Qb3NJbnQiLCJvYmpIYXNPd25Qcm9wZXJ0eSIsInNlYXJjaEVsZW1lbnQiLCJmcm9tSW5kZXgiLCJpc05hTiIsIkJvb2xlYW4iLCJpdGVyYXRvclN5bWJvbCIsIml0ZXJhdG9yIiwiaXNBcmd1bWVudHMiLCJjYWxsYWJsZSIsInZhbGlkVmFsdWUiLCJhcnJheUxpa2UiLCJtYXBGbiIsInRoaXNBcmciLCJDb250ZXh0IiwiZ2V0SXRlcmF0b3IiLCJvYmpUb1N0cmluZyIsImlzRnVuY3Rpb25TdHJpbmdUYWciLCJzaWduIiwiTmFOIiwidG9JbnRlZ2VyIiwib2JqUHJvcGVydHlJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm1ldGhvZCIsImRlZlZhbCIsImNvbXBhcmVGbiIsInNvcnQiLCJiYXIiLCJ0cnp5IiwiZGVzdCIsImFGcm9tIiwicHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZSIsImVuc3VyZSIsInNoaW0iLCJudWxsT2JqZWN0IiwicG9seVByb3BzIiwibGV2ZWwiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZGVmaW5lUHJvcGVydGllcyIsImZ1bmN0aW9uIiwib2JqZWN0IiwiX3VuZGVmaW5lZCIsInRhcmdldE9iaiIsIm9wdHMxIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsInBsYWluT2JqZWN0IiwiY3VzdG9tQ3JlYXRlIiwib2JqSXNQcm90b3R5cGVPZiIsImlzUHJvdG90eXBlT2YiLCJudWxsRGVzYyIsInZhbGlkYXRlIiwiaXNOdWxsQmFzZSIsIm51bGxQb2x5ZmlsbCIsInRtcE9iajEiLCJ0bXBPYmoyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaWdub3JlIiwic2VhcmNoU3RyaW5nIiwiSXRlcmF0b3IiLCJBcnJheUl0ZXJhdG9yIiwia2luZCIsIl9yZXNvbHZlIiwiX19raW5kX18iLCJfX2xpc3RfXyIsInRvU3RyaW5nVGFnIiwic29tZSIsIml0ZXJhYmxlIiwibW9kZSIsImRvQnJlYWsiLCJicm9rZW4iLCJjaGFyIiwiU3RyaW5nSXRlcmF0b3IiLCJhdXRvQmluZCIsImNvbnRleHQiLCJfX2NvbnRleHRfXyIsIl9fbmV4dEluZGV4X18iLCJfb25BZGQiLCJfb25EZWxldGUiLCJfb25DbGVhciIsIl9uZXh0IiwiX19yZWRvX18iLCJfdW5CaW5kIiwiX2NyZWF0ZVJlc3VsdCIsIm9mZiIsInJlZG8iLCJfX2xlbmd0aF9fIiwiaXNJdGVyYWJsZSIsImVudHJpZXMiLCJoYXMiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsImtpbmRzIiwidW5CaW5kIiwiTWFwSXRlcmF0b3IiLCJfX21hcEtleXNEYXRhX18iLCJfX3ZhbHVlc19fIiwiX19tYXBWYWx1ZXNEYXRhX18iLCJlSW5kZXhPZiIsImVlIiwiZm9yT2YiLCJpc05hdGl2ZSIsIk1hcFBvbHkiLCJ2YWxpZFR5cGVzIiwic3ltYm9sIiwib2JqUHJvdG90eXBlIiwiY3JlYXRlZCIsInBvc3RmaXgiLCJpZTExQnVnV29ya2Fyb3VuZCIsIk5hdGl2ZVN5bWJvbCIsIlN5bWJvbFBvbHlmaWxsIiwiaGFzSW5zdGFuY2UiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJzZWFyY2giLCJ1bnNjb3BhYmxlcyIsInZhbGlkYXRlU3ltYm9sIiwicmVnaXN0cnkiLCJmb3IiLCJrZXlGb3IiLCJnZW5lcmF0ZU5hbWUiLCJzZXR1cFN0YW5kYXJkU3ltYm9scyIsInNldHVwU3ltYm9sUmVnaXN0cnkiLCJIaWRkZW5TeW1ib2wiLCJpc05hdGl2ZVNhZmUiLCJkZXNjcmlwdGlvbiIsIl9fZGVzY3JpcHRpb25fXyIsIl9fbmFtZV9fIiwiZGVzY3JpcHRvciIsIm1ldGhvZHMiLCJkZXNjcmlwdG9ycyIsImJhc2UiLCJsaXN0ZW5lciIsIl9fZWVfXyIsIl9fZWVPbmNlTGlzdGVuZXJfXyIsImxpc3RlbmVycyIsImNhbmRpZGF0ZSIsImwiLCJvYmplY3RDcmVhdGUiLCJvYmplY3RDcmVhdGVQb2x5ZmlsbCIsIm9iamVjdEtleXMiLCJvYmplY3RLZXlzUG9seWZpbGwiLCJmdW5jdGlvbkJpbmRQb2x5ZmlsbCIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsImhhc0RlZmluZVByb3BlcnR5IiwiJGdldE1heExpc3RlbmVycyIsImdldE1heExpc3RlbmVycyIsImVtaXROb25lIiwiaGFuZGxlciIsImlzRm4iLCJhcnJheUNsb25lIiwiZW1pdE9uZSIsImFyZzEiLCJlbWl0VHdvIiwiYXJnMiIsImVtaXRUaHJlZSIsImFyZzMiLCJlbWl0TWFueSIsImVyIiwiZXZlbnRzIiwiZG9FcnJvciIsIl9hZGRMaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwid2FybmVkIiwiZW1pdHRlciIsImNvdW50Iiwid2FybiIsImFkZExpc3RlbmVyIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwid3JhcHBlZCIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzcGxpY2VPbmUiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwidW53cmFwIiwiZXZsaXN0ZW5lciIsInVud3JhcExpc3RlbmVycyIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJldmVudE5hbWVzIiwiUmVmbGVjdCIsIm93bktleXMiLCJwcm90byIsIkYiLCJuYWl2ZUZhbGxiYWNrIiwiX19nbG9iYWxfXyIsImdsb2JhbFRoaXMiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsInJ0IiwiTE4yIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiaXNTbG93QnVmZmVyIiwidHlwZXMiLCJjb2RlcyIsIkNNRF9TSElGVCIsIkNNRF9NQVNLIiwiRFVQX01BU0siLCJRT1NfTUFTSyIsIlFPU19TSElGVCIsIlJFVEFJTl9NQVNLIiwiTEVOR1RIX01BU0siLCJMRU5HVEhfRklOX01BU0siLCJTRVNTSU9OUFJFU0VOVF9NQVNLIiwiU0VTU0lPTlBSRVNFTlRfSEVBREVSIiwiQ09OTkFDS19IRUFERVIiLCJVU0VSTkFNRV9NQVNLIiwiUEFTU1dPUkRfTUFTSyIsIldJTExfUkVUQUlOX01BU0siLCJXSUxMX1FPU19NQVNLIiwiV0lMTF9RT1NfU0hJRlQiLCJXSUxMX0ZMQUdfTUFTSyIsIkNMRUFOX1NFU1NJT05fTUFTSyIsIkNPTk5FQ1RfSEVBREVSIiwic2Vzc2lvbkV4cGlyeUludGVydmFsIiwid2lsbERlbGF5SW50ZXJ2YWwiLCJyZWNlaXZlTWF4aW11bSIsInJlcXVlc3RSZXNwb25zZUluZm9ybWF0aW9uIiwicmVxdWVzdFByb2JsZW1JbmZvcm1hdGlvbiIsInVzZXJQcm9wZXJ0aWVzIiwicGF5bG9hZEZvcm1hdEluZGljYXRvciIsIm1lc3NhZ2VFeHBpcnlJbnRlcnZhbCIsImNvbnRlbnRUeXBlIiwicmVzcG9uc2VUb3BpYyIsImNvcnJlbGF0aW9uRGF0YSIsIm1heGltdW1Rb1MiLCJyZXRhaW5BdmFpbGFibGUiLCJhc3NpZ25lZENsaWVudElkZW50aWZpZXIiLCJ3aWxkY2FyZFN1YnNjcmlwdGlvbkF2YWlsYWJsZSIsInN1YnNjcmlwdGlvbklkZW50aWZpZXJzQXZhaWxhYmxlIiwic2hhcmVkU3Vic2NyaXB0aW9uQXZhaWxhYmxlIiwicmVzcG9uc2VJbmZvcm1hdGlvbiIsInNlcnZlclJlZmVyZW5jZSIsInN1YnNjcmlwdGlvbklkZW50aWZpZXIiLCJwcm9wZXJ0aWVzQ29kZXMiLCJwcm9wZXJ0aWVzVHlwZXMiLCJnZW5IZWFkZXIiLCJQVUJMSVNIX0hFQURFUiIsIlNVQlNDUklCRV9IRUFERVIiLCJTVUJTQ1JJQkVfT1BUSU9OU19RT1NfTUFTSyIsIlNVQlNDUklCRV9PUFRJT05TX05MX01BU0siLCJTVUJTQ1JJQkVfT1BUSU9OU19OTF9TSElGVCIsIlNVQlNDUklCRV9PUFRJT05TX1JBUF9NQVNLIiwiU1VCU0NSSUJFX09QVElPTlNfUkFQX1NISUZUIiwiU1VCU0NSSUJFX09QVElPTlNfUkhfTUFTSyIsIlNVQlNDUklCRV9PUFRJT05TX1JIX1NISUZUIiwiU1VCU0NSSUJFX09QVElPTlNfUkgiLCJTVUJTQ1JJQkVfT1BUSU9OU19OTCIsIlNVQlNDUklCRV9PUFRJT05TX1JBUCIsIlNVQlNDUklCRV9PUFRJT05TX1FPUyIsIlVOU1VCU0NSSUJFX0hFQURFUiIsIkFDS1MiLCJ1bnN1YmFjayIsInB1YmFjayIsInB1YmNvbXAiLCJwdWJyZWwiLCJwdWJyZWMiLCJTVUJBQ0tfSEVBREVSIiwiVkVSU0lPTjMiLCJWRVJTSU9ONCIsIlZFUlNJT041IiwiUU9TIiwiRU1QVFkiLCJwaW5ncmVxIiwicGluZ3Jlc3AiLCJkaXNjb25uZWN0IiwiRUUiLCJnZW5lcmF0ZSIsIkFjY3VtdWxhdG9yIiwiX2FycmF5IiwiX2kiLCJsZW5ndGhzIiwiRHVwbGV4U3RyZWFtIiwidXRpbCIsIkJ1ZmZlckxpc3QiLCJfYnVmcyIsIl9jYWxsYmFjayIsInBpcGVyIiwib25QaXBlIiwib25VbnBpcGUiLCJhcHBlbmQiLCJfb2Zmc2V0IiwidG90IiwiX3QiLCJfYXBwZW5kQnVmZmVyIiwiYXBwZW5kQnVmZmVyIiwiY29uc3VtZSIsImRzdFN0YXJ0Iiwic3JjU3RhcnQiLCJzcmNFbmQiLCJidWZvZmYiLCJzaGFsbG93U2xpY2UiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImJ1ZmZlcnMiLCJkdXBsaWNhdGUiLCJjYWNoZSIsImdlbmVyYXRlQnVmZmVyIiwiZ2VuZXJhdGVDYWNoZSIsImNhbGNWYXJpYWJsZUJ5dGVJbnRMZW5ndGgiLCJnZW5CdWZWYXJpYWJsZUJ5dGVJbnQiLCJkaWdpdCIsImdlbmVyYXRlNEJ5dGVCdWZmZXIiLCJnZW5lcmF0ZU51bWJlciIsIlBhY2tldCIsImJsIiwiY29uc3RhbnRzIiwiUGFyc2VyIiwib3B0Iiwic2V0dGluZ3MiLCJfc3RhdGVzIiwiX3Jlc2V0U3RhdGUiLCJfbGlzdCIsIl9zdGF0ZUNvdW50ZXIiLCJfcGFyc2VIZWFkZXIiLCJ6ZXJvIiwiX3BhcnNlTGVuZ3RoIiwiX3BhcnNlVmFyQnl0ZU51bSIsIl9wYXJzZVBheWxvYWQiLCJfcG9zIiwiX3BhcnNlQ29ubmVjdCIsIl9wYXJzZUNvbm5hY2siLCJfcGFyc2VQdWJsaXNoIiwiX3BhcnNlQ29uZmlybWF0aW9uIiwiX3BhcnNlU3Vic2NyaWJlIiwiX3BhcnNlU3ViYWNrIiwiX3BhcnNlVW5zdWJzY3JpYmUiLCJfcGFyc2VVbnN1YmFjayIsIl9wYXJzZURpc2Nvbm5lY3QiLCJfcGFyc2VBdXRoIiwiX2VtaXRFcnJvciIsImZsYWdzIiwiX3BhcnNlU3RyaW5nIiwid2lsbCIsIl9wYXJzZU51bSIsIl9wYXJzZVByb3BlcnRpZXMiLCJ3aWxsUHJvcGVydGllcyIsIl9wYXJzZUJ1ZmZlciIsIl9wYXJzZU1lc3NhZ2VJZCIsInN1YnNjcmlwdGlvbiIsIl9wYXJzZUJ5dGUiLCJtYXliZUJ1ZmZlciIsIl9wYXJzZVN0cmluZ1BhaXIiLCJfcGFyc2U0Qnl0ZU51bSIsImZ1bGxJbmZvRmxhZyIsImN1cnJlbnQiLCJwYWRkaW5nIiwiX3BhcnNlQnlUeXBlIiwiY3VycmVudFVzZXJQcm9wZXJ0eSIsIl9uZXdQYWNrZXQiLCJlbXB0eSIsInplcm9CdWYiLCJudW1iZXJzIiwibnVtQ2FjaGUiLCJ3cml0ZU51bWJlciIsIndyaXRlTnVtYmVyQ2FjaGVkIiwidG9HZW5lcmF0ZSIsImNvbmZpcm1hdGlvbiIsInN1YmFjayIsImVtcHR5UGFja2V0Iiwid3JpdGVOdW1iZXJHZW5lcmF0ZWQiLCJwcm9wZXJ0aWVzRGF0YSIsImdldFByb3BlcnRpZXMiLCJwcm92aWRlZFVzZXJuYW1lIiwiaXNTdHJpbmdPckJ1ZmZlciIsIndyaXRlVmFyQnl0ZUludCIsIndyaXRlU3RyaW5nT3JCdWZmZXIiLCJ3cml0ZVN0cmluZyIsImdldFByb3BlcnRpZXNCeU1heGltdW1QYWNrZXRTaXplIiwiaXRvcGljIiwiaXFvcyIsImp0b3BpYyIsImpxb3MiLCJqbmwiLCJqcmFwIiwianJoIiwiam9wdGlvbnMiLCJ1bnN1YnMiLCJ2YXJCeXRlSW50Q2FjaGUiLCJzdHJsZW4iLCJ3cml0ZVN0cmluZ1BhaXIiLCJudW1iZXIiLCJ3cml0ZTRCeXRlTnVtYmVyIiwidG9Xcml0ZSIsIndyaXRlUHJvcGVydGllcyIsInByb3BlcnRpZXNMZW5ndGgiLCJnZXRMZW5ndGhQcm9wZXJ0eSIsInJlZHVjZSIsInByb3BOYW1lIiwicHJvcExlbmd0aCIsInByb3BlcnRpZXNMZW5ndGhMZW5ndGgiLCJtYXlFbXB0eVByb3BzIiwiY3VycmVudE1heUVtcHR5UHJvcCIsImJ1Zk9yU3RyaW5nIiwiZmllbGQiLCJ3cmFwcHkiLCJzdHJpY3QiLCJvbmNlU3RyaWN0IiwiY2FsbGVkIiwib25jZUVycm9yIiwiYWZ0ZXJUaWNrT25lIiwiYWZ0ZXJUaWNrVHdvIiwiYWZ0ZXJUaWNrVGhyZWUiLCJhZnRlclRpY2siLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJydW4iLCJJdGVtIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwicm9vdCIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwiZnJlZUdsb2JhbCIsInB1bnljb2RlIiwibWF4SW50IiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImJhc2VNaW51c1RNaW4iLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJtYXBEb21haW4iLCJsYWJlbHMiLCJlbmNvZGVkIiwidWNzMmRlY29kZSIsImNvdW50ZXIiLCJleHRyYSIsInVjczJlbmNvZGUiLCJiYXNpY1RvRGlnaXQiLCJkaWdpdFRvQmFzaWMiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImRlY29kZSIsImlucHV0IiwiaW5wdXRMZW5ndGgiLCJiaWFzIiwiYmFzaWMiLCJvbGRpIiwiYmFzZU1pbnVzVCIsImVuY29kZSIsImhhbmRsZWRDUENvdW50IiwiYmFzaWNMZW5ndGgiLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsInRvVW5pY29kZSIsInRvQVNDSUkiLCJhbWQiLCJxcyIsInNlcCIsImVxIiwibWF4S2V5cyIsImlkeCIsImtzdHIiLCJ2c3RyIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwieHMiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJrcyIsImVuY29kZVVSSUNvbXBvbmVudCIsInBuYSIsImFsbG93SGFsZk9wZW4iLCJvbkVuZE5UIiwiUGFzc1Rocm91Z2giLCJfdHJhbnNmb3JtIiwiUmVhZGFibGVTdGF0ZSIsIkVFbGlzdGVuZXJDb3VudCIsIlN0cmVhbSIsIk91clVpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwiX2lzVWludDhBcnJheSIsImRlYnVnVXRpbCIsImRlYnVnbG9nIiwiZGVzdHJveUltcGwiLCJTdHJpbmdEZWNvZGVyIiwia1Byb3h5RXZlbnRzIiwiZXZlbnQiLCJpc0R1cGxleCIsInJlYWRhYmxlT2JqZWN0TW9kZSIsImh3bSIsInJlYWRhYmxlSHdtIiwicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwiZGVmYXVsdEh3bSIsInBpcGVzIiwicGlwZXNDb3VudCIsImZsb3dpbmciLCJlbmRFbWl0dGVkIiwicmVhZGluZyIsInN5bmMiLCJuZWVkUmVhZGFibGUiLCJlbWl0dGVkUmVhZGFibGUiLCJyZWFkYWJsZUxpc3RlbmluZyIsInJlc3VtZVNjaGVkdWxlZCIsImRlZmF1bHRFbmNvZGluZyIsImF3YWl0RHJhaW4iLCJyZWFkaW5nTW9yZSIsImRlY29kZXIiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95Iiwic2tpcENodW5rQ2hlY2siLCJyZWFkYWJsZUFkZENodW5rIiwiYWRkVG9Gcm9udCIsIm9uRW9mQ2h1bmsiLCJjaHVua0ludmFsaWQiLCJhZGRDaHVuayIsIm1heWJlUmVhZE1vcmUiLCJuZWVkTW9yZURhdGEiLCJlbWl0UmVhZGFibGUiLCJpc1BhdXNlZCIsInNldEVuY29kaW5nIiwiTUFYX0hXTSIsImNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrIiwiaG93TXVjaFRvUmVhZCIsImhlYWQiLCJuT3JpZyIsImVuZFJlYWRhYmxlIiwiZG9SZWFkIiwiZnJvbUxpc3QiLCJlbWl0UmVhZGFibGVfIiwiZmxvdyIsIm1heWJlUmVhZE1vcmVfIiwicGlwZU9wdHMiLCJkb0VuZCIsInN0ZG91dCIsInN0ZGVyciIsImVuZEZuIiwidW5waXBlIiwib251bnBpcGUiLCJ1bnBpcGVJbmZvIiwiaGFzVW5waXBlZCIsImNsZWFudXAiLCJwaXBlT25EcmFpbiIsImNsZWFuZWRVcCIsIm9uZGF0YSIsIm5lZWREcmFpbiIsImluY3JlYXNlZEF3YWl0RHJhaW4iLCJwYXVzZSIsImRlc3RzIiwiZXYiLCJuUmVhZGluZ05leHRUaWNrIiwicmVzdW1lXyIsIl90aGlzIiwicGF1c2VkIiwiX2Zyb21MaXN0IiwiZnJvbUxpc3RQYXJ0aWFsIiwiaGFzU3RyaW5ncyIsImNvcHlGcm9tQnVmZmVyU3RyaW5nIiwiY29weUZyb21CdWZmZXIiLCJuYiIsInRhaWwiLCJlbmRSZWFkYWJsZU5UIiwiYWZ0ZXJUcmFuc2Zvcm0iLCJ0cyIsIl90cmFuc2Zvcm1TdGF0ZSIsInRyYW5zZm9ybWluZyIsIndyaXRlY2IiLCJ3cml0ZWNodW5rIiwibmVlZFRyYW5zZm9ybSIsIndyaXRlZW5jb2RpbmciLCJ0cmFuc2Zvcm0iLCJwcmVmaW5pc2giLCJfdGhpczIiLCJlcnIyIiwiV3JpdGVSZXEiLCJDb3JrZWRSZXF1ZXN0Iiwib25Db3JrZWRGaW5pc2giLCJhc3luY1dyaXRlIiwiV3JpdGFibGVTdGF0ZSIsImludGVybmFsVXRpbCIsImRlcHJlY2F0ZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIndyaXRhYmxlSHdtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwiZmluYWxDYWxsZWQiLCJub0RlY29kZSIsImRlY29kZVN0cmluZ3MiLCJ3cml0aW5nIiwiY29ya2VkIiwiYnVmZmVyUHJvY2Vzc2luZyIsIm9ud3JpdGUiLCJ3cml0ZWxlbiIsImJ1ZmZlcmVkUmVxdWVzdCIsImxhc3RCdWZmZXJlZFJlcXVlc3QiLCJwZW5kaW5nY2IiLCJlcnJvckVtaXR0ZWQiLCJidWZmZXJlZFJlcXVlc3RDb3VudCIsImNvcmtlZFJlcXVlc3RzRnJlZSIsImdldEJ1ZmZlciIsIl8iLCJyZWFsSGFzSW5zdGFuY2UiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZmluYWwiLCJfZmluYWwiLCJ3cml0ZUFmdGVyRW5kIiwidmFsaWRDaHVuayIsInZhbGlkIiwiaXNCdWYiLCJ3cml0ZU9yQnVmZmVyIiwiY2xlYXJCdWZmZXIiLCJzZXREZWZhdWx0RW5jb2RpbmciLCJkZWNvZGVDaHVuayIsIm5ld0NodW5rIiwibGFzdCIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwibmVlZCIsImNvcmtSZXEiLCJfY2xhc3NDYWxsQ2hlY2siLCJDb25zdHJ1Y3RvciIsImNvcHlCdWZmZXIiLCJjdXN0b20iLCJyZWFkYWJsZURlc3Ryb3llZCIsIndyaXRhYmxlRGVzdHJveWVkIiwiZW1pdEVycm9yTlQiLCJfbm9ybWFsaXplRW5jb2RpbmciLCJyZXRyaWVkIiwibm9ybWFsaXplRW5jb2RpbmciLCJuZW5jIiwidGV4dCIsInV0ZjE2VGV4dCIsInV0ZjE2RW5kIiwiZmlsbExhc3QiLCJ1dGY4RmlsbExhc3QiLCJiYXNlNjRUZXh0IiwiYmFzZTY0RW5kIiwic2ltcGxlV3JpdGUiLCJzaW1wbGVFbmQiLCJsYXN0TmVlZCIsImxhc3RUb3RhbCIsImxhc3RDaGFyIiwidXRmOEVuZCIsInV0ZjhUZXh0IiwidXRmOENoZWNrQnl0ZSIsImJ5dGUiLCJ1dGY4Q2hlY2tJbmNvbXBsZXRlIiwidXRmOENoZWNrRXh0cmFCeXRlcyIsInRvdGFsIiwiUmVJbnRlcnZhbCIsImludGVydmFsIiwiX2FyZ3MiLCJfaW50ZXJ2YWwiLCJjb3B5UHJvcHMiLCJTYWZlQnVmZmVyIiwiX2R1cGxleFN0YXRlIiwiZ2V0U3RhdGVMZW5ndGgiLCJjbGVhckltbWVkaWF0ZSIsImltbWVkaWF0ZUlkcyIsIm5leHRJbW1lZGlhdGVJZCIsIlRpbWVvdXQiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIml0ZW0iLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0Iiwib25OZXh0VGljayIsImlzUHJvdG90eXBlIiwic3RyaW5nQ29lcmNlIiwidG9TaG9ydFN0cmluZyIsInJlc29sdmVNZXNzYWdlIiwiZGVmYXVsdE1lc3NhZ2UiLCJpbnB1dE9wdGlvbnMiLCJpc09wdGlvbmFsIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3IyIiwic2FmZVRvU3RyaW5nIiwicmVOZXdMaW5lIiwicG9zc2libGVUeXBlcyIsInJlc29sdmVFeGNlcHRpb24iLCJpcyIsImNsYXNzUmUiLCJmdW5jdGlvblRvU3RyaW5nIiwidmFsdWVUb1N0cmluZyIsInVybFBhcnNlIiwicmVzb2x2ZSIsInVybFJlc29sdmUiLCJyZXNvbHZlT2JqZWN0IiwidXJsUmVzb2x2ZU9iamVjdCIsInVybEZvcm1hdCIsIlVybCIsInNsYXNoZXMiLCJwYXRobmFtZSIsImhyZWYiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwidW5zYWZlUHJvdG9jb2wiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwicXVlcnlzdHJpbmciLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJxdWVyeUluZGV4Iiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzbGFzaFJlZ2V4IiwicmVzdCIsInNpbXBsZVBhdGgiLCJsb3dlclByb3RvIiwiaG9zdEVuZCIsImhlYyIsImF0U2lnbiIsInBhcnNlSG9zdCIsImlwdjZIb3N0bmFtZSIsImhvc3RwYXJ0cyIsInBhcnQiLCJuZXdwYXJ0IiwidmFsaWRQYXJ0cyIsIm5vdEhvc3QiLCJiaXQiLCJhZSIsImVzYyIsImVzY2FwZSIsInFtIiwiY2hhckF0Iiwic291cmNlIiwicmVsYXRpdmUiLCJyZWwiLCJ0a2V5cyIsInRrIiwidGtleSIsInJrZXlzIiwicmsiLCJya2V5IiwicmVsUGF0aCIsImlzU291cmNlQWJzIiwiaXNSZWxBYnMiLCJtdXN0RW5kQWJzIiwicmVtb3ZlQWxsRG90cyIsInNyY1BhdGgiLCJwc3ljaG90aWMiLCJhdXRoSW5Ib3N0IiwiaGFzVHJhaWxpbmdTbGFzaCIsInVwIiwiaXNBYnNvbHV0ZSIsIm1zZyIsImNvbmZpZyIsImRlcHJlY2F0ZWQiLCJ0cmFjZSIsImZvcm1hdFJlZ0V4cCIsIm9iamVjdHMiLCJub0RlcHJlY2F0aW9uIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJkZWJ1Z3MiLCJkZWJ1Z0Vudmlyb24iLCJOT0RFX0RFQlVHIiwidG9VcHBlckNhc2UiLCJwaWQiLCJjdHgiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiZGVwdGgiLCJzaG93SGlkZGVuIiwiX2V4dGVuZCIsImN1c3RvbUluc3BlY3QiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJzdHlsZXMiLCJzdHlsZVR5cGUiLCJhcnJheVRvSGFzaCIsInJlY3Vyc2VUaW1lcyIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsInZpc2libGVLZXlzIiwiZm9ybWF0RXJyb3IiLCJicmFjZXMiLCJ0b1VUQ1N0cmluZyIsImZvcm1hdEFycmF5IiwiZm9ybWF0UHJvcGVydHkiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsInNpbXBsZSIsImxpbmUiLCJudW1MaW5lc0VzdCIsImN1ciIsImFyIiwicGFkIiwibW9udGhzIiwidGltZXN0YW1wIiwidGltZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJvcmlnaW4iLCJhZGQiLCJXUyIsIldlYlNvY2tldFN0cmVhbSIsInNvY2tldFdyaXRlIiwic29ja2V0IiwiaXNCcm93c2VyIiwiV2ViU29ja2V0Iiwic29ja2V0V3JpdGVCcm93c2VyIiwic29ja2V0V3JpdGVOb2RlIiwiYmluYXJ5IiwiYnVmZmVyU2l6ZSIsImJyb3dzZXJCdWZmZXJTaXplIiwiYnVmZmVyVGltZW91dCIsImJyb3dzZXJCdWZmZXJUaW1lb3V0IiwiYmluYXJ5VHlwZSIsInJlYWR5U3RhdGUiLCJPUEVOIiwib25vcGVuIiwib25tZXNzYWdlIiwiY29lcmNlVG9CdWZmZXIiLCJidWZmZXJlZEFtb3VudCIsImNodW5rcyIsIk1veldlYlNvY2tldCJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxDQUFDLFVBQVNBLENBQUMsRUFBQztFQUFDLElBQUcsT0FBYyx1QkFBUEMsT0FBTyxPQUFHLFFBQVEsSUFBRSxPQUFPQyxNQUFNLEtBQUcsV0FBVyxFQUFDO0lBQUNBLE1BQU0sQ0FBQ0QsT0FBTyxHQUFDRCxDQUFDLEVBQUU7RUFBQSxDQUFDLE1BQUssSUFBRyxJQUFzQyxFQUFDO0lBQUNHLGlDQUFPLEVBQUUsb0NBQUNILENBQUM7QUFBQTtBQUFBO0FBQUEsb0dBQUM7RUFBQSxDQUFDLE1BQUksVUFBaUs7QUFBQSxDQUFDLEVBQUUsWUFBVTtFQUFDLElBQUlHLE1BQU0sRUFBQ0QsTUFBTSxFQUFDRCxPQUFPO0VBQUMsT0FBUSxZQUFVO0lBQUMsU0FBU0csQ0FBQyxDQUFDQyxDQUFDLEVBQUNDLENBQUMsRUFBQ0MsQ0FBQyxFQUFDO01BQUMsU0FBU0MsQ0FBQyxDQUFDQyxDQUFDLEVBQUNULENBQUMsRUFBQztRQUFDLElBQUcsQ0FBQ00sQ0FBQyxDQUFDRyxDQUFDLENBQUMsRUFBQztVQUFDLElBQUcsQ0FBQ0osQ0FBQyxDQUFDSSxDQUFDLENBQUMsRUFBQztZQUFDLElBQUlDLENBQUMsR0FBQyxVQUFVLElBQUUsT0FBT0MsT0FBTyxJQUFFQSxPQUFPO1lBQUMsSUFBRyxDQUFDWCxDQUFDLElBQUVVLENBQUMsRUFBQyxPQUFPQSxPQUFDLENBQUNELENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztZQUFDLElBQUdHLENBQUMsRUFBQyxPQUFP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LFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLENBQ1Q7O1FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O1FBRUE7UUFDQSxTQUFTSCxTQUFTLEdBQUc7VUFDcEI7VUFDQTtVQUNBO1VBQ0EsSUFBSSxPQUFPdlksTUFBTSxLQUFLLFdBQVcsSUFBSUEsTUFBTSxDQUFDNU4sT0FBTyxLQUFLNE4sTUFBTSxDQUFDNU4sT0FBTyxDQUFDa00sSUFBSSxLQUFLLFVBQVUsSUFBSTBCLE1B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QUssSUFBSTFjLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRzRFLFNBQVMsQ0FBQ25FLE1BQU0sRUFBRVQsQ0FBQyxFQUFFLEVBQUU7VUFDdkMsSUFBSXEvQyxNQUFNLEdBQUd6NkMsU0FBUyxDQUFDNUUsQ0FBQyxDQUFDO1VBRXpCLEtBQUssSUFBSWdVLEdBQUcsSUFBSXFyQyxNQUFNLEVBQUU7WUFDcEIsSUFBSTcwQyxjQUFjLENBQUNoSyxJQUFJLENBQUM2K0MsTUFBTSxFQUFFcnJDLEdBQUcsQ0FBQyxFQUFFO2NBQ2xDMEksTUFBTSxDQUFDMUksR0FBRyxDQUFDLEdBQUdxckMsTUFBTSxDQUFDcnJDLEdBQUcsQ0FBQztZQUM3QjtVQUNKO1FBQ0o7UUFFQSxPQUFPMEksTUFBTTtNQUNqQjtJQUVBLENBQUMsRUFBQyxDQUFDLENBQUM7RUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNqQixDQUFDLENBQUMsQyIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLm1xdHQgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgU3RvcmUgPSByZXF1aXJlKCcuL3N0b3JlJylcbnZhciBtcXR0UGFja2V0ID0gcmVxdWlyZSgnbXF0dC1wYWNrZXQnKVxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuV3JpdGFibGVcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciByZUludGVydmFsID0gcmVxdWlyZSgncmVpbnRlcnZhbCcpXG52YXIgdmFsaWRhdGlvbnMgPSByZXF1aXJlKCcuL3ZhbGlkYXRpb25zJylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21xdHRqczpjbGllbnQnKVxudmFyIHNldEltbWVkaWF0ZSA9IGdsb2JhbC5zZXRJbW1lZGlhdGUgfHwgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIC8vIHdvcmtzIGluIG5vZGUgdjAuOFxuICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKVxufVxudmFyIGRlZmF1bHRDb25uZWN0T3B0aW9ucyA9IHtcbiAga2VlcGFsaXZlOiA2MCxcbiAgcmVzY2hlZHVsZVBpbmdzOiB0cnVlLFxuICBwcm90b2NvbElkOiAnTVFUVCcsXG4gIHByb3RvY29sVmVyc2lvbjogNCxcbiAgcmVjb25uZWN0UGVyaW9kOiAxMDAwLFxuICBjb25uZWN0VGltZW91dDogMzAgKiAxMDAwLFxuICBjbGVhbjogdHJ1ZSxcbiAgcmVzdWJzY3JpYmU6IHRydWVcbn1cblxudmFyIHNvY2tldEVycm9ycyA9IFtcbiAgJ0VDT05OUkVGVVNFRCcsXG4gICdFQUREUklOVVNFJyxcbiAgJ0VDT05OUkVTRVQnLFxuICAnRU5PVEZPVU5EJ1xuXVxuXG4vLyBPdGhlciBTb2NrZXQgRXJyb3JzOiBFQUREUklOVVNFLCBFQ09OTlJFU0VULCBFTk9URk9VTkQuXG5cbnZhciBlcnJvcnMgPSB7XG4gIDA6ICcnLFxuICAxOiAnVW5hY2NlcHRhYmxlIHByb3RvY29sIHZlcnNpb24nLFxuICAyOiAnSWRlbnRpZmllciByZWplY3RlZCcsXG4gIDM6ICdTZXJ2ZXIgdW5hdmFpbGFibGUnLFxuICA0OiAnQmFkIHVzZXJuYW1lIG9yIHBhc3N3b3JkJyxcbiAgNTogJ05vdCBhdXRob3JpemVkJyxcbiAgMTY6ICdObyBtYXRjaGluZyBzdWJzY3JpYmVycycsXG4gIDE3OiAnTm8gc3Vic2NyaXB0aW9uIGV4aXN0ZWQnLFxuICAxMjg6ICdVbnNwZWNpZmllZCBlcnJvcicsXG4gIDEyOTogJ01hbGZvcm1lZCBQYWNrZXQnLFxuICAxMzA6ICdQcm90b2NvbCBFcnJvcicsXG4gIDEzMTogJ0ltcGxlbWVudGF0aW9uIHNwZWNpZmljIGVycm9yJyxcbiAgMTMyOiAnVW5zdXBwb3J0ZWQgUHJvdG9jb2wgVmVyc2lvbicsXG4gIDEzMzogJ0NsaWVudCBJZGVudGlmaWVyIG5vdCB2YWxpZCcsXG4gIDEzNDogJ0JhZCBVc2VyIE5hbWUgb3IgUGFzc3dvcmQnLFxuICAxMzU6ICdOb3QgYXV0aG9yaXplZCcsXG4gIDEzNjogJ1NlcnZlciB1bmF2YWlsYWJsZScsXG4gIDEzNzogJ1NlcnZlciBidXN5JyxcbiAgMTM4OiAnQmFubmVkJyxcbiAgMTM5OiAnU2VydmVyIHNodXR0aW5nIGRvd24nLFxuICAxNDA6ICdCYWQgYXV0aGVudGljYXRpb24gbWV0aG9kJyxcbiAgMTQxOiAnS2VlcCBBbGl2ZSB0aW1lb3V0JyxcbiAgMTQyOiAnU2Vzc2lvbiB0YWtlbiBvdmVyJyxcbiAgMTQzOiAnVG9waWMgRmlsdGVyIGludmFsaWQnLFxuICAxNDQ6ICdUb3BpYyBOYW1lIGludmFsaWQnLFxuICAxNDU6ICdQYWNrZXQgaWRlbnRpZmllciBpbiB1c2UnLFxuICAxNDY6ICdQYWNrZXQgSWRlbnRpZmllciBub3QgZm91bmQnLFxuICAxNDc6ICdSZWNlaXZlIE1heGltdW0gZXhjZWVkZWQnLFxuICAxNDg6ICdUb3BpYyBBbGlhcyBpbnZhbGlkJyxcbiAgMTQ5OiAnUGFja2V0IHRvbyBsYXJnZScsXG4gIDE1MDogJ01lc3NhZ2UgcmF0ZSB0b28gaGlnaCcsXG4gIDE1MTogJ1F1b3RhIGV4Y2VlZGVkJyxcbiAgMTUyOiAnQWRtaW5pc3RyYXRpdmUgYWN0aW9uJyxcbiAgMTUzOiAnUGF5bG9hZCBmb3JtYXQgaW52YWxpZCcsXG4gIDE1NDogJ1JldGFpbiBub3Qgc3VwcG9ydGVkJyxcbiAgMTU1OiAnUW9TIG5vdCBzdXBwb3J0ZWQnLFxuICAxNTY6ICdVc2UgYW5vdGhlciBzZXJ2ZXInLFxuICAxNTc6ICdTZXJ2ZXIgbW92ZWQnLFxuICAxNTg6ICdTaGFyZWQgU3Vic2NyaXB0aW9ucyBub3Qgc3VwcG9ydGVkJyxcbiAgMTU5OiAnQ29ubmVjdGlvbiByYXRlIGV4Y2VlZGVkJyxcbiAgMTYwOiAnTWF4aW11bSBjb25uZWN0IHRpbWUnLFxuICAxNjE6ICdTdWJzY3JpcHRpb24gSWRlbnRpZmllcnMgbm90IHN1cHBvcnRlZCcsXG4gIDE2MjogJ1dpbGRjYXJkIFN1YnNjcmlwdGlvbnMgbm90IHN1cHBvcnRlZCdcbn1cblxuZnVuY3Rpb24gZGVmYXVsdElkICgpIHtcbiAgcmV0dXJuICdtcXR0anNfJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnN1YnN0cigyLCA4KVxufVxuXG5mdW5jdGlvbiBzZW5kUGFja2V0IChjbGllbnQsIHBhY2tldCwgY2IpIHtcbiAgZGVidWcoJ3NlbmRQYWNrZXQgOjogcGFja2V0OiAlTycsIHBhY2tldClcbiAgZGVidWcoJ3NlbmRQYWNrZXQgOjogZW1pdHRpbmcgYHBhY2tldHNlbmRgJylcbiAgY2xpZW50LmVtaXQoJ3BhY2tldHNlbmQnLCBwYWNrZXQpXG5cbiAgZGVidWcoJ3NlbmRQYWNrZXQgOjogd3JpdGluZyB0byBzdHJlYW0nKVxuICB2YXIgcmVzdWx0ID0gbXF0dFBhY2tldC53cml0ZVRvU3RyZWFtKHBhY2tldCwgY2xpZW50LnN0cmVhbSwgY2xpZW50Lm9wdGlvbnMpXG4gIGRlYnVnKCdzZW5kUGFja2V0IDo6IHdyaXRlVG9TdHJlYW0gcmVzdWx0ICVzJywgcmVzdWx0KVxuICBpZiAoIXJlc3VsdCAmJiBjYikge1xuICAgIGRlYnVnKCdzZW5kUGFja2V0IDo6IGhhbmRsZSBldmVudHMgb24gYGRyYWluYCBvbmNlIHRocm91Z2ggY2FsbGJhY2suJylcbiAgICBjbGllbnQuc3RyZWFtLm9uY2UoJ2RyYWluJywgY2IpXG4gIH0gZWxzZSBpZiAoY2IpIHtcbiAgICBkZWJ1Zygnc2VuZFBhY2tldCA6OiBpbnZva2luZyBjYicpXG4gICAgY2IoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoIChxdWV1ZSkge1xuICBpZiAocXVldWUpIHtcbiAgICBkZWJ1ZygnZmx1c2g6IHF1ZXVlIGV4aXN0cz8gJWInLCAhIShxdWV1ZSkpXG4gICAgT2JqZWN0LmtleXMocXVldWUpLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2VJZCkge1xuICAgICAgaWYgKHR5cGVvZiBxdWV1ZVttZXNzYWdlSWRdLmNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHF1ZXVlW21lc3NhZ2VJZF0uY2IobmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCcpKVxuICAgICAgICBkZWxldGUgcXVldWVbbWVzc2FnZUlkXVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hWb2xhdGlsZSAocXVldWUpIHtcbiAgaWYgKHF1ZXVlKSB7XG4gICAgZGVidWcoJ2ZsdXNoVm9sYXRpbGUgOjogZGVsZXRpbmcgdm9sYXRpbGUgbWVzc2FnZXMgZnJvbSB0aGUgcXVldWUgYW5kIHNldHRpbmcgdGhlaXIgY2FsbGJhY2tzIGFzIGVycm9yIGZ1bmN0aW9uJylcbiAgICBPYmplY3Qua2V5cyhxdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZUlkKSB7XG4gICAgICBpZiAocXVldWVbbWVzc2FnZUlkXS52b2xhdGlsZSAmJiB0eXBlb2YgcXVldWVbbWVzc2FnZUlkXS5jYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBxdWV1ZVttZXNzYWdlSWRdLmNiKG5ldyBFcnJvcignQ29ubmVjdGlvbiBjbG9zZWQnKSlcbiAgICAgICAgZGVsZXRlIHF1ZXVlW21lc3NhZ2VJZF1cbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlQW5kU2VuZCAoY2xpZW50LCBwYWNrZXQsIGNiLCBjYlN0b3JlUHV0KSB7XG4gIGRlYnVnKCdzdG9yZUFuZFNlbmQgOjogc3RvcmUgcGFja2V0IHdpdGggY21kICVzIHRvIG91dGdvaW5nU3RvcmUnLCBwYWNrZXQuY21kKVxuICBjbGllbnQub3V0Z29pbmdTdG9yZS5wdXQocGFja2V0LCBmdW5jdGlvbiBzdG9yZWRQYWNrZXQgKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYiAmJiBjYihlcnIpXG4gICAgfVxuICAgIGNiU3RvcmVQdXQoKVxuICAgIHNlbmRQYWNrZXQoY2xpZW50LCBwYWNrZXQsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBub3AgKGVycm9yKSB7XG4gIGRlYnVnKCdub3AgOjonLCBlcnJvcilcbn1cblxuLyoqXG4gKiBNcXR0Q2xpZW50IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSAtIHN0cmVhbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGNvbm5lY3Rpb24gb3B0aW9uc1xuICogKHNlZSBDb25uZWN0aW9uI2Nvbm5lY3QpXG4gKi9cbmZ1bmN0aW9uIE1xdHRDbGllbnQgKHN0cmVhbUJ1aWxkZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1xdHRDbGllbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBNcXR0Q2xpZW50KHN0cmVhbUJ1aWxkZXIsIG9wdGlvbnMpXG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgLy8gRGVmYXVsdHNcbiAgZm9yIChrIGluIGRlZmF1bHRDb25uZWN0T3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zW2tdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5vcHRpb25zW2tdID0gZGVmYXVsdENvbm5lY3RPcHRpb25zW2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9uc1trXSA9IG9wdGlvbnNba11cbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnTXF0dENsaWVudCA6OiBvcHRpb25zLnByb3RvY29sJywgb3B0aW9ucy5wcm90b2NvbClcbiAgZGVidWcoJ01xdHRDbGllbnQgOjogb3B0aW9ucy5wcm90b2NvbFZlcnNpb24nLCBvcHRpb25zLnByb3RvY29sVmVyc2lvbilcbiAgZGVidWcoJ01xdHRDbGllbnQgOjogb3B0aW9ucy51c2VybmFtZScsIG9wdGlvbnMudXNlcm5hbWUpXG4gIGRlYnVnKCdNcXR0Q2xpZW50IDo6IG9wdGlvbnMua2VlcGFsaXZlJywgb3B0aW9ucy5rZWVwYWxpdmUpXG4gIGRlYnVnKCdNcXR0Q2xpZW50IDo6IG9wdGlvbnMucmVjb25uZWN0UGVyaW9kJywgb3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QpXG4gIGRlYnVnKCdNcXR0Q2xpZW50IDo6IG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkJywgb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQpXG5cbiAgdGhpcy5vcHRpb25zLmNsaWVudElkID0gKHR5cGVvZiBvcHRpb25zLmNsaWVudElkID09PSAnc3RyaW5nJykgPyBvcHRpb25zLmNsaWVudElkIDogZGVmYXVsdElkKClcblxuICBkZWJ1ZygnTXF0dENsaWVudCA6OiBjbGllbnRJZCcsIHRoaXMub3B0aW9ucy5jbGllbnRJZClcblxuICB0aGlzLm9wdGlvbnMuY3VzdG9tSGFuZGxlQWNrcyA9IChvcHRpb25zLnByb3RvY29sVmVyc2lvbiA9PT0gNSAmJiBvcHRpb25zLmN1c3RvbUhhbmRsZUFja3MpID8gb3B0aW9ucy5jdXN0b21IYW5kbGVBY2tzIDogZnVuY3Rpb24gKCkgeyBhcmd1bWVudHNbM10oMCkgfVxuXG4gIHRoaXMuc3RyZWFtQnVpbGRlciA9IHN0cmVhbUJ1aWxkZXJcblxuICAvLyBJbmZsaWdodCBtZXNzYWdlIHN0b3JhZ2VzXG4gIHRoaXMub3V0Z29pbmdTdG9yZSA9IG9wdGlvbnMub3V0Z29pbmdTdG9yZSB8fCBuZXcgU3RvcmUoKVxuICB0aGlzLmluY29taW5nU3RvcmUgPSBvcHRpb25zLmluY29taW5nU3RvcmUgfHwgbmV3IFN0b3JlKClcblxuICAvLyBTaG91bGQgUW9TIHplcm8gbWVzc2FnZXMgYmUgcXVldWVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgYnJva2VuP1xuICB0aGlzLnF1ZXVlUW9TWmVybyA9IG9wdGlvbnMucXVldWVRb1NaZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5xdWV1ZVFvU1plcm9cblxuICAvLyBtYXAgb2Ygc3Vic2NyaWJlZCB0b3BpY3MgdG8gc3VwcG9ydCByZWNvbm5lY3Rpb25cbiAgdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MgPSB7fVxuXG4gIC8vIG1hcCBvZiBhIHN1YnNjcmliZSBtZXNzYWdlSWQgYW5kIGEgdG9waWNcbiAgdGhpcy5tZXNzYWdlSWRUb1RvcGljID0ge31cblxuICAvLyBQaW5nIHRpbWVyLCBzZXR1cCBpbiBfc2V0dXBQaW5nVGltZXJcbiAgdGhpcy5waW5nVGltZXIgPSBudWxsXG4gIC8vIElzIHRoZSBjbGllbnQgY29ubmVjdGVkP1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXG4gIC8vIEFyZSB3ZSBkaXNjb25uZWN0aW5nP1xuICB0aGlzLmRpc2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAvLyBQYWNrZXQgcXVldWVcbiAgdGhpcy5xdWV1ZSA9IFtdXG4gIC8vIGNvbm5hY2sgdGltZXJcbiAgdGhpcy5jb25uYWNrVGltZXIgPSBudWxsXG4gIC8vIFJlY29ubmVjdCB0aW1lclxuICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbFxuICAvLyBJcyBwcm9jZXNzaW5nIHN0b3JlP1xuICB0aGlzLl9zdG9yZVByb2Nlc3NpbmcgPSBmYWxzZVxuICAvLyBQYWNrZXQgSWRzIGFyZSBwdXQgaW50byB0aGUgc3RvcmUgZHVyaW5nIHN0b3JlIHByb2Nlc3NpbmdcbiAgdGhpcy5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nID0ge31cbiAgLyoqXG4gICAqIE1lc3NhZ2VJRHMgc3RhcnRpbmcgd2l0aCAxXG4gICAqIGVuc3VyZSB0aGF0IG5leHRJZCBpcyBtaW4uIDEsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbXF0dGpzL01RVFQuanMvaXNzdWVzLzgxMFxuICAgKi9cbiAgdGhpcy5uZXh0SWQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2NTUzNSkpXG5cbiAgLy8gSW5mbGlnaHQgY2FsbGJhY2tzXG4gIHRoaXMub3V0Z29pbmcgPSB7fVxuXG4gIC8vIFRydWUgaWYgY29ubmVjdGlvbiBpcyBmaXJzdCB0aW1lLlxuICB0aGlzLl9maXJzdENvbm5lY3Rpb24gPSB0cnVlXG5cbiAgLy8gU2VuZCBxdWV1ZWQgcGFja2V0c1xuICB0aGlzLm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWVcblxuICAgIGZ1bmN0aW9uIGRlbGl2ZXIgKCkge1xuICAgICAgdmFyIGVudHJ5ID0gcXVldWUuc2hpZnQoKVxuICAgICAgZGVidWcoJ2RlbGl2ZXIgOjogZW50cnkgJW8nLCBlbnRyeSlcbiAgICAgIHZhciBwYWNrZXQgPSBudWxsXG5cbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHBhY2tldCA9IGVudHJ5LnBhY2tldFxuICAgICAgZGVidWcoJ2RlbGl2ZXIgOjogY2FsbCBfc2VuZFBhY2tldCBmb3IgJW8nLCBwYWNrZXQpXG4gICAgICB0aGF0Ll9zZW5kUGFja2V0KFxuICAgICAgICBwYWNrZXQsXG4gICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZW50cnkuY2IpIHtcbiAgICAgICAgICAgIGVudHJ5LmNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsaXZlcigpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBkZWJ1ZygnY29ubmVjdCA6OiBzZW5kaW5nIHF1ZXVlZCBwYWNrZXRzJylcbiAgICBkZWxpdmVyKClcbiAgfSlcblxuICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1ZygnY2xvc2UgOjogY29ubmVjdGVkIHNldCB0byBgZmFsc2VgJylcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICBkZWJ1ZygnY2xvc2UgOjogY2xlYXJpbmcgY29ubmFja1RpbWVyJylcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uYWNrVGltZXIpXG5cbiAgICBkZWJ1ZygnY2xvc2UgOjogY2xlYXJpbmcgcGluZyB0aW1lcicpXG4gICAgaWYgKHRoYXQucGluZ1RpbWVyICE9PSBudWxsKSB7XG4gICAgICB0aGF0LnBpbmdUaW1lci5jbGVhcigpXG4gICAgICB0aGF0LnBpbmdUaW1lciA9IG51bGxcbiAgICB9XG5cbiAgICBkZWJ1ZygnY2xvc2UgOjogY2FsbGluZyBfc2V0dXBSZWNvbm5lY3QnKVxuICAgIHRoaXMuX3NldHVwUmVjb25uZWN0KClcbiAgfSlcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICBkZWJ1ZygnTXF0dENsaWVudCA6OiBzZXR0aW5nIHVwIHN0cmVhbScpXG4gIHRoaXMuX3NldHVwU3RyZWFtKClcbn1cbmluaGVyaXRzKE1xdHRDbGllbnQsIEV2ZW50RW1pdHRlcilcblxuLyoqXG4gKiBzZXR1cCB0aGUgZXZlbnQgaGFuZGxlcnMgaW4gdGhlIGlubmVyIHN0cmVhbS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NldHVwU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29ubmVjdFBhY2tldFxuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIHdyaXRhYmxlID0gbmV3IFdyaXRhYmxlKClcbiAgdmFyIHBhcnNlciA9IG1xdHRQYWNrZXQucGFyc2VyKHRoaXMub3B0aW9ucylcbiAgdmFyIGNvbXBsZXRlUGFyc2UgPSBudWxsXG4gIHZhciBwYWNrZXRzID0gW11cblxuICBkZWJ1ZygnX3NldHVwU3RyZWFtIDo6IGNhbGxpbmcgbWV0aG9kIHRvIGNsZWFyIHJlY29ubmVjdCcpXG4gIHRoaXMuX2NsZWFyUmVjb25uZWN0KClcblxuICBkZWJ1ZygnX3NldHVwU3RyZWFtIDo6IHVzaW5nIHN0cmVhbUJ1aWxkZXIgcHJvdmlkZWQgdG8gY2xpZW50IHRvIGNyZWF0ZSBzdHJlYW0nKVxuICB0aGlzLnN0cmVhbSA9IHRoaXMuc3RyZWFtQnVpbGRlcih0aGlzKVxuXG4gIHBhcnNlci5vbigncGFja2V0JywgZnVuY3Rpb24gKHBhY2tldCkge1xuICAgIGRlYnVnKCdwYXJzZXIgOjogb24gcGFja2V0IHB1c2ggdG8gcGFja2V0cyBhcnJheS4nKVxuICAgIHBhY2tldHMucHVzaChwYWNrZXQpXG4gIH0pXG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tXb3JrICgpIHtcbiAgICBpZiAocGFja2V0cy5sZW5ndGgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2sod29yaylcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRvbmUgPSBjb21wbGV0ZVBhcnNlXG4gICAgICBjb21wbGV0ZVBhcnNlID0gbnVsbFxuICAgICAgZG9uZSgpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd29yayAoKSB7XG4gICAgZGVidWcoJ3dvcmsgOjogZ2V0dGluZyBuZXh0IHBhY2tldCBpbiBxdWV1ZScpXG4gICAgdmFyIHBhY2tldCA9IHBhY2tldHMuc2hpZnQoKVxuXG4gICAgaWYgKHBhY2tldCkge1xuICAgICAgZGVidWcoJ3dvcmsgOjogcGFja2V0IHB1bGxlZCBmcm9tIHF1ZXVlJylcbiAgICAgIHRoYXQuX2hhbmRsZVBhY2tldChwYWNrZXQsIG5leHRUaWNrV29yaylcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ3dvcmsgOjogbm8gcGFja2V0cyBpbiBxdWV1ZScpXG4gICAgICB2YXIgZG9uZSA9IGNvbXBsZXRlUGFyc2VcbiAgICAgIGNvbXBsZXRlUGFyc2UgPSBudWxsXG4gICAgICBkZWJ1Zygnd29yayA6OiBkb25lIGZsYWcgaXMgJXMnLCAhIShkb25lKSlcbiAgICAgIGlmIChkb25lKSBkb25lKClcbiAgICB9XG4gIH1cblxuICB3cml0YWJsZS5fd3JpdGUgPSBmdW5jdGlvbiAoYnVmLCBlbmMsIGRvbmUpIHtcbiAgICBjb21wbGV0ZVBhcnNlID0gZG9uZVxuICAgIGRlYnVnKCd3cml0YWJsZSBzdHJlYW0gOjogcGFyc2luZyBidWZmZXInKVxuICAgIHBhcnNlci5wYXJzZShidWYpXG4gICAgd29yaygpXG4gIH1cblxuICBmdW5jdGlvbiBzdHJlYW1FcnJvckhhbmRsZXIgKGVycm9yKSB7XG4gICAgZGVidWcoJ3N0cmVhbUVycm9ySGFuZGxlciA6OiBlcnJvcicsIGVycm9yLm1lc3NhZ2UpXG4gICAgaWYgKHNvY2tldEVycm9ycy5pbmNsdWRlcyhlcnJvci5jb2RlKSkge1xuICAgICAgLy8gaGFuZGxlIGVycm9yXG4gICAgICBkZWJ1Zygnc3RyZWFtRXJyb3JIYW5kbGVyIDo6IGVtaXR0aW5nIGVycm9yJylcbiAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICB9IGVsc2Uge1xuICAgICAgbm9wKGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdfc2V0dXBTdHJlYW0gOjogcGlwZSBzdHJlYW0gdG8gd3JpdGFibGUgc3RyZWFtJylcbiAgdGhpcy5zdHJlYW0ucGlwZSh3cml0YWJsZSlcblxuICAvLyBTdXBwcmVzcyBjb25uZWN0aW9uIGVycm9yc1xuICB0aGlzLnN0cmVhbS5vbignZXJyb3InLCBzdHJlYW1FcnJvckhhbmRsZXIpXG5cbiAgLy8gRWNobyBzdHJlYW0gY2xvc2VcbiAgdGhpcy5zdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCcoJXMpc3RyZWFtIDo6IG9uIGNsb3NlJywgdGhhdC5vcHRpb25zLmNsaWVudElkKVxuICAgIGZsdXNoVm9sYXRpbGUodGhhdC5vdXRnb2luZylcbiAgICBkZWJ1Zygnc3RyZWFtOiBlbWl0IGNsb3NlIHRvIE1xdHRDbGllbnQnKVxuICAgIHRoYXQuZW1pdCgnY2xvc2UnKVxuICB9KVxuXG4gIC8vIFNlbmQgYSBjb25uZWN0IHBhY2tldFxuICBkZWJ1ZygnX3NldHVwU3RyZWFtOiBzZW5kaW5nIHBhY2tldCBgY29ubmVjdGAnKVxuICBjb25uZWN0UGFja2V0ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLm9wdGlvbnMpXG4gIGNvbm5lY3RQYWNrZXQuY21kID0gJ2Nvbm5lY3QnXG4gIC8vIGF2b2lkIG1lc3NhZ2UgcXVldWVcbiAgc2VuZFBhY2tldCh0aGlzLCBjb25uZWN0UGFja2V0KVxuXG4gIC8vIEVjaG8gY29ubmVjdGlvbiBlcnJvcnNcbiAgcGFyc2VyLm9uKCdlcnJvcicsIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpKVxuXG4gIC8vIGF1dGhcbiAgaWYgKHRoaXMub3B0aW9ucy5wcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucHJvcGVydGllcy5hdXRoZW50aWNhdGlvbk1ldGhvZCAmJiB0aGlzLm9wdGlvbnMucHJvcGVydGllcy5hdXRoZW50aWNhdGlvbkRhdGEpIHtcbiAgICAgIHRoYXQuZW5kKCgpID0+XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1BhY2tldCBoYXMgbm8gQXV0aGVudGljYXRpb24gTWV0aG9kJylcbiAgICAgICAgKSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJvcGVydGllcy5hdXRoZW50aWNhdGlvbk1ldGhvZCAmJiB0aGlzLm9wdGlvbnMuYXV0aFBhY2tldCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmF1dGhQYWNrZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYXV0aFBhY2tldCA9IHh0ZW5kKHtjbWQ6ICdhdXRoJywgcmVhc29uQ29kZTogMH0sIHRoaXMub3B0aW9ucy5hdXRoUGFja2V0KVxuICAgICAgc2VuZFBhY2tldCh0aGlzLCBhdXRoUGFja2V0KVxuICAgIH1cbiAgfVxuXG4gIC8vIG1hbnkgZHJhaW4gbGlzdGVuZXJzIGFyZSBuZWVkZWQgZm9yIHFvcyAxIGNhbGxiYWNrcyBpZiB0aGUgY29ubmVjdGlvbiBpcyBpbnRlcm1pdHRlbnRcbiAgdGhpcy5zdHJlYW0uc2V0TWF4TGlzdGVuZXJzKDEwMDApXG5cbiAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmFja1RpbWVyKVxuICB0aGlzLmNvbm5hY2tUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCchIWNvbm5lY3RUaW1lb3V0IGhpdCEhIENhbGxpbmcgX2NsZWFuVXAgd2l0aCBmb3JjZSBgdHJ1ZWAnKVxuICAgIHRoYXQuX2NsZWFuVXAodHJ1ZSlcbiAgfSwgdGhpcy5vcHRpb25zLmNvbm5lY3RUaW1lb3V0KVxufVxuXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgZG9uZSkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIGlmIChvcHRpb25zLnByb3RvY29sVmVyc2lvbiA9PT0gNSAmJiBvcHRpb25zLnByb3BlcnRpZXMgJiYgb3B0aW9ucy5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplICYmIG9wdGlvbnMucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSA8IHBhY2tldC5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdleGNlZWRpbmcgcGFja2V0cyBzaXplICcgKyBwYWNrZXQuY21kKSlcbiAgICB0aGlzLmVuZCh7cmVhc29uQ29kZTogMTQ5LCBwcm9wZXJ0aWVzOiB7IHJlYXNvblN0cmluZzogJ01heGltdW0gcGFja2V0IHNpemUgd2FzIGV4Y2VlZGVkJyB9fSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIGRlYnVnKCdfaGFuZGxlUGFja2V0IDo6IGVtaXR0aW5nIHBhY2tldHJlY2VpdmUnKVxuICB0aGlzLmVtaXQoJ3BhY2tldHJlY2VpdmUnLCBwYWNrZXQpXG5cbiAgc3dpdGNoIChwYWNrZXQuY21kKSB7XG4gICAgY2FzZSAncHVibGlzaCc6XG4gICAgICB0aGlzLl9oYW5kbGVQdWJsaXNoKHBhY2tldCwgZG9uZSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHViYWNrJzpcbiAgICBjYXNlICdwdWJyZWMnOlxuICAgIGNhc2UgJ3B1YmNvbXAnOlxuICAgIGNhc2UgJ3N1YmFjayc6XG4gICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgdGhpcy5faGFuZGxlQWNrKHBhY2tldClcbiAgICAgIGRvbmUoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwdWJyZWwnOlxuICAgICAgdGhpcy5faGFuZGxlUHVicmVsKHBhY2tldCwgZG9uZSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnY29ubmFjayc6XG4gICAgICB0aGlzLl9oYW5kbGVDb25uYWNrKHBhY2tldClcbiAgICAgIGRvbmUoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwaW5ncmVzcCc6XG4gICAgICB0aGlzLl9oYW5kbGVQaW5ncmVzcChwYWNrZXQpXG4gICAgICBkb25lKClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnZGlzY29ubmVjdCc6XG4gICAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0KHBhY2tldClcbiAgICAgIGRvbmUoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgLy8gbWF5YmUgd2Ugc2hvdWxkIGRvIGFuIGVycm9yIGhhbmRsaW5nXG4gICAgICAvLyBvciBqdXN0IGxvZyBpdFxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fY2hlY2tEaXNjb25uZWN0aW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RpbmcpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignY2xpZW50IGRpc2Nvbm5lY3RpbmcnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignY2xpZW50IGRpc2Nvbm5lY3RpbmcnKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdGluZ1xufVxuXG4vKipcbiAqIHB1Ymxpc2ggLSBwdWJsaXNoIDxtZXNzYWdlPiB0byA8dG9waWM+XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRvcGljIC0gdG9waWMgdG8gcHVibGlzaCB0b1xuICogQHBhcmFtIHtTdHJpbmcsIEJ1ZmZlcn0gbWVzc2FnZSAtIG1lc3NhZ2UgdG8gcHVibGlzaFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIHB1Ymxpc2ggb3B0aW9ucywgaW5jbHVkZXM6XG4gKiAgICB7TnVtYmVyfSBxb3MgLSBxb3MgbGV2ZWwgdG8gcHVibGlzaCBvblxuICogICAge0Jvb2xlYW59IHJldGFpbiAtIHdoZXRoZXIgb3Igbm90IHRvIHJldGFpbiB0aGUgbWVzc2FnZVxuICogICAge0Jvb2xlYW59IGR1cCAtIHdoZXRoZXIgb3Igbm90IG1hcmsgYSBtZXNzYWdlIGFzIGR1cGxpY2F0ZVxuICogICAge0Z1bmN0aW9ufSBjYlN0b3JlUHV0IC0gZnVuY3Rpb24oKXt9IGNhbGxlZCB3aGVuIG1lc3NhZ2UgaXMgcHV0IGludG8gYG91dGdvaW5nU3RvcmVgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gZnVuY3Rpb24oZXJyKXt9XG4gKiAgICBjYWxsZWQgd2hlbiBwdWJsaXNoIHN1Y2NlZWRzIG9yIGZhaWxzXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZSBjbGllbnQucHVibGlzaCgndG9waWMnLCAnbWVzc2FnZScpO1xuICogQGV4YW1wbGVcbiAqICAgICBjbGllbnQucHVibGlzaCgndG9waWMnLCAnbWVzc2FnZScsIHtxb3M6IDEsIHJldGFpbjogdHJ1ZSwgZHVwOiB0cnVlfSk7XG4gKiBAZXhhbXBsZSBjbGllbnQucHVibGlzaCgndG9waWMnLCAnbWVzc2FnZScsIGNvbnNvbGUubG9nKTtcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICh0b3BpYywgbWVzc2FnZSwgb3B0cywgY2FsbGJhY2spIHtcbiAgZGVidWcoJ3B1Ymxpc2ggOjogbWVzc2FnZSBgJXNgIHRvIHRvcGljIGAlc2AnLCBtZXNzYWdlLCB0b3BpYylcbiAgdmFyIHBhY2tldFxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIC5wdWJsaXNoKHRvcGljLCBwYXlsb2FkLCBjYik7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0c1xuICAgIG9wdHMgPSBudWxsXG4gIH1cblxuICAvLyBkZWZhdWx0IG9wdHNcbiAgdmFyIGRlZmF1bHRPcHRzID0ge3FvczogMCwgcmV0YWluOiBmYWxzZSwgZHVwOiBmYWxzZX1cbiAgb3B0cyA9IHh0ZW5kKGRlZmF1bHRPcHRzLCBvcHRzKVxuXG4gIGlmICh0aGlzLl9jaGVja0Rpc2Nvbm5lY3RpbmcoY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBhY2tldCA9IHtcbiAgICBjbWQ6ICdwdWJsaXNoJyxcbiAgICB0b3BpYzogdG9waWMsXG4gICAgcGF5bG9hZDogbWVzc2FnZSxcbiAgICBxb3M6IG9wdHMucW9zLFxuICAgIHJldGFpbjogb3B0cy5yZXRhaW4sXG4gICAgbWVzc2FnZUlkOiB0aGlzLl9uZXh0SWQoKSxcbiAgICBkdXA6IG9wdHMuZHVwXG4gIH1cblxuICBpZiAob3B0aW9ucy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICBwYWNrZXQucHJvcGVydGllcyA9IG9wdHMucHJvcGVydGllc1xuICAgIGlmICgoIW9wdGlvbnMucHJvcGVydGllcyAmJiBwYWNrZXQucHJvcGVydGllcyAmJiBwYWNrZXQucHJvcGVydGllcy50b3BpY0FsaWFzKSB8fCAoKG9wdHMucHJvcGVydGllcyAmJiBvcHRpb25zLnByb3BlcnRpZXMpICYmXG4gICAgICAoKG9wdHMucHJvcGVydGllcy50b3BpY0FsaWFzICYmIG9wdGlvbnMucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bSAmJiBvcHRzLnByb3BlcnRpZXMudG9waWNBbGlhcyA+IG9wdGlvbnMucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bSkgfHxcbiAgICAgICAgKCFvcHRpb25zLnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW0gJiYgb3B0cy5wcm9wZXJ0aWVzLnRvcGljQWxpYXMpKSkpIHtcbiAgICAgIC8qXG4gICAgICBpZiB3ZSBhcmUgZG9uYHQgc2V0dXAgdG9waWMgYWxpYXMgb3JcbiAgICAgIHRvcGljIGFsaWFzIG1heGltdW0gbGVzcyB0aGFuIHRvcGljIGFsaWFzIG9yXG4gICAgICBzZXJ2ZXIgZG9uYHQgZ2l2ZSB0b3BpYyBhbGlhcyBtYXhpbXVtLFxuICAgICAgd2UgYXJlIHJlbW92aW5nIHRvcGljIGFsaWFzIGZyb20gcGFja2V0XG4gICAgICAqL1xuICAgICAgZGVsZXRlIHBhY2tldC5wcm9wZXJ0aWVzLnRvcGljQWxpYXNcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygncHVibGlzaCA6OiBxb3MnLCBvcHRzLnFvcylcbiAgc3dpdGNoIChvcHRzLnFvcykge1xuICAgIGNhc2UgMTpcbiAgICBjYXNlIDI6XG4gICAgICAvLyBBZGQgdG8gY2FsbGJhY2tzXG4gICAgICB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0ge1xuICAgICAgICB2b2xhdGlsZTogZmFsc2UsXG4gICAgICAgIGNiOiBjYWxsYmFjayB8fCBub3BcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zdG9yZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgZGVidWcoJ19zdG9yZVByb2Nlc3NpbmcgZW5hYmxlZCcpXG4gICAgICAgIHRoaXMuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZ1twYWNrZXQubWVzc2FnZUlkXSA9IGZhbHNlXG4gICAgICAgIHRoaXMuX3N0b3JlUGFja2V0KHBhY2tldCwgdW5kZWZpbmVkLCBvcHRzLmNiU3RvcmVQdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnTXF0dENsaWVudDpwdWJsaXNoOiBwYWNrZXQgY21kOiAlcycsIHBhY2tldC5jbWQpXG4gICAgICAgIHRoaXMuX3NlbmRQYWNrZXQocGFja2V0LCB1bmRlZmluZWQsIG9wdHMuY2JTdG9yZVB1dClcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0aGlzLl9zdG9yZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgZGVidWcoJ19zdG9yZVByb2Nlc3NpbmcgZW5hYmxlZCcpXG4gICAgICAgIHRoaXMuX3N0b3JlUGFja2V0KHBhY2tldCwgY2FsbGJhY2ssIG9wdHMuY2JTdG9yZVB1dClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdNcXR0Q2xpZW50OnB1Ymxpc2g6IHBhY2tldCBjbWQ6ICVzJywgcGFja2V0LmNtZClcbiAgICAgICAgdGhpcy5fc2VuZFBhY2tldChwYWNrZXQsIGNhbGxiYWNrLCBvcHRzLmNiU3RvcmVQdXQpXG4gICAgICB9XG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBzdWJzY3JpYmUgLSBzdWJzY3JpYmUgdG8gPHRvcGljPlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nLCBBcnJheSwgT2JqZWN0fSB0b3BpYyAtIHRvcGljKHMpIHRvIHN1YnNjcmliZSB0bywgc3VwcG9ydHMgb2JqZWN0cyBpbiB0aGUgZm9ybSB7J3RvcGljJzogcW9zfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbmFsIHN1YnNjcmlwdGlvbiBvcHRpb25zLCBpbmNsdWRlczpcbiAqICAgIHtOdW1iZXJ9IHFvcyAtIHN1YnNjcmliZSBxb3MgbGV2ZWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBmdW5jdGlvbihlcnIsIGdyYW50ZWQpe30gd2hlcmU6XG4gKiAgICB7RXJyb3J9IGVyciAtIHN1YnNjcmlwdGlvbiBlcnJvciAobm9uZSBhdCB0aGUgbW9tZW50ISlcbiAqICAgIHtBcnJheX0gZ3JhbnRlZCAtIGFycmF5IG9mIHt0b3BpYzogJ3QnLCBxb3M6IDB9XG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqIEBleGFtcGxlIGNsaWVudC5zdWJzY3JpYmUoJ3RvcGljJyk7XG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKCd0b3BpYycsIHtxb3M6IDF9KTtcbiAqIEBleGFtcGxlIGNsaWVudC5zdWJzY3JpYmUoeyd0b3BpYyc6IHtxb3M6IDB9LCAndG9waWMyJzoge3FvczogMX19LCBjb25zb2xlLmxvZyk7XG4gKiBAZXhhbXBsZSBjbGllbnQuc3Vic2NyaWJlKCd0b3BpYycsIGNvbnNvbGUubG9nKTtcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICB9XG4gIHZhciBzdWJzID0gW11cbiAgdmFyIG9iaiA9IGFyZ3Muc2hpZnQoKVxuICB2YXIgcmVzdWJzY3JpYmUgPSBvYmoucmVzdWJzY3JpYmVcbiAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKSB8fCBub3BcbiAgdmFyIG9wdHMgPSBhcmdzLnBvcCgpXG4gIHZhciBpbnZhbGlkVG9waWNcbiAgdmFyIHRoYXQgPSB0aGlzXG4gIHZhciB2ZXJzaW9uID0gdGhpcy5vcHRpb25zLnByb3RvY29sVmVyc2lvblxuXG4gIGRlbGV0ZSBvYmoucmVzdWJzY3JpYmVcblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICBvYmogPSBbb2JqXVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSBjYWxsYmFja1xuICAgIGNhbGxiYWNrID0gbm9wXG4gIH1cblxuICBpbnZhbGlkVG9waWMgPSB2YWxpZGF0aW9ucy52YWxpZGF0ZVRvcGljcyhvYmopXG4gIGlmIChpbnZhbGlkVG9waWMgIT09IG51bGwpIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2ssIG5ldyBFcnJvcignSW52YWxpZCB0b3BpYyAnICsgaW52YWxpZFRvcGljKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWYgKHRoaXMuX2NoZWNrRGlzY29ubmVjdGluZyhjYWxsYmFjaykpIHtcbiAgICBkZWJ1Zygnc3Vic2NyaWJlOiBkaXNjY29uZWN0aW5nIHRydWUnKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgZGVmYXVsdE9wdHMgPSB7XG4gICAgcW9zOiAwXG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBkZWZhdWx0T3B0cy5ubCA9IGZhbHNlXG4gICAgZGVmYXVsdE9wdHMucmFwID0gZmFsc2VcbiAgICBkZWZhdWx0T3B0cy5yaCA9IDBcbiAgfVxuICBvcHRzID0geHRlbmQoZGVmYXVsdE9wdHMsIG9wdHMpXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgZGVidWcoJ3N1YnNjcmliZTogYXJyYXkgdG9waWMgJXMnLCB0b3BpYylcbiAgICAgIGlmICghdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3MuaGFzT3duUHJvcGVydHkodG9waWMpIHx8XG4gICAgICAgIHRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzW3RvcGljXS5xb3MgPCBvcHRzLnFvcyB8fFxuICAgICAgICAgIHJlc3Vic2NyaWJlKSB7XG4gICAgICAgIHZhciBjdXJyZW50T3B0cyA9IHtcbiAgICAgICAgICB0b3BpYzogdG9waWMsXG4gICAgICAgICAgcW9zOiBvcHRzLnFvc1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgICAgICAgY3VycmVudE9wdHMubmwgPSBvcHRzLm5sXG4gICAgICAgICAgY3VycmVudE9wdHMucmFwID0gb3B0cy5yYXBcbiAgICAgICAgICBjdXJyZW50T3B0cy5yaCA9IG9wdHMucmhcbiAgICAgICAgICBjdXJyZW50T3B0cy5wcm9wZXJ0aWVzID0gb3B0cy5wcm9wZXJ0aWVzXG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3N1YnNjcmliZTogcHVzaGluZyB0b3BpYyBgJXNgIGFuZCBxb3MgYCVzYCB0byBzdWJzIGxpc3QnLCBjdXJyZW50T3B0cy50b3BpYywgY3VycmVudE9wdHMucW9zKVxuICAgICAgICBzdWJzLnB1c2goY3VycmVudE9wdHMpXG4gICAgICB9XG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBPYmplY3RcbiAgICAgIC5rZXlzKG9iailcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGRlYnVnKCdzdWJzY3JpYmU6IG9iamVjdCB0b3BpYyAlcycsIGspXG4gICAgICAgIGlmICghdGhhdC5fcmVzdWJzY3JpYmVUb3BpY3MuaGFzT3duUHJvcGVydHkoaykgfHxcbiAgICAgICAgICB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1trXS5xb3MgPCBvYmpba10ucW9zIHx8XG4gICAgICAgICAgICByZXN1YnNjcmliZSkge1xuICAgICAgICAgIHZhciBjdXJyZW50T3B0cyA9IHtcbiAgICAgICAgICAgIHRvcGljOiBrLFxuICAgICAgICAgICAgcW9zOiBvYmpba10ucW9zXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgICAgICAgICBjdXJyZW50T3B0cy5ubCA9IG9ialtrXS5ubFxuICAgICAgICAgICAgY3VycmVudE9wdHMucmFwID0gb2JqW2tdLnJhcFxuICAgICAgICAgICAgY3VycmVudE9wdHMucmggPSBvYmpba10ucmhcbiAgICAgICAgICAgIGN1cnJlbnRPcHRzLnByb3BlcnRpZXMgPSBvcHRzLnByb3BlcnRpZXNcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVidWcoJ3N1YnNjcmliZTogcHVzaGluZyBgJXNgIHRvIHN1YnMgbGlzdCcsIGN1cnJlbnRPcHRzKVxuICAgICAgICAgIHN1YnMucHVzaChjdXJyZW50T3B0cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIHBhY2tldCA9IHtcbiAgICBjbWQ6ICdzdWJzY3JpYmUnLFxuICAgIHN1YnNjcmlwdGlvbnM6IHN1YnMsXG4gICAgcW9zOiAxLFxuICAgIHJldGFpbjogZmFsc2UsXG4gICAgZHVwOiBmYWxzZSxcbiAgICBtZXNzYWdlSWQ6IHRoaXMuX25leHRJZCgpXG4gIH1cblxuICBpZiAob3B0cy5wcm9wZXJ0aWVzKSB7XG4gICAgcGFja2V0LnByb3BlcnRpZXMgPSBvcHRzLnByb3BlcnRpZXNcbiAgfVxuXG4gIGlmICghc3Vicy5sZW5ndGgpIHtcbiAgICBjYWxsYmFjayhudWxsLCBbXSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHN1YnNjcmlwdGlvbnMgdG8gcmVzdWJzY3JpYmUgdG8gaW4gY2FzZSBvZiBkaXNjb25uZWN0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVzdWJzY3JpYmUpIHtcbiAgICBkZWJ1Zygnc3Vic2NyaWJlIDo6IHJlc3Vic2NyaWJlIHRydWUnKVxuICAgIHZhciB0b3BpY3MgPSBbXVxuICAgIHN1YnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7XG4gICAgICBpZiAodGhhdC5vcHRpb25zLnJlY29ubmVjdFBlcmlvZCA+IDApIHtcbiAgICAgICAgdmFyIHRvcGljID0geyBxb3M6IHN1Yi5xb3MgfVxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgICAgICAgIHRvcGljLm5sID0gc3ViLm5sIHx8IGZhbHNlXG4gICAgICAgICAgdG9waWMucmFwID0gc3ViLnJhcCB8fCBmYWxzZVxuICAgICAgICAgIHRvcGljLnJoID0gc3ViLnJoIHx8IDBcbiAgICAgICAgICB0b3BpYy5wcm9wZXJ0aWVzID0gc3ViLnByb3BlcnRpZXNcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1tzdWIudG9waWNdID0gdG9waWNcbiAgICAgICAgdG9waWNzLnB1c2goc3ViLnRvcGljKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhhdC5tZXNzYWdlSWRUb1RvcGljW3BhY2tldC5tZXNzYWdlSWRdID0gdG9waWNzXG4gIH1cblxuICB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0ge1xuICAgIHZvbGF0aWxlOiB0cnVlLFxuICAgIGNiOiBmdW5jdGlvbiAoZXJyLCBwYWNrZXQpIHtcbiAgICAgIGlmICghZXJyKSB7XG4gICAgICAgIHZhciBncmFudGVkID0gcGFja2V0LmdyYW50ZWRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFudGVkLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgc3Vic1tpXS5xb3MgPSBncmFudGVkW2ldXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZXJyLCBzdWJzKVxuICAgIH1cbiAgfVxuICBkZWJ1Zygnc3Vic2NyaWJlIDo6IGNhbGwgX3NlbmRQYWNrZXQnKVxuICB0aGlzLl9zZW5kUGFja2V0KHBhY2tldClcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIHVuc3Vic2NyaWJlIC0gdW5zdWJzY3JpYmUgZnJvbSB0b3BpYyhzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nLCBBcnJheX0gdG9waWMgLSB0b3BpY3MgdG8gdW5zdWJzY3JpYmUgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSAtIG9wdGlvbmFsIHN1YnNjcmlwdGlvbiBvcHRpb25zLCBpbmNsdWRlczpcbiAqICAgIHtPYmplY3R9IHByb3BlcnRpZXMgLSBwcm9wZXJ0aWVzIG9mIHVuc3Vic2NyaWJlIHBhY2tldFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIGNhbGxiYWNrIGZpcmVkIG9uIHVuc3ViYWNrXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqIEBleGFtcGxlIGNsaWVudC51bnN1YnNjcmliZSgndG9waWMnKTtcbiAqIEBleGFtcGxlIGNsaWVudC51bnN1YnNjcmliZSgndG9waWMnLCBjb25zb2xlLmxvZyk7XG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0ge1xuICAgIGNtZDogJ3Vuc3Vic2NyaWJlJyxcbiAgICBxb3M6IDEsXG4gICAgbWVzc2FnZUlkOiB0aGlzLl9uZXh0SWQoKVxuICB9XG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgfVxuICB2YXIgdG9waWMgPSBhcmdzLnNoaWZ0KClcbiAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKSB8fCBub3BcbiAgdmFyIG9wdHMgPSBhcmdzLnBvcCgpXG5cbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ3N0cmluZycpIHtcbiAgICB0b3BpYyA9IFt0b3BpY11cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0gY2FsbGJhY2tcbiAgICBjYWxsYmFjayA9IG5vcFxuICB9XG5cbiAgaWYgKHRoaXMuX2NoZWNrRGlzY29ubmVjdGluZyhjYWxsYmFjaykpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3BpYyA9PT0gJ3N0cmluZycpIHtcbiAgICBwYWNrZXQudW5zdWJzY3JpcHRpb25zID0gW3RvcGljXVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodG9waWMpKSB7XG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucyA9IHRvcGljXG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnJlc3Vic2NyaWJlKSB7XG4gICAgcGFja2V0LnVuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0b3BpYykge1xuICAgICAgZGVsZXRlIHRoYXQuX3Jlc3Vic2NyaWJlVG9waWNzW3RvcGljXVxuICAgIH0pXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmIG9wdHMucHJvcGVydGllcykge1xuICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gb3B0cy5wcm9wZXJ0aWVzXG4gIH1cblxuICB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdID0ge1xuICAgIHZvbGF0aWxlOiB0cnVlLFxuICAgIGNiOiBjYWxsYmFja1xuICB9XG5cbiAgZGVidWcoJ3Vuc3Vic2NyaWJlOiBjYWxsIF9zZW5kUGFja2V0JylcbiAgdGhpcy5fc2VuZFBhY2tldChwYWNrZXQpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBlbmQgLSBjbG9zZSBjb25uZWN0aW9uXG4gKlxuICogQHJldHVybnMge01xdHRDbGllbnR9IHRoaXMgLSBmb3IgY2hhaW5pbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgLSBkbyBub3Qgd2FpdCBmb3IgYWxsIGluLWZsaWdodCBtZXNzYWdlcyB0byBiZSBhY2tlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsZWQgd2hlbiB0aGUgY2xpZW50IGhhcyBiZWVuIGNsb3NlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChmb3JjZSwgb3B0cywgY2IpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgZGVidWcoJ2VuZCA6OiAoJXMpJywgdGhpcy5vcHRpb25zLmNsaWVudElkKVxuXG4gIGlmIChmb3JjZSA9PSBudWxsIHx8IHR5cGVvZiBmb3JjZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgY2IgPSBvcHRzIHx8IG5vcFxuICAgIG9wdHMgPSBmb3JjZVxuICAgIGZvcmNlID0gZmFsc2VcbiAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICBjYiA9IG9wdHNcbiAgICAgIG9wdHMgPSBudWxsXG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gbm9wXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSBudWxsXG4gIH1cblxuICBkZWJ1ZygnZW5kIDo6IGNiPyAlcycsICEhY2IpXG4gIGNiID0gY2IgfHwgbm9wXG5cbiAgZnVuY3Rpb24gY2xvc2VTdG9yZXMgKCkge1xuICAgIGRlYnVnKCdlbmQgOjogY2xvc2VTdG9yZXM6IGNsb3NpbmcgaW5jb21pbmcgYW5kIG91dGdvaW5nIHN0b3JlcycpXG4gICAgdGhhdC5kaXNjb25uZWN0ZWQgPSB0cnVlXG4gICAgdGhhdC5pbmNvbWluZ1N0b3JlLmNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQub3V0Z29pbmdTdG9yZS5jbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlYnVnKCdlbmQgOjogY2xvc2VTdG9yZXM6IGVtaXR0aW5nIGVuZCcpXG4gICAgICAgIHRoYXQuZW1pdCgnZW5kJylcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgZGVidWcoJ2VuZCA6OiBjbG9zZVN0b3JlczogaW52b2tpbmcgY2FsbGJhY2sgd2l0aCBhcmdzJylcbiAgICAgICAgICBjYigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICBpZiAodGhhdC5fZGVmZXJyZWRSZWNvbm5lY3QpIHtcbiAgICAgIHRoYXQuX2RlZmVycmVkUmVjb25uZWN0KClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2ggKCkge1xuICAgIC8vIGRlZmVyIGNsb3Nlc1N0b3JlcyBvZiBhbiBJL08gY3ljbGUsXG4gICAgLy8ganVzdCB0byBtYWtlIHN1cmUgdGhpbmdzIGFyZVxuICAgIC8vIG9rIGZvciB3ZWJzb2NrZXRzXG4gICAgZGVidWcoJ2VuZCA6OiAoJXMpIDo6IGZpbmlzaCA6OiBjYWxsaW5nIF9jbGVhblVwIHdpdGggZm9yY2UgJXMnLCB0aGF0Lm9wdGlvbnMuY2xpZW50SWQsIGZvcmNlKVxuICAgIHRoYXQuX2NsZWFuVXAoZm9yY2UsICgpID0+IHtcbiAgICAgIGRlYnVnKCdlbmQgOjogZmluaXNoIDo6IGNhbGxpbmcgcHJvY2Vzcy5uZXh0VGljayBvbiBjbG9zZVN0b3JlcycpXG4gICAgICAvLyB2YXIgYm91bmRQcm9jZXNzID0gcHJvY2Vzcy5uZXh0VGljay5iaW5kKG51bGwsIGNsb3NlU3RvcmVzKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjbG9zZVN0b3Jlcy5iaW5kKHRoYXQpKVxuICAgIH0sIG9wdHMpXG4gIH1cblxuICBpZiAodGhpcy5kaXNjb25uZWN0aW5nKSB7XG4gICAgY2IoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0aGlzLl9jbGVhclJlY29ubmVjdCgpXG5cbiAgdGhpcy5kaXNjb25uZWN0aW5nID0gdHJ1ZVxuXG4gIGlmICghZm9yY2UgJiYgT2JqZWN0LmtleXModGhpcy5vdXRnb2luZykubGVuZ3RoID4gMCkge1xuICAgIC8vIHdhaXQgMTBtcywganVzdCB0byBiZSBzdXJlIHdlIHJlY2VpdmVkIGFsbCBvZiBpdFxuICAgIGRlYnVnKCdlbmQgOjogKCVzKSA6OiBjYWxsaW5nIGZpbmlzaCBpbiAxMG1zIG9uY2Ugb3V0Z29pbmcgaXMgZW1wdHknLCB0aGF0Lm9wdGlvbnMuY2xpZW50SWQpXG4gICAgdGhpcy5vbmNlKCdvdXRnb2luZ0VtcHR5Jywgc2V0VGltZW91dC5iaW5kKG51bGwsIGZpbmlzaCwgMTApKVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdlbmQgOjogKCVzKSA6OiBpbW1lZGlhdGVseSBjYWxsaW5nIGZpbmlzaCcsIHRoYXQub3B0aW9ucy5jbGllbnRJZClcbiAgICBmaW5pc2goKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiByZW1vdmVPdXRnb2luZ01lc3NhZ2UgLSByZW1vdmUgYSBtZXNzYWdlIGluIG91dGdvaW5nIHN0b3JlXG4gKiB0aGUgb3V0Z29pbmcgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aGUgRXJyb3IoJ01lc3NhZ2UgcmVtb3ZlZCcpIGlmIHRoZSBtZXNzYWdlIGlzIHJlbW92ZWRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZUlkIC0gbWVzc2FnZUlkIHRvIHJlbW92ZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7TXF0dENsaWVudH0gdGhpcyAtIGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZSBjbGllbnQucmVtb3ZlT3V0Z29pbmdNZXNzYWdlKGNsaWVudC5nZXRMYXN0TWVzc2FnZUlkKCkpO1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5yZW1vdmVPdXRnb2luZ01lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZUlkKSB7XG4gIHZhciBjYiA9IHRoaXMub3V0Z29pbmdbbWVzc2FnZUlkXSA/IHRoaXMub3V0Z29pbmdbbWVzc2FnZUlkXS5jYiA6IG51bGxcbiAgZGVsZXRlIHRoaXMub3V0Z29pbmdbbWVzc2FnZUlkXVxuICB0aGlzLm91dGdvaW5nU3RvcmUuZGVsKHttZXNzYWdlSWQ6IG1lc3NhZ2VJZH0sIGZ1bmN0aW9uICgpIHtcbiAgICBjYihuZXcgRXJyb3IoJ01lc3NhZ2UgcmVtb3ZlZCcpKVxuICB9KVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIHJlY29ubmVjdCAtIGNvbm5lY3QgYWdhaW4gdXNpbmcgdGhlIHNhbWUgb3B0aW9ucyBhcyBjb25uZWN0KClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9uYWwgcmVjb25uZWN0IG9wdGlvbnMsIGluY2x1ZGVzOlxuICogICAge1N0b3JlfSBpbmNvbWluZ1N0b3JlIC0gYSBzdG9yZSBmb3IgdGhlIGluY29taW5nIHBhY2tldHNcbiAqICAgIHtTdG9yZX0gb3V0Z29pbmdTdG9yZSAtIGEgc3RvcmUgZm9yIHRoZSBvdXRnb2luZyBwYWNrZXRzXG4gKiAgICBpZiBvcHRzIGlzIG5vdCBnaXZlbiwgY3VycmVudCBzdG9yZXMgYXJlIHVzZWRcbiAqIEByZXR1cm5zIHtNcXR0Q2xpZW50fSB0aGlzIC0gZm9yIGNoYWluaW5nXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgZGVidWcoJ2NsaWVudCByZWNvbm5lY3QnKVxuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIHRoYXQub3B0aW9ucy5pbmNvbWluZ1N0b3JlID0gb3B0cy5pbmNvbWluZ1N0b3JlXG4gICAgICB0aGF0Lm9wdGlvbnMub3V0Z29pbmdTdG9yZSA9IG9wdHMub3V0Z29pbmdTdG9yZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Lm9wdGlvbnMuaW5jb21pbmdTdG9yZSA9IG51bGxcbiAgICAgIHRoYXQub3B0aW9ucy5vdXRnb2luZ1N0b3JlID0gbnVsbFxuICAgIH1cbiAgICB0aGF0LmluY29taW5nU3RvcmUgPSB0aGF0Lm9wdGlvbnMuaW5jb21pbmdTdG9yZSB8fCBuZXcgU3RvcmUoKVxuICAgIHRoYXQub3V0Z29pbmdTdG9yZSA9IHRoYXQub3B0aW9ucy5vdXRnb2luZ1N0b3JlIHx8IG5ldyBTdG9yZSgpXG4gICAgdGhhdC5kaXNjb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGF0LmRpc2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhhdC5fZGVmZXJyZWRSZWNvbm5lY3QgPSBudWxsXG4gICAgdGhhdC5fcmVjb25uZWN0KClcbiAgfVxuXG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RpbmcgJiYgIXRoaXMuZGlzY29ubmVjdGVkKSB7XG4gICAgdGhpcy5fZGVmZXJyZWRSZWNvbm5lY3QgPSBmXG4gIH0gZWxzZSB7XG4gICAgZigpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBfcmVjb25uZWN0IC0gaW1wbGVtZW50IHJlY29ubmVjdGlvblxuICogQGFwaSBwcml2YXRlaXNoXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdfcmVjb25uZWN0OiBlbWl0dGluZyByZWNvbm5lY3QgdG8gY2xpZW50JylcbiAgdGhpcy5lbWl0KCdyZWNvbm5lY3QnKVxuICBkZWJ1ZygnX3JlY29ubmVjdDogY2FsbGluZyBfc2V0dXBTdHJlYW0nKVxuICB0aGlzLl9zZXR1cFN0cmVhbSgpXG59XG5cbi8qKlxuICogX3NldHVwUmVjb25uZWN0IC0gc2V0dXAgcmVjb25uZWN0IHRpbWVyXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9zZXR1cFJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG5cbiAgaWYgKCF0aGF0LmRpc2Nvbm5lY3RpbmcgJiYgIXRoYXQucmVjb25uZWN0VGltZXIgJiYgKHRoYXQub3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QgPiAwKSkge1xuICAgIGlmICghdGhpcy5yZWNvbm5lY3RpbmcpIHtcbiAgICAgIGRlYnVnKCdfc2V0dXBSZWNvbm5lY3QgOjogZW1pdCBgb2ZmbGluZWAgc3RhdGUnKVxuICAgICAgdGhpcy5lbWl0KCdvZmZsaW5lJylcbiAgICAgIGRlYnVnKCdfc2V0dXBSZWNvbm5lY3QgOjogc2V0IGByZWNvbm5lY3RpbmdgIHRvIGB0cnVlYCcpXG4gICAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWVcbiAgICB9XG4gICAgZGVidWcoJ19zZXR1cFJlY29ubmVjdCA6OiBzZXR0aW5nIHJlY29ubmVjdFRpbWVyIGZvciAlZCBtcycsIHRoYXQub3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QpXG4gICAgdGhhdC5yZWNvbm5lY3RUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlYnVnKCdyZWNvbm5lY3RUaW1lciA6OiByZWNvbm5lY3QgdHJpZ2dlcmVkIScpXG4gICAgICB0aGF0Ll9yZWNvbm5lY3QoKVxuICAgIH0sIHRoYXQub3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QpXG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ19zZXR1cFJlY29ubmVjdCA6OiBkb2luZyBub3RoaW5nLi4uJylcbiAgfVxufVxuXG4vKipcbiAqIF9jbGVhclJlY29ubmVjdCAtIGNsZWFyIHRoZSByZWNvbm5lY3QgdGltZXJcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2NsZWFyUmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnX2NsZWFyUmVjb25uZWN0IDogY2xlYXJpbmcgcmVjb25uZWN0IHRpbWVyJylcbiAgaWYgKHRoaXMucmVjb25uZWN0VGltZXIpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMucmVjb25uZWN0VGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGxcbiAgfVxufVxuXG4vKipcbiAqIF9jbGVhblVwIC0gY2xlYW4gdXAgb24gY29ubmVjdGlvbiBlbmRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fY2xlYW5VcCA9IGZ1bmN0aW9uIChmb3JjZWQsIGRvbmUpIHtcbiAgdmFyIG9wdHMgPSBhcmd1bWVudHNbMl1cbiAgaWYgKGRvbmUpIHtcbiAgICBkZWJ1ZygnX2NsZWFuVXAgOjogZG9uZSBjYWxsYmFjayBwcm92aWRlZCBmb3Igb24gc3RyZWFtIGNsb3NlJylcbiAgICB0aGlzLnN0cmVhbS5vbignY2xvc2UnLCBkb25lKVxuICB9XG5cbiAgZGVidWcoJ19jbGVhblVwIDo6IGZvcmNlZD8gJXMnLCBmb3JjZWQpXG4gIGlmIChmb3JjZWQpIHtcbiAgICBpZiAoKHRoaXMub3B0aW9ucy5yZWNvbm5lY3RQZXJpb2QgPT09IDApICYmIHRoaXMub3B0aW9ucy5jbGVhbikge1xuICAgICAgZmx1c2godGhpcy5vdXRnb2luZylcbiAgICB9XG4gICAgZGVidWcoJ19jbGVhblVwIDo6ICglcykgOjogZGVzdHJveWluZyBzdHJlYW0nLCB0aGlzLm9wdGlvbnMuY2xpZW50SWQpXG4gICAgdGhpcy5zdHJlYW0uZGVzdHJveSgpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhY2tldCA9IHh0ZW5kKHsgY21kOiAnZGlzY29ubmVjdCcgfSwgb3B0cylcbiAgICBkZWJ1ZygnX2NsZWFuVXAgOjogKCVzKSA6OiBjYWxsIF9zZW5kUGFja2V0IHdpdGggZGlzY29ubmVjdCBwYWNrZXQnLCB0aGlzLm9wdGlvbnMuY2xpZW50SWQpXG4gICAgdGhpcy5fc2VuZFBhY2tldChcbiAgICAgIHBhY2tldCxcbiAgICAgIHNldEltbWVkaWF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICB0aGlzLnN0cmVhbS5lbmQuYmluZCh0aGlzLnN0cmVhbSlcbiAgICAgIClcbiAgICApXG4gIH1cblxuICBpZiAoIXRoaXMuZGlzY29ubmVjdGluZykge1xuICAgIGRlYnVnKCdfY2xlYW5VcCA6OiBjbGllbnQgbm90IGRpc2Nvbm5lY3RpbmcuIENsZWFyaW5nIGFuZCByZXNldHRpbmcgcmVjb25uZWN0LicpXG4gICAgdGhpcy5fY2xlYXJSZWNvbm5lY3QoKVxuICAgIHRoaXMuX3NldHVwUmVjb25uZWN0KClcbiAgfVxuXG4gIGlmICh0aGlzLnBpbmdUaW1lciAhPT0gbnVsbCkge1xuICAgIGRlYnVnKCdfY2xlYW5VcCA6OiBjbGVhcmluZyBwaW5nVGltZXInKVxuICAgIHRoaXMucGluZ1RpbWVyLmNsZWFyKClcbiAgICB0aGlzLnBpbmdUaW1lciA9IG51bGxcbiAgfVxuXG4gIGlmIChkb25lICYmICF0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdfY2xlYW5VcCA6OiAoJXMpIDo6IHJlbW92aW5nIHN0cmVhbSBgZG9uZWAgY2FsbGJhY2sgYGNsb3NlYCBsaXN0ZW5lcicsIHRoaXMub3B0aW9ucy5jbGllbnRJZClcbiAgICB0aGlzLnN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBkb25lKVxuICAgIGRvbmUoKVxuICB9XG59XG5cbi8qKlxuICogX3NlbmRQYWNrZXQgLSBzZW5kIG9yIHF1ZXVlIGEgcGFja2V0XG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gcGFja2V0IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgd2hlbiB0aGUgcGFja2V0IGlzIHNlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiU3RvcmVQdXQgLSBjYWxsZWQgd2hlbiBtZXNzYWdlIGlzIHB1dCBpbnRvIG91dGdvaW5nU3RvcmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fc2VuZFBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNiLCBjYlN0b3JlUHV0KSB7XG4gIGRlYnVnKCdfc2VuZFBhY2tldCA6OiAoJXMpIDo6ICBzdGFydCcsIHRoaXMub3B0aW9ucy5jbGllbnRJZClcbiAgY2JTdG9yZVB1dCA9IGNiU3RvcmVQdXQgfHwgbm9wXG5cbiAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdfc2VuZFBhY2tldCA6OiBjbGllbnQgbm90IGNvbm5lY3RlZC4gU3RvcmluZyBwYWNrZXQgb2ZmbGluZS4nKVxuICAgIHRoaXMuX3N0b3JlUGFja2V0KHBhY2tldCwgY2IsIGNiU3RvcmVQdXQpXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBXaGVuIHNlbmRpbmcgYSBwYWNrZXQsIHJlc2NoZWR1bGUgdGhlIHBpbmcgdGltZXJcbiAgdGhpcy5fc2hpZnRQaW5nSW50ZXJ2YWwoKVxuXG4gIHN3aXRjaCAocGFja2V0LmNtZCkge1xuICAgIGNhc2UgJ3B1Ymxpc2gnOlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwdWJyZWwnOlxuICAgICAgc3RvcmVBbmRTZW5kKHRoaXMsIHBhY2tldCwgY2IsIGNiU3RvcmVQdXQpXG4gICAgICByZXR1cm5cbiAgICBkZWZhdWx0OlxuICAgICAgc2VuZFBhY2tldCh0aGlzLCBwYWNrZXQsIGNiKVxuICAgICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKHBhY2tldC5xb3MpIHtcbiAgICBjYXNlIDI6XG4gICAgY2FzZSAxOlxuICAgICAgc3RvcmVBbmRTZW5kKHRoaXMsIHBhY2tldCwgY2IsIGNiU3RvcmVQdXQpXG4gICAgICBicmVha1xuICAgIC8qKlxuICAgICAqIG5vIG5lZWQgb2YgY2FzZSBoZXJlIHNpbmNlIGl0IHdpbGwgYmUgY2F1Z2h0IGJ5IGRlZmF1bHRcbiAgICAgKiBhbmQganNoaW50IGNvbXBseSB0aGF0IGJlZm9yZSBkZWZhdWx0IGl0IG11c3QgYmUgYSBicmVha1xuICAgICAqIGFueXdheSBpdCB3aWxsIHJlc3VsdCBpbiAtMSBldmFsdWF0aW9uXG4gICAgICovXG4gICAgY2FzZSAwOlxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICBzZW5kUGFja2V0KHRoaXMsIHBhY2tldCwgY2IpXG4gICAgICBicmVha1xuICB9XG4gIGRlYnVnKCdfc2VuZFBhY2tldCA6OiAoJXMpIDo6ICBlbmQnLCB0aGlzLm9wdGlvbnMuY2xpZW50SWQpXG59XG5cbi8qKlxuICogX3N0b3JlUGFja2V0IC0gcXVldWUgYSBwYWNrZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBwYWNrZXQgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFjayB3aGVuIHRoZSBwYWNrZXQgaXMgc2VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JTdG9yZVB1dCAtIGNhbGxlZCB3aGVuIG1lc3NhZ2UgaXMgcHV0IGludG8gb3V0Z29pbmdTdG9yZVxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9zdG9yZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIGNiLCBjYlN0b3JlUHV0KSB7XG4gIGRlYnVnKCdfc3RvcmVQYWNrZXQgOjogcGFja2V0OiAlbycsIHBhY2tldClcbiAgZGVidWcoJ19zdG9yZVBhY2tldCA6OiBjYj8gJXMnLCAhIWNiKVxuICBjYlN0b3JlUHV0ID0gY2JTdG9yZVB1dCB8fCBub3BcblxuICAvLyBjaGVjayB0aGF0IHRoZSBwYWNrZXQgaXMgbm90IGEgcW9zIG9mIDAsIG9yIHRoYXQgdGhlIGNvbW1hbmQgaXMgbm90IGEgcHVibGlzaFxuICBpZiAoKChwYWNrZXQucW9zIHx8IDApID09PSAwICYmIHRoaXMucXVldWVRb1NaZXJvKSB8fCBwYWNrZXQuY21kICE9PSAncHVibGlzaCcpIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2goeyBwYWNrZXQ6IHBhY2tldCwgY2I6IGNiIH0pXG4gIH0gZWxzZSBpZiAocGFja2V0LnFvcyA+IDApIHtcbiAgICBjYiA9IHRoaXMub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPyB0aGlzLm91dGdvaW5nW3BhY2tldC5tZXNzYWdlSWRdLmNiIDogbnVsbFxuICAgIHRoaXMub3V0Z29pbmdTdG9yZS5wdXQocGFja2V0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYiAmJiBjYihlcnIpXG4gICAgICB9XG4gICAgICBjYlN0b3JlUHV0KClcbiAgICB9KVxuICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgY2IobmV3IEVycm9yKCdObyBjb25uZWN0aW9uIHRvIGJyb2tlcicpKVxuICB9XG59XG5cbi8qKlxuICogX3NldHVwUGluZ1RpbWVyIC0gc2V0dXAgdGhlIHBpbmcgdGltZXJcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX3NldHVwUGluZ1RpbWVyID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnX3NldHVwUGluZ1RpbWVyIDo6IGtlZXBhbGl2ZSAlZCAoc2Vjb25kcyknLCB0aGlzLm9wdGlvbnMua2VlcGFsaXZlKVxuICB2YXIgdGhhdCA9IHRoaXNcblxuICBpZiAoIXRoaXMucGluZ1RpbWVyICYmIHRoaXMub3B0aW9ucy5rZWVwYWxpdmUpIHtcbiAgICB0aGlzLnBpbmdSZXNwID0gdHJ1ZVxuICAgIHRoaXMucGluZ1RpbWVyID0gcmVJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0Ll9jaGVja1BpbmcoKVxuICAgIH0sIHRoaXMub3B0aW9ucy5rZWVwYWxpdmUgKiAxMDAwKVxuICB9XG59XG5cbi8qKlxuICogX3NoaWZ0UGluZ0ludGVydmFsIC0gcmVzY2hlZHVsZSB0aGUgcGluZyBpbnRlcnZhbFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fc2hpZnRQaW5nSW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBpbmdUaW1lciAmJiB0aGlzLm9wdGlvbnMua2VlcGFsaXZlICYmIHRoaXMub3B0aW9ucy5yZXNjaGVkdWxlUGluZ3MpIHtcbiAgICB0aGlzLnBpbmdUaW1lci5yZXNjaGVkdWxlKHRoaXMub3B0aW9ucy5rZWVwYWxpdmUgKiAxMDAwKVxuICB9XG59XG4vKipcbiAqIF9jaGVja1BpbmcgLSBjaGVjayBpZiBhIHBpbmdyZXNwIGhhcyBjb21lIGJhY2ssIGFuZCBwaW5nIHRoZSBzZXJ2ZXIgYWdhaW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX2NoZWNrUGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ19jaGVja1BpbmcgOjogY2hlY2tpbmcgcGluZy4uLicpXG4gIGlmICh0aGlzLnBpbmdSZXNwKSB7XG4gICAgZGVidWcoJ19jaGVja1BpbmcgOjogcGluZyByZXNwb25zZSByZWNlaXZlZC4gQ2xlYXJpbmcgZmxhZyBhbmQgc2VuZGluZyBgcGluZ3JlcWAnKVxuICAgIHRoaXMucGluZ1Jlc3AgPSBmYWxzZVxuICAgIHRoaXMuX3NlbmRQYWNrZXQoeyBjbWQ6ICdwaW5ncmVxJyB9KVxuICB9IGVsc2Uge1xuICAgIC8vIGRvIGEgZm9yY2VkIGNsZWFudXAgc2luY2Ugc29ja2V0IHdpbGwgYmUgaW4gYmFkIHNoYXBlXG4gICAgZGVidWcoJ19jaGVja1BpbmcgOjogY2FsbGluZyBfY2xlYW5VcCB3aXRoIGZvcmNlIHRydWUnKVxuICAgIHRoaXMuX2NsZWFuVXAodHJ1ZSlcbiAgfVxufVxuXG4vKipcbiAqIF9oYW5kbGVQaW5ncmVzcCAtIGhhbmRsZSBhIHBpbmdyZXNwXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVQaW5ncmVzcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5waW5nUmVzcCA9IHRydWVcbn1cblxuLyoqXG4gKiBfaGFuZGxlQ29ubmFja1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlQ29ubmFjayA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgZGVidWcoJ19oYW5kbGVDb25uYWNrJylcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgdmFyIHZlcnNpb24gPSBvcHRpb25zLnByb3RvY29sVmVyc2lvblxuICB2YXIgcmMgPSB2ZXJzaW9uID09PSA1ID8gcGFja2V0LnJlYXNvbkNvZGUgOiBwYWNrZXQucmV0dXJuQ29kZVxuXG4gIGNsZWFyVGltZW91dCh0aGlzLmNvbm5hY2tUaW1lcilcblxuICBpZiAocGFja2V0LnByb3BlcnRpZXMpIHtcbiAgICBpZiAocGFja2V0LnByb3BlcnRpZXMudG9waWNBbGlhc01heGltdW0pIHtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9wZXJ0aWVzKSB7IG9wdGlvbnMucHJvcGVydGllcyA9IHt9IH1cbiAgICAgIG9wdGlvbnMucHJvcGVydGllcy50b3BpY0FsaWFzTWF4aW11bSA9IHBhY2tldC5wcm9wZXJ0aWVzLnRvcGljQWxpYXNNYXhpbXVtXG4gICAgfVxuICAgIGlmIChwYWNrZXQucHJvcGVydGllcy5zZXJ2ZXJLZWVwQWxpdmUgJiYgb3B0aW9ucy5rZWVwYWxpdmUpIHtcbiAgICAgIG9wdGlvbnMua2VlcGFsaXZlID0gcGFja2V0LnByb3BlcnRpZXMuc2VydmVyS2VlcEFsaXZlXG4gICAgICB0aGlzLl9zaGlmdFBpbmdJbnRlcnZhbCgpXG4gICAgfVxuICAgIGlmIChwYWNrZXQucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSkge1xuICAgICAgaWYgKCFvcHRpb25zLnByb3BlcnRpZXMpIHsgb3B0aW9ucy5wcm9wZXJ0aWVzID0ge30gfVxuICAgICAgb3B0aW9ucy5wcm9wZXJ0aWVzLm1heGltdW1QYWNrZXRTaXplID0gcGFja2V0LnByb3BlcnRpZXMubWF4aW11bVBhY2tldFNpemVcbiAgICB9XG4gIH1cblxuICBpZiAocmMgPT09IDApIHtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhpcy5fb25Db25uZWN0KHBhY2tldClcbiAgfSBlbHNlIGlmIChyYyA+IDApIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIHJlZnVzZWQ6ICcgKyBlcnJvcnNbcmNdKVxuICAgIGVyci5jb2RlID0gcmNcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG59XG5cbi8qKlxuICogX2hhbmRsZVB1Ymxpc2hcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuLypcbnRob3NlIGxhdGUgMiBjYXNlIHNob3VsZCBiZSByZXdyaXRlIHRvIGNvbXBseSB3aXRoIGNvZGluZyBzdHlsZTpcblxuY2FzZSAxOlxuY2FzZSAwOlxuICAvLyBkbyBub3Qgd2FpdCBzZW5kaW5nIGEgcHViYWNrXG4gIC8vIG5vIGNhbGxiYWNrIHBhc3NlZFxuICBpZiAoMSA9PT0gcW9zKSB7XG4gICAgdGhpcy5fc2VuZFBhY2tldCh7XG4gICAgICBjbWQ6ICdwdWJhY2snLFxuICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWRcbiAgICB9KTtcbiAgfVxuICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50IGZvciBib3RoIHFvcyAxIGFuZCAwXG4gIHRoaXMuZW1pdCgnbWVzc2FnZScsIHRvcGljLCBtZXNzYWdlLCBwYWNrZXQpO1xuICB0aGlzLmhhbmRsZU1lc3NhZ2UocGFja2V0LCBkb25lKTtcbiAgYnJlYWs7XG5kZWZhdWx0OlxuICAvLyBkbyBub3RoaW5nIGJ1dCBldmVyeSBzd2l0Y2ggbXVzIGhhdmUgYSBkZWZhdWx0XG4gIC8vIGxvZyBvciB0aHJvdyBhbiBlcnJvciBhYm91dCB1bmtub3duIHFvc1xuICBicmVhaztcblxuZm9yIG5vdyBpIGp1c3Qgc3VwcHJlc3NlZCB0aGUgd2FybmluZ3NcbiovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlUHVibGlzaCA9IGZ1bmN0aW9uIChwYWNrZXQsIGRvbmUpIHtcbiAgZGVidWcoJ19oYW5kbGVQdWJsaXNoOiBwYWNrZXQgJW8nLCBwYWNrZXQpXG4gIGRvbmUgPSB0eXBlb2YgZG9uZSAhPT0gJ3VuZGVmaW5lZCcgPyBkb25lIDogbm9wXG4gIHZhciB0b3BpYyA9IHBhY2tldC50b3BpYy50b1N0cmluZygpXG4gIHZhciBtZXNzYWdlID0gcGFja2V0LnBheWxvYWRcbiAgdmFyIHFvcyA9IHBhY2tldC5xb3NcbiAgdmFyIG1lc3NhZ2VJZCA9IHBhY2tldC5tZXNzYWdlSWRcbiAgdmFyIHRoYXQgPSB0aGlzXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gIHZhciB2YWxpZFJlYXNvbkNvZGVzID0gWzAsIDE2LCAxMjgsIDEzMSwgMTM1LCAxNDQsIDE0NSwgMTUxLCAxNTNdXG4gIGRlYnVnKCdfaGFuZGxlUHVibGlzaDogcW9zICVkJywgcW9zKVxuICBzd2l0Y2ggKHFvcykge1xuICAgIGNhc2UgMjoge1xuICAgICAgb3B0aW9ucy5jdXN0b21IYW5kbGVBY2tzKHRvcGljLCBtZXNzYWdlLCBwYWNrZXQsIGZ1bmN0aW9uIChlcnJvciwgY29kZSkge1xuICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIGNvZGUgPSBlcnJvclxuICAgICAgICAgIGVycm9yID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcikgeyByZXR1cm4gdGhhdC5lbWl0KCdlcnJvcicsIGVycm9yKSB9XG4gICAgICAgIGlmICh2YWxpZFJlYXNvbkNvZGVzLmluZGV4T2YoY29kZSkgPT09IC0xKSB7IHJldHVybiB0aGF0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdXcm9uZyByZWFzb24gY29kZSBmb3IgcHVicmVjJykpIH1cbiAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICB0aGF0Ll9zZW5kUGFja2V0KHtjbWQ6ICdwdWJyZWMnLCBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCwgcmVhc29uQ29kZTogY29kZX0sIGRvbmUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhhdC5pbmNvbWluZ1N0b3JlLnB1dChwYWNrZXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoe2NtZDogJ3B1YnJlYycsIG1lc3NhZ2VJZDogbWVzc2FnZUlkfSwgZG9uZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAxOiB7XG4gICAgICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50XG4gICAgICBvcHRpb25zLmN1c3RvbUhhbmRsZUFja3ModG9waWMsIG1lc3NhZ2UsIHBhY2tldCwgZnVuY3Rpb24gKGVycm9yLCBjb2RlKSB7XG4gICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgY29kZSA9IGVycm9yXG4gICAgICAgICAgZXJyb3IgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yKSB7IHJldHVybiB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyb3IpIH1cbiAgICAgICAgaWYgKHZhbGlkUmVhc29uQ29kZXMuaW5kZXhPZihjb2RlKSA9PT0gLTEpIHsgcmV0dXJuIHRoYXQuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1dyb25nIHJlYXNvbiBjb2RlIGZvciBwdWJhY2snKSkgfVxuICAgICAgICBpZiAoIWNvZGUpIHsgdGhhdC5lbWl0KCdtZXNzYWdlJywgdG9waWMsIG1lc3NhZ2UsIHBhY2tldCkgfVxuICAgICAgICB0aGF0LmhhbmRsZU1lc3NhZ2UocGFja2V0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUgJiYgZG9uZShlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoYXQuX3NlbmRQYWNrZXQoe2NtZDogJ3B1YmFjaycsIG1lc3NhZ2VJZDogbWVzc2FnZUlkLCByZWFzb25Db2RlOiBjb2RlfSwgZG9uZSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIDA6XG4gICAgICAvLyBlbWl0IHRoZSBtZXNzYWdlIGV2ZW50XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB0b3BpYywgbWVzc2FnZSwgcGFja2V0KVxuICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKHBhY2tldCwgZG9uZSlcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIGRlYnVnKCdfaGFuZGxlUHVibGlzaDogdW5rbm93biBRb1MuIERvaW5nIG5vdGhpbmcuJylcbiAgICAgIC8vIGxvZyBvciB0aHJvdyBhbiBlcnJvciBhYm91dCB1bmtub3duIHFvc1xuICAgICAgYnJlYWtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBtZXNzYWdlcyB3aXRoIGJhY2twcmVzc3VyZSBzdXBwb3J0LCBvbmUgYXQgYSB0aW1lLlxuICogT3ZlcnJpZGUgYXQgd2lsbC5cbiAqXG4gKiBAcGFyYW0gUGFja2V0IHBhY2tldCB0aGUgcGFja2V0XG4gKiBAcGFyYW0gRnVuY3Rpb24gY2FsbGJhY2sgY2FsbCB3aGVuIGZpbmlzaGVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKVxufVxuXG4vKipcbiAqIF9oYW5kbGVBY2tcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5faGFuZGxlQWNrID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFwib2ZmXCIgKi9cbiAgdmFyIG1lc3NhZ2VJZCA9IHBhY2tldC5tZXNzYWdlSWRcbiAgdmFyIHR5cGUgPSBwYWNrZXQuY21kXG4gIHZhciByZXNwb25zZSA9IG51bGxcbiAgdmFyIGNiID0gdGhpcy5vdXRnb2luZ1ttZXNzYWdlSWRdID8gdGhpcy5vdXRnb2luZ1ttZXNzYWdlSWRdLmNiIDogbnVsbFxuICB2YXIgdGhhdCA9IHRoaXNcbiAgdmFyIGVyclxuXG4gIGlmICghY2IpIHtcbiAgICBkZWJ1ZygnX2hhbmRsZUFjayA6OiBTZXJ2ZXIgc2VudCBhbiBhY2sgaW4gZXJyb3IuIElnbm9yaW5nLicpXG4gICAgLy8gU2VydmVyIHNlbnQgYW4gYWNrIGluIGVycm9yLCBpZ25vcmUgaXQuXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBQcm9jZXNzXG4gIGRlYnVnKCdfaGFuZGxlQWNrIDo6IHBhY2tldCB0eXBlJywgdHlwZSlcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncHViY29tcCc6XG4gICAgICAvLyBzYW1lIHRoaW5nIGFzIHB1YmFjayBmb3IgUW9TIDJcbiAgICBjYXNlICdwdWJhY2snOlxuICAgICAgdmFyIHB1YmFja1JDID0gcGFja2V0LnJlYXNvbkNvZGVcbiAgICAgIC8vIENhbGxiYWNrIC0gd2UncmUgZG9uZVxuICAgICAgaWYgKHB1YmFja1JDICYmIHB1YmFja1JDID4gMCAmJiBwdWJhY2tSQyAhPT0gMTYpIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKCdQdWJsaXNoIGVycm9yOiAnICsgZXJyb3JzW3B1YmFja1JDXSlcbiAgICAgICAgZXJyLmNvZGUgPSBwdWJhY2tSQ1xuICAgICAgICBjYihlcnIsIHBhY2tldClcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21lc3NhZ2VJZF1cbiAgICAgIHRoaXMub3V0Z29pbmdTdG9yZS5kZWwocGFja2V0LCBjYilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncHVicmVjJzpcbiAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICBjbWQ6ICdwdWJyZWwnLFxuICAgICAgICBxb3M6IDIsXG4gICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkXG4gICAgICB9XG4gICAgICB2YXIgcHVicmVjUkMgPSBwYWNrZXQucmVhc29uQ29kZVxuXG4gICAgICBpZiAocHVicmVjUkMgJiYgcHVicmVjUkMgPiAwICYmIHB1YnJlY1JDICE9PSAxNikge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ1B1Ymxpc2ggZXJyb3I6ICcgKyBlcnJvcnNbcHVicmVjUkNdKVxuICAgICAgICBlcnIuY29kZSA9IHB1YnJlY1JDXG4gICAgICAgIGNiKGVyciwgcGFja2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VuZFBhY2tldChyZXNwb25zZSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnc3ViYWNrJzpcbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21lc3NhZ2VJZF1cbiAgICAgIGZvciAodmFyIGdyYW50ZWRJID0gMDsgZ3JhbnRlZEkgPCBwYWNrZXQuZ3JhbnRlZC5sZW5ndGg7IGdyYW50ZWRJKyspIHtcbiAgICAgICAgaWYgKChwYWNrZXQuZ3JhbnRlZFtncmFudGVkSV0gJiAweDgwKSAhPT0gMCkge1xuICAgICAgICAgIC8vIHN1YmFjayB3aXRoIEZhaWx1cmUgc3RhdHVzXG4gICAgICAgICAgdmFyIHRvcGljcyA9IHRoaXMubWVzc2FnZUlkVG9Ub3BpY1ttZXNzYWdlSWRdXG4gICAgICAgICAgaWYgKHRvcGljcykge1xuICAgICAgICAgICAgdG9waWNzLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9yZXN1YnNjcmliZVRvcGljc1t0b3BpY11cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYihudWxsLCBwYWNrZXQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3Vuc3ViYWNrJzpcbiAgICAgIGRlbGV0ZSB0aGlzLm91dGdvaW5nW21lc3NhZ2VJZF1cbiAgICAgIGNiKG51bGwpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgcGFja2V0IHR5cGUnKSlcbiAgfVxuXG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RpbmcgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMub3V0Z29pbmcpLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuZW1pdCgnb3V0Z29pbmdFbXB0eScpXG4gIH1cbn1cblxuLyoqXG4gKiBfaGFuZGxlUHVicmVsXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVQdWJyZWwgPSBmdW5jdGlvbiAocGFja2V0LCBjYWxsYmFjaykge1xuICBkZWJ1ZygnaGFuZGxpbmcgcHVicmVsIHBhY2tldCcpXG4gIGNhbGxiYWNrID0gdHlwZW9mIGNhbGxiYWNrICE9PSAndW5kZWZpbmVkJyA/IGNhbGxiYWNrIDogbm9wXG4gIHZhciBtZXNzYWdlSWQgPSBwYWNrZXQubWVzc2FnZUlkXG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIHZhciBjb21wID0ge2NtZDogJ3B1YmNvbXAnLCBtZXNzYWdlSWQ6IG1lc3NhZ2VJZH1cblxuICB0aGF0LmluY29taW5nU3RvcmUuZ2V0KHBhY2tldCwgZnVuY3Rpb24gKGVyciwgcHViKSB7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIHRoYXQuZW1pdCgnbWVzc2FnZScsIHB1Yi50b3BpYywgcHViLnBheWxvYWQsIHB1YilcbiAgICAgIHRoYXQuaGFuZGxlTWVzc2FnZShwdWIsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5pbmNvbWluZ1N0b3JlLmRlbChwdWIsIG5vcClcbiAgICAgICAgdGhhdC5fc2VuZFBhY2tldChjb21wLCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX3NlbmRQYWNrZXQoY29tcCwgY2FsbGJhY2spXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIF9oYW5kbGVEaXNjb25uZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9oYW5kbGVEaXNjb25uZWN0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBwYWNrZXQpXG59XG5cbi8qKlxuICogX25leHRJZFxuICogQHJldHVybiB1bnNpZ25lZCBpbnRcbiAqL1xuTXF0dENsaWVudC5wcm90b3R5cGUuX25leHRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gaWQgYmVjb21lcyBjdXJyZW50IHN0YXRlIG9mIHRoaXMubmV4dElkIGFuZCBpbmNyZW1lbnRzIGFmdGVyd2FyZHNcbiAgdmFyIGlkID0gdGhpcy5uZXh0SWQrK1xuICAvLyBFbnN1cmUgMTYgYml0IHVuc2lnbmVkIGludCAobWF4IDY1NTM1LCBuZXh0SWQgZ290IG9uZSBoaWdoZXIpXG4gIGlmICh0aGlzLm5leHRJZCA9PT0gNjU1MzYpIHtcbiAgICB0aGlzLm5leHRJZCA9IDFcbiAgfVxuICByZXR1cm4gaWRcbn1cblxuLyoqXG4gKiBnZXRMYXN0TWVzc2FnZUlkXG4gKiBAcmV0dXJuIHVuc2lnbmVkIGludFxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5nZXRMYXN0TWVzc2FnZUlkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMubmV4dElkID09PSAxKSA/IDY1NTM1IDogKHRoaXMubmV4dElkIC0gMSlcbn1cblxuLyoqXG4gKiBfcmVzdWJzY3JpYmVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5NcXR0Q2xpZW50LnByb3RvdHlwZS5fcmVzdWJzY3JpYmUgPSBmdW5jdGlvbiAoY29ubmFjaykge1xuICBkZWJ1ZygnX3Jlc3Vic2NyaWJlJylcbiAgdmFyIF9yZXN1YnNjcmliZVRvcGljc0tleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9yZXN1YnNjcmliZVRvcGljcylcbiAgaWYgKCF0aGlzLl9maXJzdENvbm5lY3Rpb24gJiZcbiAgICAgICh0aGlzLm9wdGlvbnMuY2xlYW4gfHwgKHRoaXMub3B0aW9ucy5wcm90b2NvbFZlcnNpb24gPT09IDUgJiYgIWNvbm5hY2suc2Vzc2lvblByZXNlbnQpKSAmJlxuICAgICAgX3Jlc3Vic2NyaWJlVG9waWNzS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXN1YnNjcmliZSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICAgICAgZGVidWcoJ19yZXN1YnNjcmliZTogcHJvdG9jb2xWZXJzaW9uIDUnKVxuICAgICAgICBmb3IgKHZhciB0b3BpY0kgPSAwOyB0b3BpY0kgPCBfcmVzdWJzY3JpYmVUb3BpY3NLZXlzLmxlbmd0aDsgdG9waWNJKyspIHtcbiAgICAgICAgICB2YXIgcmVzdWJzY3JpYmVUb3BpYyA9IHt9XG4gICAgICAgICAgcmVzdWJzY3JpYmVUb3BpY1tfcmVzdWJzY3JpYmVUb3BpY3NLZXlzW3RvcGljSV1dID0gdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3NbX3Jlc3Vic2NyaWJlVG9waWNzS2V5c1t0b3BpY0ldXVxuICAgICAgICAgIHJlc3Vic2NyaWJlVG9waWMucmVzdWJzY3JpYmUgPSB0cnVlXG4gICAgICAgICAgdGhpcy5zdWJzY3JpYmUocmVzdWJzY3JpYmVUb3BpYywge3Byb3BlcnRpZXM6IHJlc3Vic2NyaWJlVG9waWNbX3Jlc3Vic2NyaWJlVG9waWNzS2V5c1t0b3BpY0ldXS5wcm9wZXJ0aWVzfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWJzY3JpYmVUb3BpY3MucmVzdWJzY3JpYmUgPSB0cnVlXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKHRoaXMuX3Jlc3Vic2NyaWJlVG9waWNzKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXN1YnNjcmliZVRvcGljcyA9IHt9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fZmlyc3RDb25uZWN0aW9uID0gZmFsc2Vcbn1cblxuLyoqXG4gKiBfb25Db25uZWN0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbk1xdHRDbGllbnQucHJvdG90eXBlLl9vbkNvbm5lY3QgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkge1xuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIHBhY2tldClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIHRoaXMuX3NldHVwUGluZ1RpbWVyKClcbiAgdGhpcy5fcmVzdWJzY3JpYmUocGFja2V0KVxuXG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZVxuXG4gIGZ1bmN0aW9uIHN0YXJ0U3RyZWFtUHJvY2VzcyAoKSB7XG4gICAgdmFyIG91dFN0b3JlID0gdGhhdC5vdXRnb2luZ1N0b3JlLmNyZWF0ZVN0cmVhbSgpXG5cbiAgICBmdW5jdGlvbiBjbGVhclN0b3JlUHJvY2Vzc2luZyAoKSB7XG4gICAgICB0aGF0Ll9zdG9yZVByb2Nlc3NpbmcgPSBmYWxzZVxuICAgICAgdGhhdC5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nID0ge31cbiAgICB9XG5cbiAgICB0aGF0Lm9uY2UoJ2Nsb3NlJywgcmVtb3ZlKVxuICAgIG91dFN0b3JlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGNsZWFyU3RvcmVQcm9jZXNzaW5nKClcbiAgICAgIHRoYXQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgcmVtb3ZlKVxuICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIG91dFN0b3JlLmRlc3Ryb3koKVxuICAgICAgb3V0U3RvcmUgPSBudWxsXG4gICAgICBjbGVhclN0b3JlUHJvY2Vzc2luZygpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcmVEZWxpdmVyICgpIHtcbiAgICAgIC8vIGVkZ2UgY2FzZSwgd2Ugd3JhcHBlZCB0aGlzIHR3aWNlXG4gICAgICBpZiAoIW91dFN0b3JlKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhhdC5fc3RvcmVQcm9jZXNzaW5nID0gdHJ1ZVxuXG4gICAgICB2YXIgcGFja2V0ID0gb3V0U3RvcmUucmVhZCgxKVxuXG4gICAgICB2YXIgY2JcblxuICAgICAgaWYgKCFwYWNrZXQpIHtcbiAgICAgICAgLy8gcmVhZCB3aGVuIGRhdGEgaXMgYXZhaWxhYmxlIGluIHRoZSBmdXR1cmVcbiAgICAgICAgb3V0U3RvcmUub25jZSgncmVhZGFibGUnLCBzdG9yZURlbGl2ZXIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGFscmVhZHkgcHJvY2Vzc2VkIHN0b3JlIHBhY2tldHNcbiAgICAgIGlmICh0aGF0Ll9wYWNrZXRJZHNEdXJpbmdTdG9yZVByb2Nlc3NpbmdbcGFja2V0Lm1lc3NhZ2VJZF0pIHtcbiAgICAgICAgc3RvcmVEZWxpdmVyKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IHN0cmVhbSByZWFkIG9wZXJhdGlvbnMgd2hlbiBkaXNjb25uZWN0ZWRcbiAgICAgIGlmICghdGhhdC5kaXNjb25uZWN0aW5nICYmICF0aGF0LnJlY29ubmVjdFRpbWVyKSB7XG4gICAgICAgIGNiID0gdGhhdC5vdXRnb2luZ1twYWNrZXQubWVzc2FnZUlkXSA/IHRoYXQub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0uY2IgOiBudWxsXG4gICAgICAgIHRoYXQub3V0Z29pbmdbcGFja2V0Lm1lc3NhZ2VJZF0gPSB7XG4gICAgICAgICAgdm9sYXRpbGU6IGZhbHNlLFxuICAgICAgICAgIGNiOiBmdW5jdGlvbiAoZXJyLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvcmlnaW5hbCBjYWxsYmFjayBwYXNzZWQgaW4gdG8gcHVibGlzaCBnZXRzIGludm9rZWRcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICBjYihlcnIsIHN0YXR1cylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmVEZWxpdmVyKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fcGFja2V0SWRzRHVyaW5nU3RvcmVQcm9jZXNzaW5nW3BhY2tldC5tZXNzYWdlSWRdID0gdHJ1ZVxuICAgICAgICB0aGF0Ll9zZW5kUGFja2V0KHBhY2tldClcbiAgICAgIH0gZWxzZSBpZiAob3V0U3RvcmUuZGVzdHJveSkge1xuICAgICAgICBvdXRTdG9yZS5kZXN0cm95KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRTdG9yZS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFsbFByb2Nlc3NlZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGlkIGluIHRoYXQuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZykge1xuICAgICAgICBpZiAoIXRoYXQuX3BhY2tldElkc0R1cmluZ1N0b3JlUHJvY2Vzc2luZ1tpZF0pIHtcbiAgICAgICAgICBhbGxQcm9jZXNzZWQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbGxQcm9jZXNzZWQpIHtcbiAgICAgICAgY2xlYXJTdG9yZVByb2Nlc3NpbmcoKVxuICAgICAgICB0aGF0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHJlbW92ZSlcbiAgICAgICAgdGhhdC5lbWl0KCdjb25uZWN0JywgcGFja2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRTdHJlYW1Qcm9jZXNzKClcbiAgICAgIH1cbiAgICB9KVxuICAgIHN0b3JlRGVsaXZlcigpXG4gIH1cbiAgLy8gc3RhcnQgZmxvd2luZ1xuICBzdGFydFN0cmVhbVByb2Nlc3MoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1xdHRDbGllbnRcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9zdG9yZVwiOjcsXCIuL3ZhbGlkYXRpb25zXCI6OCxcIl9wcm9jZXNzXCI6MTAwLFwiZGVidWdcIjoxNyxcImV2ZW50c1wiOjgzLFwiaW5oZXJpdHNcIjo4OCxcIm1xdHQtcGFja2V0XCI6OTIsXCJyZWFkYWJsZS1zdHJlYW1cIjoxMTYsXCJyZWludGVydmFsXCI6MTE3LFwieHRlbmRcIjoxNDB9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoQnVmZmVyKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5JylcbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuXG4vKiBnbG9iYWwgRmlsZVJlYWRlciAqL1xudmFyIG15XG52YXIgcHJveHlcbnZhciBzdHJlYW1cbnZhciBpc0luaXRpYWxpemVkID0gZmFsc2VcblxuZnVuY3Rpb24gYnVpbGRQcm94eSAoKSB7XG4gIHZhciBwcm94eSA9IG5ldyBUcmFuc2Zvcm0oKVxuICBwcm94eS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBuZXh0KSB7XG4gICAgbXkuc2VuZFNvY2tldE1lc3NhZ2Uoe1xuICAgICAgZGF0YTogY2h1bmsuYnVmZmVyLFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0KClcbiAgICAgIH0sXG4gICAgICBmYWlsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHQobmV3IEVycm9yKCkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBwcm94eS5fZmx1c2ggPSBmdW5jdGlvbiBzb2NrZXRFbmQgKGRvbmUpIHtcbiAgICBteS5jbG9zZVNvY2tldCh7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcHJveHlcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdE9wdHMgKG9wdHMpIHtcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9ICdsb2NhbGhvc3QnXG4gIH1cbiAgaWYgKCFvcHRzLnBhdGgpIHtcbiAgICBvcHRzLnBhdGggPSAnLydcbiAgfVxuXG4gIGlmICghb3B0cy53c09wdGlvbnMpIHtcbiAgICBvcHRzLndzT3B0aW9ucyA9IHt9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRVcmwgKG9wdHMsIGNsaWVudCkge1xuICB2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sID09PSAnYWxpcycgPyAnd3NzJyA6ICd3cydcbiAgdmFyIHVybCA9IHByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgb3B0cy5wYXRoXG4gIGlmIChvcHRzLnBvcnQgJiYgb3B0cy5wb3J0ICE9PSA4MCAmJiBvcHRzLnBvcnQgIT09IDQ0Mykge1xuICAgIHVybCA9IHByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgJzonICsgb3B0cy5wb3J0ICsgb3B0cy5wYXRoXG4gIH1cbiAgaWYgKHR5cGVvZiAob3B0cy50cmFuc2Zvcm1Xc1VybCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cmwgPSBvcHRzLnRyYW5zZm9ybVdzVXJsKHVybCwgb3B0cywgY2xpZW50KVxuICB9XG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gYmluZEV2ZW50SGFuZGxlciAoKSB7XG4gIGlmIChpc0luaXRpYWxpemVkKSByZXR1cm5cblxuICBpc0luaXRpYWxpemVkID0gdHJ1ZVxuXG4gIG15Lm9uU29ja2V0T3BlbihmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnNldFJlYWRhYmxlKHByb3h5KVxuICAgIHN0cmVhbS5zZXRXcml0YWJsZShwcm94eSlcbiAgICBzdHJlYW0uZW1pdCgnY29ubmVjdCcpXG4gIH0pXG5cbiAgbXkub25Tb2NrZXRNZXNzYWdlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAodHlwZW9mIHJlcy5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGFycmF5ID0gYmFzZTY0LnRvQnl0ZUFycmF5KHJlcy5kYXRhKVxuICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGFycmF5KVxuICAgICAgcHJveHkucHVzaChidWZmZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSByZWFkZXIucmVzdWx0XG5cbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgICAgIGVsc2UgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICd1dGY4JylcbiAgICAgICAgcHJveHkucHVzaChkYXRhKVxuICAgICAgfSlcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihyZXMuZGF0YSlcbiAgICB9XG4gIH0pXG5cbiAgbXkub25Tb2NrZXRDbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLmVuZCgpXG4gICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9KVxuXG4gIG15Lm9uU29ja2V0RXJyb3IoZnVuY3Rpb24gKHJlcykge1xuICAgIHN0cmVhbS5kZXN0cm95KHJlcylcbiAgfSlcbn1cblxuZnVuY3Rpb24gYnVpbGRTdHJlYW0gKGNsaWVudCwgb3B0cykge1xuICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3RcblxuICBpZiAoIW9wdHMuaG9zdG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgaG9zdC4gU3BlY2lmeSBob3N0IG1hbnVhbGx5LicpXG4gIH1cblxuICB2YXIgd2Vic29ja2V0U3ViUHJvdG9jb2wgPVxuICAgIChvcHRzLnByb3RvY29sSWQgPT09ICdNUUlzZHAnKSAmJiAob3B0cy5wcm90b2NvbFZlcnNpb24gPT09IDMpXG4gICAgICA/ICdtcXR0djMuMSdcbiAgICAgIDogJ21xdHQnXG5cbiAgc2V0RGVmYXVsdE9wdHMob3B0cylcblxuICB2YXIgdXJsID0gYnVpbGRVcmwob3B0cywgY2xpZW50KVxuICBteSA9IG9wdHMubXlcbiAgbXkuY29ubmVjdFNvY2tldCh7XG4gICAgdXJsOiB1cmwsXG4gICAgcHJvdG9jb2xzOiB3ZWJzb2NrZXRTdWJQcm90b2NvbFxuICB9KVxuXG4gIHByb3h5ID0gYnVpbGRQcm94eSgpXG4gIHN0cmVhbSA9IGR1cGxleGlmeS5vYmooKVxuXG4gIGJpbmRFdmVudEhhbmRsZXIoKVxuXG4gIHJldHVybiBzdHJlYW1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZFN0cmVhbVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG59LHtcImJhc2U2NC1qc1wiOjEwLFwiYnVmZmVyXCI6MTIsXCJkdXBsZXhpZnlcIjoxOSxcInJlYWRhYmxlLXN0cmVhbVwiOjExNn1dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0JylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21xdHRqczp0Y3AnKVxuXG4vKlxuICB2YXJpYWJsZXMgcG9ydCBhbmQgaG9zdCBjYW4gYmUgcmVtb3ZlZCBzaW5jZVxuICB5b3UgaGF2ZSBhbGwgcmVxdWlyZWQgaW5mb3JtYXRpb24gaW4gb3B0cyBvYmplY3RcbiovXG5mdW5jdGlvbiBzdHJlYW1CdWlsZGVyIChjbGllbnQsIG9wdHMpIHtcbiAgdmFyIHBvcnQsIGhvc3RcbiAgb3B0cy5wb3J0ID0gb3B0cy5wb3J0IHx8IDE4ODNcbiAgb3B0cy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0IHx8ICdsb2NhbGhvc3QnXG5cbiAgcG9ydCA9IG9wdHMucG9ydFxuICBob3N0ID0gb3B0cy5ob3N0bmFtZVxuXG4gIGRlYnVnKCdwb3J0ICVkIGFuZCBob3N0ICVzJywgcG9ydCwgaG9zdClcbiAgcmV0dXJuIG5ldC5jcmVhdGVDb25uZWN0aW9uKHBvcnQsIGhvc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyZWFtQnVpbGRlclxuXG59LHtcImRlYnVnXCI6MTcsXCJuZXRcIjoxMX1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG52YXIgdGxzID0gcmVxdWlyZSgndGxzJylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21xdHRqczp0bHMnKVxuXG5mdW5jdGlvbiBidWlsZEJ1aWxkZXIgKG1xdHRDbGllbnQsIG9wdHMpIHtcbiAgdmFyIGNvbm5lY3Rpb25cbiAgb3B0cy5wb3J0ID0gb3B0cy5wb3J0IHx8IDg4ODNcbiAgb3B0cy5ob3N0ID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3QgfHwgJ2xvY2FsaG9zdCdcbiAgb3B0cy5zZXJ2ZXJuYW1lID0gb3B0cy5ob3N0XG5cbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gZmFsc2VcblxuICBkZWxldGUgb3B0cy5wYXRoXG5cbiAgZGVidWcoJ3BvcnQgJWQgaG9zdCAlcyByZWplY3RVbmF1dGhvcml6ZWQgJWInLCBvcHRzLnBvcnQsIG9wdHMuaG9zdCwgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQpXG5cbiAgY29ubmVjdGlvbiA9IHRscy5jb25uZWN0KG9wdHMpXG4gIC8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTogWzIsIFwibm9mdW5jXCJdICovXG4gIGNvbm5lY3Rpb24ub24oJ3NlY3VyZUNvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG9wdHMucmVqZWN0VW5hdXRob3JpemVkICYmICFjb25uZWN0aW9uLmF1dGhvcml6ZWQpIHtcbiAgICAgIGNvbm5lY3Rpb24uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1RMUyBub3QgYXV0aG9yaXplZCcpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVRMU2Vycm9ycylcbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gaGFuZGxlVExTZXJyb3JzIChlcnIpIHtcbiAgICAvLyBIb3cgY2FuIEkgZ2V0IHZlcmlmeSB0aGlzIGVycm9yIGlzIGEgdGxzIGVycm9yP1xuICAgIGlmIChvcHRzLnJlamVjdFVuYXV0aG9yaXplZCkge1xuICAgICAgbXF0dENsaWVudC5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9XG5cbiAgICAvLyBjbG9zZSB0aGlzIGNvbm5lY3Rpb24gdG8gbWF0Y2ggdGhlIGJlaGF2aW91ciBvZiBuZXRcbiAgICAvLyBvdGhlcndpc2UgYWxsIHdlIGdldCBpcyBhbiBlcnJvciBmcm9tIHRoZSBjb25uZWN0aW9uXG4gICAgLy8gYW5kIGNsb3NlIGV2ZW50IGRvZXNuJ3QgZmlyZS4gVGhpcyBpcyBhIHdvcmsgYXJvdW5kXG4gICAgLy8gdG8gZW5hYmxlIHRoZSByZWNvbm5lY3QgY29kZSB0byB3b3JrIHRoZSBzYW1lIGFzIHdpdGhcbiAgICAvLyBuZXQuY3JlYXRlQ29ubmVjdGlvblxuICAgIGNvbm5lY3Rpb24uZW5kKClcbiAgfVxuXG4gIGNvbm5lY3Rpb24ub24oJ2Vycm9yJywgaGFuZGxlVExTZXJyb3JzKVxuICByZXR1cm4gY29ubmVjdGlvblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkQnVpbGRlclxuXG59LHtcImRlYnVnXCI6MTcsXCJ0bHNcIjoxMX1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtcXR0anM6d3MnKVxudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJ3dlYnNvY2tldC1zdHJlYW0nKVxudmFyIHVybE1vZHVsZSA9IHJlcXVpcmUoJ3VybCcpXG52YXIgV1NTX09QVElPTlMgPSBbXG4gICdyZWplY3RVbmF1dGhvcml6ZWQnLFxuICAnY2EnLFxuICAnY2VydCcsXG4gICdrZXknLFxuICAncGZ4JyxcbiAgJ3Bhc3NwaHJhc2UnXG5dXG52YXIgSVNfQlJPV1NFUiA9IHByb2Nlc3MudGl0bGUgPT09ICdicm93c2VyJ1xuXG5mdW5jdGlvbiBidWlsZFVybCAob3B0cywgY2xpZW50KSB7XG4gIHZhciB1cmwgPSBvcHRzLnByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgJzonICsgb3B0cy5wb3J0ICsgb3B0cy5wYXRoXG4gIGlmICh0eXBlb2YgKG9wdHMudHJhbnNmb3JtV3NVcmwpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXJsID0gb3B0cy50cmFuc2Zvcm1Xc1VybCh1cmwsIG9wdHMsIGNsaWVudClcbiAgfVxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRPcHRzIChvcHRzKSB7XG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSAnbG9jYWxob3N0J1xuICB9XG4gIGlmICghb3B0cy5wb3J0KSB7XG4gICAgaWYgKG9wdHMucHJvdG9jb2wgPT09ICd3c3MnKSB7XG4gICAgICBvcHRzLnBvcnQgPSA0NDNcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5wb3J0ID0gODBcbiAgICB9XG4gIH1cbiAgaWYgKCFvcHRzLnBhdGgpIHtcbiAgICBvcHRzLnBhdGggPSAnLydcbiAgfVxuXG4gIGlmICghb3B0cy53c09wdGlvbnMpIHtcbiAgICBvcHRzLndzT3B0aW9ucyA9IHt9XG4gIH1cbiAgaWYgKCFJU19CUk9XU0VSICYmIG9wdHMucHJvdG9jb2wgPT09ICd3c3MnKSB7XG4gICAgLy8gQWRkIGNlcnQva2V5L2NhIGV0YyBvcHRpb25zXG4gICAgV1NTX09QVElPTlMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgIW9wdHMud3NPcHRpb25zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIG9wdHMud3NPcHRpb25zW3Byb3BdID0gb3B0c1twcm9wXVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0IChjbGllbnQsIG9wdHMpIHtcbiAgZGVidWcoJ2NyZWF0ZVdlYlNvY2tldCcpXG4gIHZhciB3ZWJzb2NrZXRTdWJQcm90b2NvbCA9XG4gICAgKG9wdHMucHJvdG9jb2xJZCA9PT0gJ01RSXNkcCcpICYmIChvcHRzLnByb3RvY29sVmVyc2lvbiA9PT0gMylcbiAgICAgID8gJ21xdHR2My4xJ1xuICAgICAgOiAnbXF0dCdcblxuICBzZXREZWZhdWx0T3B0cyhvcHRzKVxuICB2YXIgdXJsID0gYnVpbGRVcmwob3B0cywgY2xpZW50KVxuICBkZWJ1ZygndXJsICVzIHByb3RvY29sICVzJywgdXJsLCB3ZWJzb2NrZXRTdWJQcm90b2NvbClcbiAgcmV0dXJuIHdlYnNvY2tldCh1cmwsIFt3ZWJzb2NrZXRTdWJQcm90b2NvbF0sIG9wdHMud3NPcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdHJlYW1CdWlsZGVyIChjbGllbnQsIG9wdHMpIHtcbiAgcmV0dXJuIGNyZWF0ZVdlYlNvY2tldChjbGllbnQsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIGJyb3dzZXJTdHJlYW1CdWlsZGVyIChjbGllbnQsIG9wdHMpIHtcbiAgZGVidWcoJ2Jyb3dzZXJTdHJlYW1CdWlsZGVyJylcbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgb3B0cy5ob3N0bmFtZSA9IG9wdHMuaG9zdFxuICB9XG5cbiAgaWYgKCFvcHRzLmhvc3RuYW1lKSB7XG4gICAgLy8gVGhyb3dpbmcgYW4gZXJyb3IgaW4gYSBXZWIgV29ya2VyIGlmIG5vIGBob3N0bmFtZWAgaXMgZ2l2ZW4sIGJlY2F1c2Ugd2VcbiAgICAvLyBjYW4gbm90IGRldGVybWluZSB0aGUgYGhvc3RuYW1lYCBhdXRvbWF0aWNhbGx5LiAgSWYgY29ubmVjdGluZyB0b1xuICAgIC8vIGxvY2FsaG9zdCwgcGxlYXNlIHN1cHBseSB0aGUgYGhvc3RuYW1lYCBhcyBhbiBhcmd1bWVudC5cbiAgICBpZiAodHlwZW9mIChkb2N1bWVudCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgaG9zdC4gU3BlY2lmeSBob3N0IG1hbnVhbGx5LicpXG4gICAgfVxuICAgIHZhciBwYXJzZWQgPSB1cmxNb2R1bGUucGFyc2UoZG9jdW1lbnQuVVJMKVxuICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZWQuaG9zdG5hbWVcblxuICAgIGlmICghb3B0cy5wb3J0KSB7XG4gICAgICBvcHRzLnBvcnQgPSBwYXJzZWQucG9ydFxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlV2ViU29ja2V0KGNsaWVudCwgb3B0cylcbn1cblxuaWYgKElTX0JST1dTRVIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBicm93c2VyU3RyZWFtQnVpbGRlclxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBzdHJlYW1CdWlsZGVyXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCJfcHJvY2Vzc1wiOjEwMCxcImRlYnVnXCI6MTcsXCJ1cmxcIjoxMzIsXCJ3ZWJzb2NrZXQtc3RyZWFtXCI6MTM3fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsQnVmZmVyKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgZHVwbGV4aWZ5ID0gcmVxdWlyZSgnZHVwbGV4aWZ5JylcblxuLyogZ2xvYmFsIHd4ICovXG52YXIgc29ja2V0VGFza1xudmFyIHByb3h5XG52YXIgc3RyZWFtXG5cbmZ1bmN0aW9uIGJ1aWxkUHJveHkgKCkge1xuICB2YXIgcHJveHkgPSBuZXcgVHJhbnNmb3JtKClcbiAgcHJveHkuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgbmV4dCkge1xuICAgIHNvY2tldFRhc2suc2VuZCh7XG4gICAgICBkYXRhOiBjaHVuay5idWZmZXIsXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHQoKVxuICAgICAgfSxcbiAgICAgIGZhaWw6IGZ1bmN0aW9uIChlcnJNc2cpIHtcbiAgICAgICAgbmV4dChuZXcgRXJyb3IoZXJyTXNnKSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHByb3h5Ll9mbHVzaCA9IGZ1bmN0aW9uIHNvY2tldEVuZCAoZG9uZSkge1xuICAgIHNvY2tldFRhc2suY2xvc2Uoe1xuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHByb3h5XG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHRPcHRzIChvcHRzKSB7XG4gIGlmICghb3B0cy5ob3N0bmFtZSkge1xuICAgIG9wdHMuaG9zdG5hbWUgPSAnbG9jYWxob3N0J1xuICB9XG4gIGlmICghb3B0cy5wYXRoKSB7XG4gICAgb3B0cy5wYXRoID0gJy8nXG4gIH1cblxuICBpZiAoIW9wdHMud3NPcHRpb25zKSB7XG4gICAgb3B0cy53c09wdGlvbnMgPSB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVXJsIChvcHRzLCBjbGllbnQpIHtcbiAgdmFyIHByb3RvY29sID0gb3B0cy5wcm90b2NvbCA9PT0gJ3d4cycgPyAnd3NzJyA6ICd3cydcbiAgdmFyIHVybCA9IHByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgb3B0cy5wYXRoXG4gIGlmIChvcHRzLnBvcnQgJiYgb3B0cy5wb3J0ICE9PSA4MCAmJiBvcHRzLnBvcnQgIT09IDQ0Mykge1xuICAgIHVybCA9IHByb3RvY29sICsgJzovLycgKyBvcHRzLmhvc3RuYW1lICsgJzonICsgb3B0cy5wb3J0ICsgb3B0cy5wYXRoXG4gIH1cbiAgaWYgKHR5cGVvZiAob3B0cy50cmFuc2Zvcm1Xc1VybCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cmwgPSBvcHRzLnRyYW5zZm9ybVdzVXJsKHVybCwgb3B0cywgY2xpZW50KVxuICB9XG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gYmluZEV2ZW50SGFuZGxlciAoKSB7XG4gIHNvY2tldFRhc2sub25PcGVuKGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0uc2V0UmVhZGFibGUocHJveHkpXG4gICAgc3RyZWFtLnNldFdyaXRhYmxlKHByb3h5KVxuICAgIHN0cmVhbS5lbWl0KCdjb25uZWN0JylcbiAgfSlcblxuICBzb2NrZXRUYXNrLm9uTWVzc2FnZShmdW5jdGlvbiAocmVzKSB7XG4gICAgdmFyIGRhdGEgPSByZXMuZGF0YVxuXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgZWxzZSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKVxuICAgIHByb3h5LnB1c2goZGF0YSlcbiAgfSlcblxuICBzb2NrZXRUYXNrLm9uQ2xvc2UoZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5lbmQoKVxuICAgIHN0cmVhbS5kZXN0cm95KClcbiAgfSlcblxuICBzb2NrZXRUYXNrLm9uRXJyb3IoZnVuY3Rpb24gKHJlcykge1xuICAgIHN0cmVhbS5kZXN0cm95KG5ldyBFcnJvcihyZXMuZXJyTXNnKSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gYnVpbGRTdHJlYW0gKGNsaWVudCwgb3B0cykge1xuICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fCBvcHRzLmhvc3RcblxuICBpZiAoIW9wdHMuaG9zdG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgaG9zdC4gU3BlY2lmeSBob3N0IG1hbnVhbGx5LicpXG4gIH1cblxuICB2YXIgd2Vic29ja2V0U3ViUHJvdG9jb2wgPVxuICAgIChvcHRzLnByb3RvY29sSWQgPT09ICdNUUlzZHAnKSAmJiAob3B0cy5wcm90b2NvbFZlcnNpb24gPT09IDMpXG4gICAgICA/ICdtcXR0djMuMSdcbiAgICAgIDogJ21xdHQnXG5cbiAgc2V0RGVmYXVsdE9wdHMob3B0cylcblxuICB2YXIgdXJsID0gYnVpbGRVcmwob3B0cywgY2xpZW50KVxuICBzb2NrZXRUYXNrID0gd3guY29ubmVjdFNvY2tldCh7XG4gICAgdXJsOiB1cmwsXG4gICAgcHJvdG9jb2xzOiBbd2Vic29ja2V0U3ViUHJvdG9jb2xdXG4gIH0pXG5cbiAgcHJveHkgPSBidWlsZFByb3h5KClcbiAgc3RyZWFtID0gZHVwbGV4aWZ5Lm9iaigpXG4gIHN0cmVhbS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gICAgc29ja2V0VGFzay5jbG9zZSh7XG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNiICYmIGNiKGVycilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdmFyIGRlc3Ryb3lSZWYgPSBzdHJlYW0uZGVzdHJveVxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0uZGVzdHJveSA9IGRlc3Ryb3lSZWZcblxuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgc29ja2V0VGFzay5jbG9zZSh7XG4gICAgICAgIGZhaWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLl9kZXN0cm95KG5ldyBFcnJvcigpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0uYmluZChzdHJlYW0pXG5cbiAgYmluZEV2ZW50SGFuZGxlcigpXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkU3RyZWFtXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKVxufSx7XCJfcHJvY2Vzc1wiOjEwMCxcImJ1ZmZlclwiOjEyLFwiZHVwbGV4aWZ5XCI6MTksXCJyZWFkYWJsZS1zdHJlYW1cIjoxMTZ9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGVcbnZhciBzdHJlYW1zT3B0cyA9IHsgb2JqZWN0TW9kZTogdHJ1ZSB9XG52YXIgZGVmYXVsdFN0b3JlT3B0aW9ucyA9IHtcbiAgY2xlYW46IHRydWVcbn1cblxuLyoqXG4gKiBlczYtbWFwIGNhbiBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXIgZXZlbiBpZiBFUyB2ZXJzaW9uIGlzIG9sZGVyLlxuICpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcCNEZXNjcmlwdGlvblxuICogSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgYSBNYXAgd2hpY2ggaXMgYSBtYXAgb2YgYW4gb2JqZWN0LCBlc3BlY2lhbGx5XG4gKiBhIGRpY3Rpb25hcnkgb2YgZGljdGlvbmFyaWVzLCB3aWxsIG9ubHkgbWFwIHRvIHRoZSBvYmplY3QncyBpbnNlcnRpb25cbiAqIG9yZGVyLiBJbiBFUzIwMTUgdGhpcyBpcyBvcmRlcmVkIGZvciBvYmplY3RzIGJ1dCBmb3Igb2xkZXIgdmVyc2lvbnMgb2ZcbiAqIEVTLCB0aGlzIG1heSBiZSByYW5kb20gYW5kIG5vdCBvcmRlcmVkLlxuICpcbiAqL1xudmFyIE1hcCA9IHJlcXVpcmUoJ2VzNi1tYXAnKVxuXG4vKipcbiAqIEluLW1lbW9yeSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgbWVzc2FnZSBzdG9yZVxuICogVGhpcyBjYW4gYWN0dWFsbHkgYmUgc2F2ZWQgaW50byBmaWxlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gc3RvcmUgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBTdG9yZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RvcmUpKSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yZShvcHRpb25zKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIC8vIERlZmF1bHRzXG4gIHRoaXMub3B0aW9ucyA9IHh0ZW5kKGRlZmF1bHRTdG9yZU9wdGlvbnMsIG9wdGlvbnMpXG5cbiAgdGhpcy5faW5mbGlnaHRzID0gbmV3IE1hcCgpXG59XG5cbi8qKlxuICogQWRkcyBhIHBhY2tldCB0byB0aGUgc3RvcmUsIGEgcGFja2V0IGlzXG4gKiBhbnl0aGluZyB0aGF0IGhhcyBhIG1lc3NhZ2VJZCBwcm9wZXJ0eS5cbiAqXG4gKi9cblN0b3JlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICB0aGlzLl9pbmZsaWdodHMuc2V0KHBhY2tldC5tZXNzYWdlSWQsIHBhY2tldClcblxuICBpZiAoY2IpIHtcbiAgICBjYigpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdHJlYW0gd2l0aCBhbGwgdGhlIHBhY2tldHMgaW4gdGhlIHN0b3JlXG4gKlxuICovXG5TdG9yZS5wcm90b3R5cGUuY3JlYXRlU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyZWFtID0gbmV3IFJlYWRhYmxlKHN0cmVhbXNPcHRzKVxuICB2YXIgZGVzdHJveWVkID0gZmFsc2VcbiAgdmFyIHZhbHVlcyA9IFtdXG4gIHZhciBpID0gMFxuXG4gIHRoaXMuX2luZmxpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgdmFsdWVzLnB1c2godmFsdWUpXG4gIH0pXG5cbiAgc3RyZWFtLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGVzdHJveWVkICYmIGkgPCB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnB1c2godmFsdWVzW2krK10pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaChudWxsKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChkZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpc1xuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG4vKipcbiAqIGRlbGV0ZXMgYSBwYWNrZXQgZnJvbSB0aGUgc3RvcmUuXG4gKi9cblN0b3JlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICBwYWNrZXQgPSB0aGlzLl9pbmZsaWdodHMuZ2V0KHBhY2tldC5tZXNzYWdlSWQpXG4gIGlmIChwYWNrZXQpIHtcbiAgICB0aGlzLl9pbmZsaWdodHMuZGVsZXRlKHBhY2tldC5tZXNzYWdlSWQpXG4gICAgY2IobnVsbCwgcGFja2V0KVxuICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgY2IobmV3IEVycm9yKCdtaXNzaW5nIHBhY2tldCcpKVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBnZXQgYSBwYWNrZXQgZnJvbSB0aGUgc3RvcmUuXG4gKi9cblN0b3JlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFja2V0LCBjYikge1xuICBwYWNrZXQgPSB0aGlzLl9pbmZsaWdodHMuZ2V0KHBhY2tldC5tZXNzYWdlSWQpXG4gIGlmIChwYWNrZXQpIHtcbiAgICBjYihudWxsLCBwYWNrZXQpXG4gIH0gZWxzZSBpZiAoY2IpIHtcbiAgICBjYihuZXcgRXJyb3IoJ21pc3NpbmcgcGFja2V0JykpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENsb3NlIHRoZSBzdG9yZVxuICovXG5TdG9yZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5jbGVhbikge1xuICAgIHRoaXMuX2luZmxpZ2h0cyA9IG51bGxcbiAgfVxuICBpZiAoY2IpIHtcbiAgICBjYigpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdG9yZVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiX3Byb2Nlc3NcIjoxMDAsXCJlczYtbWFwXCI6NjgsXCJyZWFkYWJsZS1zdHJlYW1cIjoxMTYsXCJ4dGVuZFwiOjE0MH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogVmFsaWRhdGUgYSB0b3BpYyB0byBzZWUgaWYgaXQncyB2YWxpZCBvciBub3QuXG4gKiBBIHRvcGljIGlzIHZhbGlkIGlmIGl0IGZvbGxvdyBiZWxvdyBydWxlczpcbiAqIC0gUnVsZSAjMTogSWYgYW55IHBhcnQgb2YgdGhlIHRvcGljIGlzIG5vdCBgK2Agb3IgYCNgLCB0aGVuIGl0IG11c3Qgbm90IGNvbnRhaW4gYCtgIGFuZCAnIydcbiAqIC0gUnVsZSAjMjogUGFydCBgI2AgbXVzdCBiZSBsb2NhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIG1haWxib3hcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWMgLSBBIHRvcGljXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIHRvcGljIGlzIHZhbGlkLCByZXR1cm5zIHRydWUuIE90aGVyd2lzZSwgcmV0dXJucyBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUb3BpYyAodG9waWMpIHtcbiAgdmFyIHBhcnRzID0gdG9waWMuc3BsaXQoJy8nKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFydHNbaV0gPT09ICcrJykge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAocGFydHNbaV0gPT09ICcjJykge1xuICAgICAgLy8gZm9yIFJ1bGUgIzJcbiAgICAgIHJldHVybiBpID09PSBwYXJ0cy5sZW5ndGggLSAxXG4gICAgfVxuXG4gICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJysnKSAhPT0gLTEgfHwgcGFydHNbaV0uaW5kZXhPZignIycpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhbiBhcnJheSBvZiB0b3BpY3MgdG8gc2VlIGlmIGFueSBvZiB0aGVtIGlzIHZhbGlkIG9yIG5vdFxuICAqIEBwYXJhbSB7QXJyYXl9IHRvcGljcyAtIEFycmF5IG9mIHRvcGljc1xuICogQHJldHVybnMge1N0cmluZ30gSWYgdGhlIHRvcGljcyBpcyB2YWxpZCwgcmV0dXJucyBudWxsLiBPdGhlcndpc2UsIHJldHVybnMgdGhlIGludmFsaWQgb25lXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVG9waWNzICh0b3BpY3MpIHtcbiAgaWYgKHRvcGljcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ2VtcHR5X3RvcGljX2xpc3QnXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3BpY3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXZhbGlkYXRlVG9waWModG9waWNzW2ldKSkge1xuICAgICAgcmV0dXJuIHRvcGljc1tpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsaWRhdGVUb3BpY3M6IHZhbGlkYXRlVG9waWNzXG59XG5cbn0se31dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgTXF0dENsaWVudCA9IHJlcXVpcmUoJy4uL2NsaWVudCcpXG52YXIgU3RvcmUgPSByZXF1aXJlKCcuLi9zdG9yZScpXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJylcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21xdHRqcycpXG5cbnZhciBwcm90b2NvbHMgPSB7fVxuXG5pZiAocHJvY2Vzcy50aXRsZSAhPT0gJ2Jyb3dzZXInKSB7XG4gIHByb3RvY29scy5tcXR0ID0gcmVxdWlyZSgnLi90Y3AnKVxuICBwcm90b2NvbHMudGNwID0gcmVxdWlyZSgnLi90Y3AnKVxuICBwcm90b2NvbHMuc3NsID0gcmVxdWlyZSgnLi90bHMnKVxuICBwcm90b2NvbHMudGxzID0gcmVxdWlyZSgnLi90bHMnKVxuICBwcm90b2NvbHMubXF0dHMgPSByZXF1aXJlKCcuL3RscycpXG59IGVsc2Uge1xuICBwcm90b2NvbHMud3ggPSByZXF1aXJlKCcuL3d4JylcbiAgcHJvdG9jb2xzLnd4cyA9IHJlcXVpcmUoJy4vd3gnKVxuXG4gIHByb3RvY29scy5hbGkgPSByZXF1aXJlKCcuL2FsaScpXG4gIHByb3RvY29scy5hbGlzID0gcmVxdWlyZSgnLi9hbGknKVxufVxuXG5wcm90b2NvbHMud3MgPSByZXF1aXJlKCcuL3dzJylcbnByb3RvY29scy53c3MgPSByZXF1aXJlKCcuL3dzJylcblxuLyoqXG4gKiBQYXJzZSB0aGUgYXV0aCBhdHRyaWJ1dGUgYW5kIG1lcmdlIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBvcHRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXV0aE9wdGlvbnMgKG9wdHMpIHtcbiAgdmFyIG1hdGNoZXNcbiAgaWYgKG9wdHMuYXV0aCkge1xuICAgIG1hdGNoZXMgPSBvcHRzLmF1dGgubWF0Y2goL14oLispOiguKykkLylcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgb3B0cy51c2VybmFtZSA9IG1hdGNoZXNbMV1cbiAgICAgIG9wdHMucGFzc3dvcmQgPSBtYXRjaGVzWzJdXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMudXNlcm5hbWUgPSBvcHRzLmF1dGhcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBjb25uZWN0IC0gY29ubmVjdCB0byBhbiBNUVRUIGJyb2tlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW2Jyb2tlclVybF0gLSB1cmwgb2YgdGhlIGJyb2tlciwgb3B0aW9uYWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gc2VlIE1xdHRDbGllbnQjY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gY29ubmVjdCAoYnJva2VyVXJsLCBvcHRzKSB7XG4gIGRlYnVnKCdjb25uZWN0aW5nIHRvIGFuIE1RVFQgYnJva2VyLi4uJylcbiAgaWYgKCh0eXBlb2YgYnJva2VyVXJsID09PSAnb2JqZWN0JykgJiYgIW9wdHMpIHtcbiAgICBvcHRzID0gYnJva2VyVXJsXG4gICAgYnJva2VyVXJsID0gbnVsbFxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBpZiAoYnJva2VyVXJsKSB7XG4gICAgdmFyIHBhcnNlZCA9IHVybC5wYXJzZShicm9rZXJVcmwsIHRydWUpXG4gICAgaWYgKHBhcnNlZC5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gTnVtYmVyKHBhcnNlZC5wb3J0KVxuICAgIH1cblxuICAgIG9wdHMgPSB4dGVuZChwYXJzZWQsIG9wdHMpXG5cbiAgICBpZiAob3B0cy5wcm90b2NvbCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByb3RvY29sJylcbiAgICB9XG4gICAgb3B0cy5wcm90b2NvbCA9IG9wdHMucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJylcbiAgfVxuXG4gIC8vIG1lcmdlIGluIHRoZSBhdXRoIG9wdGlvbnMgaWYgc3VwcGxpZWRcbiAgcGFyc2VBdXRoT3B0aW9ucyhvcHRzKVxuXG4gIC8vIHN1cHBvcnQgY2xpZW50SWQgcGFzc2VkIGluIHRoZSBxdWVyeSBzdHJpbmcgb2YgdGhlIHVybFxuICBpZiAob3B0cy5xdWVyeSAmJiB0eXBlb2Ygb3B0cy5xdWVyeS5jbGllbnRJZCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRzLmNsaWVudElkID0gb3B0cy5xdWVyeS5jbGllbnRJZFxuICB9XG5cbiAgaWYgKG9wdHMuY2VydCAmJiBvcHRzLmtleSkge1xuICAgIGlmIChvcHRzLnByb3RvY29sKSB7XG4gICAgICBpZiAoWydtcXR0cycsICd3c3MnLCAnd3hzJywgJ2FsaXMnXS5pbmRleE9mKG9wdHMucHJvdG9jb2wpID09PSAtMSkge1xuICAgICAgICBzd2l0Y2ggKG9wdHMucHJvdG9jb2wpIHtcbiAgICAgICAgICBjYXNlICdtcXR0JzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnbXF0dHMnXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgJ3dzJzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnd3NzJ1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICd3eCc6XG4gICAgICAgICAgICBvcHRzLnByb3RvY29sID0gJ3d4cydcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAnYWxpJzpcbiAgICAgICAgICAgIG9wdHMucHJvdG9jb2wgPSAnYWxpcydcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcm90b2NvbCBmb3Igc2VjdXJlIGNvbm5lY3Rpb246IFwiJyArIG9wdHMucHJvdG9jb2wgKyAnXCIhJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBIGNlcnQgYW5kIGtleSB3YXMgcHJvdmlkZWQsIGhvd2V2ZXIgbm8gcHJvdG9jb2wgd2FzIHNwZWNpZmllZCwgc28gd2Ugd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzZWN1cmUgcHJvdG9jb2wga2V5JylcbiAgICB9XG4gIH1cblxuICBpZiAoIXByb3RvY29sc1tvcHRzLnByb3RvY29sXSkge1xuICAgIHZhciBpc1NlY3VyZSA9IFsnbXF0dHMnLCAnd3NzJ10uaW5kZXhPZihvcHRzLnByb3RvY29sKSAhPT0gLTFcbiAgICBvcHRzLnByb3RvY29sID0gW1xuICAgICAgJ21xdHQnLFxuICAgICAgJ21xdHRzJyxcbiAgICAgICd3cycsXG4gICAgICAnd3NzJyxcbiAgICAgICd3eCcsXG4gICAgICAnd3hzJyxcbiAgICAgICdhbGknLFxuICAgICAgJ2FsaXMnXG4gICAgXS5maWx0ZXIoZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgIGlmIChpc1NlY3VyZSAmJiBpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgLy8gU2tpcCBpbnNlY3VyZSBwcm90b2NvbHMgd2hlbiByZXF1ZXN0aW5nIGEgc2VjdXJlIG9uZS5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gKHR5cGVvZiBwcm90b2NvbHNba2V5XSA9PT0gJ2Z1bmN0aW9uJylcbiAgICB9KVswXVxuICB9XG5cbiAgaWYgKG9wdHMuY2xlYW4gPT09IGZhbHNlICYmICFvcHRzLmNsaWVudElkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNsaWVudElkIGZvciB1bmNsZWFuIGNsaWVudHMnKVxuICB9XG5cbiAgaWYgKG9wdHMucHJvdG9jb2wpIHtcbiAgICBvcHRzLmRlZmF1bHRQcm90b2NvbCA9IG9wdHMucHJvdG9jb2xcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIgKGNsaWVudCkge1xuICAgIGlmIChvcHRzLnNlcnZlcnMpIHtcbiAgICAgIGlmICghY2xpZW50Ll9yZWNvbm5lY3RDb3VudCB8fCBjbGllbnQuX3JlY29ubmVjdENvdW50ID09PSBvcHRzLnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNsaWVudC5fcmVjb25uZWN0Q291bnQgPSAwXG4gICAgICB9XG5cbiAgICAgIG9wdHMuaG9zdCA9IG9wdHMuc2VydmVyc1tjbGllbnQuX3JlY29ubmVjdENvdW50XS5ob3N0XG4gICAgICBvcHRzLnBvcnQgPSBvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0ucG9ydFxuICAgICAgb3B0cy5wcm90b2NvbCA9ICghb3B0cy5zZXJ2ZXJzW2NsaWVudC5fcmVjb25uZWN0Q291bnRdLnByb3RvY29sID8gb3B0cy5kZWZhdWx0UHJvdG9jb2wgOiBvcHRzLnNlcnZlcnNbY2xpZW50Ll9yZWNvbm5lY3RDb3VudF0ucHJvdG9jb2wpXG4gICAgICBvcHRzLmhvc3RuYW1lID0gb3B0cy5ob3N0XG5cbiAgICAgIGNsaWVudC5fcmVjb25uZWN0Q291bnQrK1xuICAgIH1cblxuICAgIGRlYnVnKCdjYWxsaW5nIHN0cmVhbWJ1aWxkZXIgZm9yJywgb3B0cy5wcm90b2NvbClcbiAgICByZXR1cm4gcHJvdG9jb2xzW29wdHMucHJvdG9jb2xdKGNsaWVudCwgb3B0cylcbiAgfVxuICB2YXIgY2xpZW50ID0gbmV3IE1xdHRDbGllbnQod3JhcHBlciwgb3B0cylcbiAgY2xpZW50Lm9uKCdlcnJvcicsIGZ1bmN0aW9uICgpIHsgLyogQXV0b21hdGljYWxseSBzZXQgdXAgY2xpZW50IGVycm9yIGhhbmRsaW5nICovIH0pXG4gIHJldHVybiBjbGllbnRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0XG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdFxubW9kdWxlLmV4cG9ydHMuTXF0dENsaWVudCA9IE1xdHRDbGllbnRcbm1vZHVsZS5leHBvcnRzLlN0b3JlID0gU3RvcmVcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIi4uL2NsaWVudFwiOjEsXCIuLi9zdG9yZVwiOjcsXCIuL2FsaVwiOjIsXCIuL3RjcFwiOjMsXCIuL3Rsc1wiOjQsXCIuL3dzXCI6NSxcIi4vd3hcIjo2LFwiX3Byb2Nlc3NcIjoxMDAsXCJkZWJ1Z1wiOjE3LFwidXJsXCI6MTMyLFwieHRlbmRcIjoxNDB9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxufSx7fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG59LHt9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKEJ1ZmZlcil7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpXG59LHtcImJhc2U2NC1qc1wiOjEwLFwiYnVmZmVyXCI6MTIsXCJpZWVlNzU0XCI6ODd9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKEJ1ZmZlcil7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cbn0pLmNhbGwodGhpcyx7XCJpc0J1ZmZlclwiOnJlcXVpcmUoXCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcIil9KVxufSx7XCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcIjo4OX1dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSAgICAgICAgICAgICA9IHJlcXVpcmUoXCJ0eXBlL3ZhbHVlL2lzXCIpXG4gICwgZW5zdXJlVmFsdWUgICAgICAgICA9IHJlcXVpcmUoXCJ0eXBlL3ZhbHVlL2Vuc3VyZVwiKVxuICAsIGVuc3VyZVBsYWluRnVuY3Rpb24gPSByZXF1aXJlKFwidHlwZS9wbGFpbi1mdW5jdGlvbi9lbnN1cmVcIilcbiAgLCBjb3B5ICAgICAgICAgICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L2NvcHlcIilcbiAgLCBub3JtYWxpemVPcHRpb25zICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L25vcm1hbGl6ZS1vcHRpb25zXCIpXG4gICwgbWFwICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9tYXBcIik7XG5cbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlZmluZTtcblxuZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlc2MsIG9wdGlvbnMpIHtcblx0dmFyIHZhbHVlID0gZW5zdXJlVmFsdWUoZGVzYykgJiYgZW5zdXJlUGxhaW5GdW5jdGlvbihkZXNjLnZhbHVlKSwgZGdzO1xuXHRkZ3MgPSBjb3B5KGRlc2MpO1xuXHRkZWxldGUgZGdzLndyaXRhYmxlO1xuXHRkZWxldGUgZGdzLnZhbHVlO1xuXHRkZ3MuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghb3B0aW9ucy5vdmVyd3JpdGVEZWZpbml0aW9uICYmIGhhc093blByb3BlcnR5LmNhbGwodGhpcywgbmFtZSkpIHJldHVybiB2YWx1ZTtcblx0XHRkZXNjLnZhbHVlID0gYmluZC5jYWxsKHZhbHVlLCBvcHRpb25zLnJlc29sdmVDb250ZXh0ID8gb3B0aW9ucy5yZXNvbHZlQ29udGV4dCh0aGlzKSA6IHRoaXMpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIGRlc2MpO1xuXHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHR9O1xuXHRyZXR1cm4gZGdzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcHMvKiwgb3B0aW9ucyovKSB7XG5cdHZhciBvcHRpb25zID0gbm9ybWFsaXplT3B0aW9ucyhhcmd1bWVudHNbMV0pO1xuXHRpZiAoaXNWYWx1ZShvcHRpb25zLnJlc29sdmVDb250ZXh0KSkgZW5zdXJlUGxhaW5GdW5jdGlvbihvcHRpb25zLnJlc29sdmVDb250ZXh0KTtcblx0cmV0dXJuIG1hcChwcm9wcywgZnVuY3Rpb24gKGRlc2MsIG5hbWUpIHsgcmV0dXJuIGRlZmluZShuYW1lLCBkZXNjLCBvcHRpb25zKTsgfSk7XG59O1xuXG59LHtcImVzNS1leHQvb2JqZWN0L2NvcHlcIjo0MSxcImVzNS1leHQvb2JqZWN0L21hcFwiOjQ5LFwiZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnNcIjo1MCxcInR5cGUvcGxhaW4tZnVuY3Rpb24vZW5zdXJlXCI6MTI2LFwidHlwZS92YWx1ZS9lbnN1cmVcIjoxMzAsXCJ0eXBlL3ZhbHVlL2lzXCI6MTMxfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc1ZhbHVlICAgICAgICAgPSByZXF1aXJlKFwidHlwZS92YWx1ZS9pc1wiKVxuICAsIGlzUGxhaW5GdW5jdGlvbiA9IHJlcXVpcmUoXCJ0eXBlL3BsYWluLWZ1bmN0aW9uL2lzXCIpXG4gICwgYXNzaWduICAgICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L2Fzc2lnblwiKVxuICAsIG5vcm1hbGl6ZU9wdHMgICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9ub3JtYWxpemUtb3B0aW9uc1wiKVxuICAsIGNvbnRhaW5zICAgICAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zXCIpO1xuXG52YXIgZCA9IChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkc2NyLCB2YWx1ZS8qLCBvcHRpb25zKi8pIHtcblx0dmFyIGMsIGUsIHcsIG9wdGlvbnMsIGRlc2M7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiB8fCB0eXBlb2YgZHNjciAhPT0gXCJzdHJpbmdcIikge1xuXHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHR2YWx1ZSA9IGRzY3I7XG5cdFx0ZHNjciA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcblx0fVxuXHRpZiAoaXNWYWx1ZShkc2NyKSkge1xuXHRcdGMgPSBjb250YWlucy5jYWxsKGRzY3IsIFwiY1wiKTtcblx0XHRlID0gY29udGFpbnMuY2FsbChkc2NyLCBcImVcIik7XG5cdFx0dyA9IGNvbnRhaW5zLmNhbGwoZHNjciwgXCJ3XCIpO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSB3ID0gdHJ1ZTtcblx0XHRlID0gZmFsc2U7XG5cdH1cblxuXHRkZXNjID0geyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogYywgZW51bWVyYWJsZTogZSwgd3JpdGFibGU6IHcgfTtcblx0cmV0dXJuICFvcHRpb25zID8gZGVzYyA6IGFzc2lnbihub3JtYWxpemVPcHRzKG9wdGlvbnMpLCBkZXNjKTtcbn0pO1xuXG5kLmdzID0gZnVuY3Rpb24gKGRzY3IsIGdldCwgc2V0LyosIG9wdGlvbnMqLykge1xuXHR2YXIgYywgZSwgb3B0aW9ucywgZGVzYztcblx0aWYgKHR5cGVvZiBkc2NyICE9PSBcInN0cmluZ1wiKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSBnZXQ7XG5cdFx0Z2V0ID0gZHNjcjtcblx0XHRkc2NyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zID0gYXJndW1lbnRzWzNdO1xuXHR9XG5cdGlmICghaXNWYWx1ZShnZXQpKSB7XG5cdFx0Z2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc1BsYWluRnVuY3Rpb24oZ2V0KSkge1xuXHRcdG9wdGlvbnMgPSBnZXQ7XG5cdFx0Z2V0ID0gc2V0ID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCFpc1ZhbHVlKHNldCkpIHtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIWlzUGxhaW5GdW5jdGlvbihzZXQpKSB7XG5cdFx0b3B0aW9ucyA9IHNldDtcblx0XHRzZXQgPSB1bmRlZmluZWQ7XG5cdH1cblx0aWYgKGlzVmFsdWUoZHNjcikpIHtcblx0XHRjID0gY29udGFpbnMuY2FsbChkc2NyLCBcImNcIik7XG5cdFx0ZSA9IGNvbnRhaW5zLmNhbGwoZHNjciwgXCJlXCIpO1xuXHR9IGVsc2Uge1xuXHRcdGMgPSB0cnVlO1xuXHRcdGUgPSBmYWxzZTtcblx0fVxuXG5cdGRlc2MgPSB7IGdldDogZ2V0LCBzZXQ6IHNldCwgY29uZmlndXJhYmxlOiBjLCBlbnVtZXJhYmxlOiBlIH07XG5cdHJldHVybiAhb3B0aW9ucyA/IGRlc2MgOiBhc3NpZ24obm9ybWFsaXplT3B0cyhvcHRpb25zKSwgZGVzYyk7XG59O1xuXG59LHtcImVzNS1leHQvb2JqZWN0L2Fzc2lnblwiOjM4LFwiZXM1LWV4dC9vYmplY3Qvbm9ybWFsaXplLW9wdGlvbnNcIjo1MCxcImVzNS1leHQvc3RyaW5nLyMvY29udGFpbnNcIjo1NyxcInR5cGUvcGxhaW4tZnVuY3Rpb24vaXNcIjoxMjcsXCJ0eXBlL3ZhbHVlL2lzXCI6MTMxfV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG5cbn0se31dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2coLi4uYXJncykge1xuXHQvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuXHQvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuXHRyZXR1cm4gdHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmXG5cdFx0Y29uc29sZS5sb2cgJiZcblx0XHRjb25zb2xlLmxvZyguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCIuL2NvbW1vblwiOjE4LFwiX3Byb2Nlc3NcIjoxMDB9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHQvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcblx0XHQvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG5cblx0XHQvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zdCBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuXHRcdFx0aW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxufSx7XCJtc1wiOjE2fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLEJ1ZmZlcil7XG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJylcbnZhciBlb3MgPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzaGlmdCA9IHJlcXVpcmUoJ3N0cmVhbS1zaGlmdCcpXG5cbnZhciBTSUdOQUxfRkxVU0ggPSAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSlcbiAgPyBCdWZmZXIuZnJvbShbMF0pXG4gIDogbmV3IEJ1ZmZlcihbMF0pXG5cbnZhciBvbnVuY29yayA9IGZ1bmN0aW9uKHNlbGYsIGZuKSB7XG4gIGlmIChzZWxmLl9jb3JrZWQpIHNlbGYub25jZSgndW5jb3JrJywgZm4pXG4gIGVsc2UgZm4oKVxufVxuXG52YXIgYXV0b0Rlc3Ryb3kgPSBmdW5jdGlvbiAoc2VsZiwgZXJyKSB7XG4gIGlmIChzZWxmLl9hdXRvRGVzdHJveSkgc2VsZi5kZXN0cm95KGVycilcbn1cblxudmFyIGRlc3Ryb3llciA9IGZ1bmN0aW9uKHNlbGYsIGVuZCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVycikgYXV0b0Rlc3Ryb3koc2VsZiwgZXJyLm1lc3NhZ2UgPT09ICdwcmVtYXR1cmUgY2xvc2UnID8gbnVsbCA6IGVycilcbiAgICBlbHNlIGlmIChlbmQgJiYgIXNlbGYuX2VuZGVkKSBzZWxmLmVuZCgpXG4gIH1cbn1cblxudmFyIGVuZCA9IGZ1bmN0aW9uKHdzLCBmbikge1xuICBpZiAoIXdzKSByZXR1cm4gZm4oKVxuICBpZiAod3MuX3dyaXRhYmxlU3RhdGUgJiYgd3MuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHJldHVybiBmbigpXG4gIGlmICh3cy5fd3JpdGFibGVTdGF0ZSkgcmV0dXJuIHdzLmVuZChmbilcbiAgd3MuZW5kKClcbiAgZm4oKVxufVxuXG52YXIgdG9TdHJlYW1zMiA9IGZ1bmN0aW9uKHJzKSB7XG4gIHJldHVybiBuZXcgKHN0cmVhbS5SZWFkYWJsZSkoe29iamVjdE1vZGU6dHJ1ZSwgaGlnaFdhdGVyTWFyazoxNn0pLndyYXAocnMpXG59XG5cbnZhciBEdXBsZXhpZnkgPSBmdW5jdGlvbih3cml0YWJsZSwgcmVhZGFibGUsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleGlmeSkpIHJldHVybiBuZXcgRHVwbGV4aWZ5KHdyaXRhYmxlLCByZWFkYWJsZSwgb3B0cylcbiAgc3RyZWFtLkR1cGxleC5jYWxsKHRoaXMsIG9wdHMpXG5cbiAgdGhpcy5fd3JpdGFibGUgPSBudWxsXG4gIHRoaXMuX3JlYWRhYmxlID0gbnVsbFxuICB0aGlzLl9yZWFkYWJsZTIgPSBudWxsXG5cbiAgdGhpcy5fYXV0b0Rlc3Ryb3kgPSAhb3B0cyB8fCBvcHRzLmF1dG9EZXN0cm95ICE9PSBmYWxzZVxuICB0aGlzLl9mb3J3YXJkRGVzdHJveSA9ICFvcHRzIHx8IG9wdHMuZGVzdHJveSAhPT0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZEVuZCA9ICFvcHRzIHx8IG9wdHMuZW5kICE9PSBmYWxzZVxuICB0aGlzLl9jb3JrZWQgPSAxIC8vIHN0YXJ0IGNvcmtlZFxuICB0aGlzLl9vbmRyYWluID0gbnVsbFxuICB0aGlzLl9kcmFpbmVkID0gZmFsc2VcbiAgdGhpcy5fZm9yd2FyZGluZyA9IGZhbHNlXG4gIHRoaXMuX3Vud3JpdGUgPSBudWxsXG4gIHRoaXMuX3VucmVhZCA9IG51bGxcbiAgdGhpcy5fZW5kZWQgPSBmYWxzZVxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2VcblxuICBpZiAod3JpdGFibGUpIHRoaXMuc2V0V3JpdGFibGUod3JpdGFibGUpXG4gIGlmIChyZWFkYWJsZSkgdGhpcy5zZXRSZWFkYWJsZShyZWFkYWJsZSlcbn1cblxuaW5oZXJpdHMoRHVwbGV4aWZ5LCBzdHJlYW0uRHVwbGV4KVxuXG5EdXBsZXhpZnkub2JqID0gZnVuY3Rpb24od3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG4gIG9wdHMub2JqZWN0TW9kZSA9IHRydWVcbiAgb3B0cy5oaWdoV2F0ZXJNYXJrID0gMTZcbiAgcmV0dXJuIG5ldyBEdXBsZXhpZnkod3JpdGFibGUsIHJlYWRhYmxlLCBvcHRzKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCsrdGhpcy5fY29ya2VkID09PSAxKSB0aGlzLmVtaXQoJ2NvcmsnKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fY29ya2VkICYmIC0tdGhpcy5fY29ya2VkID09PSAwKSB0aGlzLmVtaXQoJ3VuY29yaycpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuc2V0V3JpdGFibGUgPSBmdW5jdGlvbih3cml0YWJsZSkge1xuICBpZiAodGhpcy5fdW53cml0ZSkgdGhpcy5fdW53cml0ZSgpXG5cbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgaWYgKHdyaXRhYmxlICYmIHdyaXRhYmxlLmRlc3Ryb3kpIHdyaXRhYmxlLmRlc3Ryb3koKVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHdyaXRhYmxlID09PSBudWxsIHx8IHdyaXRhYmxlID09PSBmYWxzZSkge1xuICAgIHRoaXMuZW5kKClcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgdW5lbmQgPSBlb3Mod3JpdGFibGUsIHt3cml0YWJsZTp0cnVlLCByZWFkYWJsZTpmYWxzZX0sIGRlc3Ryb3llcih0aGlzLCB0aGlzLl9mb3J3YXJkRW5kKSlcblxuICB2YXIgb25kcmFpbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbmRyYWluID0gc2VsZi5fb25kcmFpblxuICAgIHNlbGYuX29uZHJhaW4gPSBudWxsXG4gICAgaWYgKG9uZHJhaW4pIG9uZHJhaW4oKVxuICB9XG5cbiAgdmFyIGNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fd3JpdGFibGUucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbilcbiAgICB1bmVuZCgpXG4gIH1cblxuICBpZiAodGhpcy5fdW53cml0ZSkgcHJvY2Vzcy5uZXh0VGljayhvbmRyYWluKSAvLyBmb3JjZSBhIGRyYWluIG9uIHN0cmVhbSByZXNldCB0byBhdm9pZCBsaXZlbG9ja3NcblxuICB0aGlzLl93cml0YWJsZSA9IHdyaXRhYmxlXG4gIHRoaXMuX3dyaXRhYmxlLm9uKCdkcmFpbicsIG9uZHJhaW4pXG4gIHRoaXMuX3Vud3JpdGUgPSBjbGVhclxuXG4gIHRoaXMudW5jb3JrKCkgLy8gYWx3YXlzIHVuY29yayBzZXRXcml0YWJsZVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLnNldFJlYWRhYmxlID0gZnVuY3Rpb24ocmVhZGFibGUpIHtcbiAgaWYgKHRoaXMuX3VucmVhZCkgdGhpcy5fdW5yZWFkKClcblxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICBpZiAocmVhZGFibGUgJiYgcmVhZGFibGUuZGVzdHJveSkgcmVhZGFibGUuZGVzdHJveSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocmVhZGFibGUgPT09IG51bGwgfHwgcmVhZGFibGUgPT09IGZhbHNlKSB7XG4gICAgdGhpcy5wdXNoKG51bGwpXG4gICAgdGhpcy5yZXN1bWUoKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciB1bmVuZCA9IGVvcyhyZWFkYWJsZSwge3dyaXRhYmxlOmZhbHNlLCByZWFkYWJsZTp0cnVlfSwgZGVzdHJveWVyKHRoaXMpKVxuXG4gIHZhciBvbnJlYWRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZm9yd2FyZCgpXG4gIH1cblxuICB2YXIgb25lbmQgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLnB1c2gobnVsbClcbiAgfVxuXG4gIHZhciBjbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3JlYWRhYmxlMi5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBvbnJlYWRhYmxlKVxuICAgIHNlbGYuX3JlYWRhYmxlMi5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpXG4gICAgdW5lbmQoKVxuICB9XG5cbiAgdGhpcy5fZHJhaW5lZCA9IHRydWVcbiAgdGhpcy5fcmVhZGFibGUgPSByZWFkYWJsZVxuICB0aGlzLl9yZWFkYWJsZTIgPSByZWFkYWJsZS5fcmVhZGFibGVTdGF0ZSA/IHJlYWRhYmxlIDogdG9TdHJlYW1zMihyZWFkYWJsZSlcbiAgdGhpcy5fcmVhZGFibGUyLm9uKCdyZWFkYWJsZScsIG9ucmVhZGFibGUpXG4gIHRoaXMuX3JlYWRhYmxlMi5vbignZW5kJywgb25lbmQpXG4gIHRoaXMuX3VucmVhZCA9IGNsZWFyXG5cbiAgdGhpcy5fZm9yd2FyZCgpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZHJhaW5lZCA9IHRydWVcbiAgdGhpcy5fZm9yd2FyZCgpXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2ZvcndhcmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2ZvcndhcmRpbmcgfHwgIXRoaXMuX3JlYWRhYmxlMiB8fCAhdGhpcy5fZHJhaW5lZCkgcmV0dXJuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSB0cnVlXG5cbiAgdmFyIGRhdGFcblxuICB3aGlsZSAodGhpcy5fZHJhaW5lZCAmJiAoZGF0YSA9IHNoaWZ0KHRoaXMuX3JlYWRhYmxlMikpICE9PSBudWxsKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSBjb250aW51ZVxuICAgIHRoaXMuX2RyYWluZWQgPSB0aGlzLnB1c2goZGF0YSlcbiAgfVxuXG4gIHRoaXMuX2ZvcndhcmRpbmcgPSBmYWxzZVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlXG5cbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fZGVzdHJveShlcnIpXG4gIH0pXG59XG5cbkR1cGxleGlmeS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKGVycikge1xuICAgIHZhciBvbmRyYWluID0gdGhpcy5fb25kcmFpblxuICAgIHRoaXMuX29uZHJhaW4gPSBudWxsXG4gICAgaWYgKG9uZHJhaW4pIG9uZHJhaW4oZXJyKVxuICAgIGVsc2UgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG4gIGlmICh0aGlzLl9mb3J3YXJkRGVzdHJveSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZSAmJiB0aGlzLl9yZWFkYWJsZS5kZXN0cm95KSB0aGlzLl9yZWFkYWJsZS5kZXN0cm95KClcbiAgICBpZiAodGhpcy5fd3JpdGFibGUgJiYgdGhpcy5fd3JpdGFibGUuZGVzdHJveSkgdGhpcy5fd3JpdGFibGUuZGVzdHJveSgpXG4gIH1cblxuICB0aGlzLmVtaXQoJ2Nsb3NlJylcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihkYXRhLCBlbmMsIGNiKSB7XG4gIGlmICh0aGlzLmRlc3Ryb3llZCkgcmV0dXJuIGNiKClcbiAgaWYgKHRoaXMuX2NvcmtlZCkgcmV0dXJuIG9udW5jb3JrKHRoaXMsIHRoaXMuX3dyaXRlLmJpbmQodGhpcywgZGF0YSwgZW5jLCBjYikpXG4gIGlmIChkYXRhID09PSBTSUdOQUxfRkxVU0gpIHJldHVybiB0aGlzLl9maW5pc2goY2IpXG4gIGlmICghdGhpcy5fd3JpdGFibGUpIHJldHVybiBjYigpXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlLndyaXRlKGRhdGEpID09PSBmYWxzZSkgdGhpcy5fb25kcmFpbiA9IGNiXG4gIGVsc2UgY2IoKVxufVxuXG5EdXBsZXhpZnkucHJvdG90eXBlLl9maW5pc2ggPSBmdW5jdGlvbihjYikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5lbWl0KCdwcmVlbmQnKVxuICBvbnVuY29yayh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBlbmQoc2VsZi5fZm9yd2FyZEVuZCAmJiBzZWxmLl93cml0YWJsZSwgZnVuY3Rpb24oKSB7XG4gICAgICAvLyBoYXh4IHRvIG5vdCBlbWl0IHByZWZpbmlzaCB0d2ljZVxuICAgICAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPT09IGZhbHNlKSBzZWxmLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZVxuICAgICAgc2VsZi5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgb251bmNvcmsoc2VsZiwgY2IpXG4gICAgfSlcbiAgfSlcbn1cblxuRHVwbGV4aWZ5LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihkYXRhLCBlbmMsIGNiKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXMuZW5kKG51bGwsIG51bGwsIGRhdGEpXG4gIGlmICh0eXBlb2YgZW5jID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5lbmQoZGF0YSwgbnVsbCwgZW5jKVxuICB0aGlzLl9lbmRlZCA9IHRydWVcbiAgaWYgKGRhdGEpIHRoaXMud3JpdGUoZGF0YSlcbiAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZykgdGhpcy53cml0ZShTSUdOQUxfRkxVU0gpXG4gIHJldHVybiBzdHJlYW0uV3JpdGFibGUucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNiKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleGlmeVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbn0se1wiX3Byb2Nlc3NcIjoxMDAsXCJidWZmZXJcIjoxMixcImVuZC1vZi1zdHJlYW1cIjoyMCxcImluaGVyaXRzXCI6ODgsXCJyZWFkYWJsZS1zdHJlYW1cIjoxMTYsXCJzdHJlYW0tc2hpZnRcIjoxMTl9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgb25jZSA9IHJlcXVpcmUoJ29uY2UnKTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG52YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24oc3RyZWFtKSB7XG5cdHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgaXNDaGlsZFByb2Nlc3MgPSBmdW5jdGlvbihzdHJlYW0pIHtcblx0cmV0dXJuIHN0cmVhbS5zdGRpbyAmJiBBcnJheS5pc0FycmF5KHN0cmVhbS5zdGRpbykgJiYgc3RyZWFtLnN0ZGlvLmxlbmd0aCA9PT0gM1xufTtcblxudmFyIGVvcyA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG5cdGlmICghb3B0cykgb3B0cyA9IHt9O1xuXG5cdGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTtcblxuXHR2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cdHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblx0dmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCAob3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlKTtcblx0dmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCAob3B0cy53cml0YWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLndyaXRhYmxlKTtcblxuXHR2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcblx0fTtcblxuXHR2YXIgb25maW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHR3cml0YWJsZSA9IGZhbHNlO1xuXHRcdGlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcblx0fTtcblxuXHR2YXIgb25lbmQgPSBmdW5jdGlvbigpIHtcblx0XHRyZWFkYWJsZSA9IGZhbHNlO1xuXHRcdGlmICghd3JpdGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTtcblx0fTtcblxuXHR2YXIgb25leGl0ID0gZnVuY3Rpb24oZXhpdENvZGUpIHtcblx0XHRjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXhpdENvZGUgPyBuZXcgRXJyb3IoJ2V4aXRlZCB3aXRoIGVycm9yIGNvZGU6ICcgKyBleGl0Q29kZSkgOiBudWxsKTtcblx0fTtcblxuXHR2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHRcdGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuXHR9O1xuXG5cdHZhciBvbmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHJlYWRhYmxlICYmICEocnMgJiYgcnMuZW5kZWQpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpO1xuXHRcdGlmICh3cml0YWJsZSAmJiAhKHdzICYmIHdzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTtcblx0fTtcblxuXHR2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0c3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuXHR9O1xuXG5cdGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkge1xuXHRcdHN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpO1xuXHRcdGlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTtcblx0XHRlbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG5cdH0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXdzKSB7IC8vIGxlZ2FjeSBzdHJlYW1zXG5cdFx0c3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTtcblx0fVxuXG5cdGlmIChpc0NoaWxkUHJvY2VzcyhzdHJlYW0pKSBzdHJlYW0ub24oJ2V4aXQnLCBvbmV4aXQpO1xuXG5cdHN0cmVhbS5vbignZW5kJywgb25lbmQpO1xuXHRzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblx0aWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7XG5cdHN0cmVhbS5vbignY2xvc2UnLCBvbmNsb3NlKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcblx0XHRpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuXHRcdHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25leGl0KTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcblx0XHRzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cdFx0c3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXHR9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7XG5cbn0se1wib25jZVwiOjk4fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gSW5zcGlyZWQgYnkgR29vZ2xlIENsb3N1cmU6XG4vLyBodHRwOi8vY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL3N2bi9kb2NzL1xuLy8gY2xvc3VyZV9nb29nX2FycmF5X2FycmF5LmpzLmh0bWwjZ29vZy5hcnJheS5jbGVhclxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHZhbHVlID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC12YWx1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhbHVlKHRoaXMpLmxlbmd0aCA9IDA7XG5cdHJldHVybiB0aGlzO1xufTtcblxufSx7XCIuLi8uLi9vYmplY3QvdmFsaWQtdmFsdWVcIjo1Nn1dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgbnVtYmVySXNOYU4gICAgICAgPSByZXF1aXJlKFwiLi4vLi4vbnVtYmVyL2lzLW5hblwiKVxuICAsIHRvUG9zSW50ICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL251bWJlci90by1wb3MtaW50ZWdlclwiKVxuICAsIHZhbHVlICAgICAgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL29iamVjdC92YWxpZC12YWx1ZVwiKVxuICAsIGluZGV4T2YgICAgICAgICAgID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2ZcbiAgLCBvYmpIYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBhYnMgICAgICAgICAgICAgICA9IE1hdGguYWJzXG4gICwgZmxvb3IgICAgICAgICAgICAgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWFyY2hFbGVtZW50LyosIGZyb21JbmRleCovKSB7XG5cdHZhciBpLCBsZW5ndGgsIGZyb21JbmRleCwgdmFsO1xuXHRpZiAoIW51bWJlcklzTmFOKHNlYXJjaEVsZW1lbnQpKSByZXR1cm4gaW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdGxlbmd0aCA9IHRvUG9zSW50KHZhbHVlKHRoaXMpLmxlbmd0aCk7XG5cdGZyb21JbmRleCA9IGFyZ3VtZW50c1sxXTtcblx0aWYgKGlzTmFOKGZyb21JbmRleCkpIGZyb21JbmRleCA9IDA7XG5cdGVsc2UgaWYgKGZyb21JbmRleCA+PSAwKSBmcm9tSW5kZXggPSBmbG9vcihmcm9tSW5kZXgpO1xuXHRlbHNlIGZyb21JbmRleCA9IHRvUG9zSW50KHRoaXMubGVuZ3RoKSAtIGZsb29yKGFicyhmcm9tSW5kZXgpKTtcblxuXHRmb3IgKGkgPSBmcm9tSW5kZXg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdGlmIChvYmpIYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGkpKSB7XG5cdFx0XHR2YWwgPSB0aGlzW2ldO1xuXHRcdFx0aWYgKG51bWJlcklzTmFOKHZhbCkpIHJldHVybiBpOyAvLyBKc2xpbnQ6IGlnbm9yZVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG59LHtcIi4uLy4uL251bWJlci9pcy1uYW5cIjozMixcIi4uLy4uL251bWJlci90by1wb3MtaW50ZWdlclwiOjM2LFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCI6NTZ9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gQXJyYXkuZnJvbSA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG5cbn0se1wiLi9pcy1pbXBsZW1lbnRlZFwiOjI0LFwiLi9zaGltXCI6MjV9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBmcm9tID0gQXJyYXkuZnJvbSwgYXJyLCByZXN1bHQ7XG5cdGlmICh0eXBlb2YgZnJvbSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdGFyciA9IFtcInJhelwiLCBcImR3YVwiXTtcblx0cmVzdWx0ID0gZnJvbShhcnIpO1xuXHRyZXR1cm4gQm9vbGVhbihyZXN1bHQgJiYgcmVzdWx0ICE9PSBhcnIgJiYgcmVzdWx0WzFdID09PSBcImR3YVwiKTtcbn07XG5cbn0se31dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXRlcmF0b3JTeW1ib2wgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKS5pdGVyYXRvclxuICAsIGlzQXJndW1lbnRzICAgID0gcmVxdWlyZShcIi4uLy4uL2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGlzRnVuY3Rpb24gICAgID0gcmVxdWlyZShcIi4uLy4uL2Z1bmN0aW9uL2lzLWZ1bmN0aW9uXCIpXG4gICwgdG9Qb3NJbnQgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyXCIpXG4gICwgY2FsbGFibGUgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgdmFsaWRWYWx1ZSAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCIpXG4gICwgaXNWYWx1ZSAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vb2JqZWN0L2lzLXZhbHVlXCIpXG4gICwgaXNTdHJpbmcgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vc3RyaW5nL2lzLXN0cmluZ1wiKVxuICAsIGlzQXJyYXkgICAgICAgID0gQXJyYXkuaXNBcnJheVxuICAsIGNhbGwgICAgICAgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBkZXNjICAgICAgICAgICA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG51bGwgfVxuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSwgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXlMaWtlLyosIG1hcEZuLCB0aGlzQXJnKi8pIHtcblx0dmFyIG1hcEZuID0gYXJndW1lbnRzWzFdXG5cdCAgLCB0aGlzQXJnID0gYXJndW1lbnRzWzJdXG5cdCAgLCBDb250ZXh0XG5cdCAgLCBpXG5cdCAgLCBqXG5cdCAgLCBhcnJcblx0ICAsIGxlbmd0aFxuXHQgICwgY29kZVxuXHQgICwgaXRlcmF0b3Jcblx0ICAsIHJlc3VsdFxuXHQgICwgZ2V0SXRlcmF0b3Jcblx0ICAsIHZhbHVlO1xuXG5cdGFycmF5TGlrZSA9IE9iamVjdCh2YWxpZFZhbHVlKGFycmF5TGlrZSkpO1xuXG5cdGlmIChpc1ZhbHVlKG1hcEZuKSkgY2FsbGFibGUobWFwRm4pO1xuXHRpZiAoIXRoaXMgfHwgdGhpcyA9PT0gQXJyYXkgfHwgIWlzRnVuY3Rpb24odGhpcykpIHtcblx0XHQvLyBSZXN1bHQ6IFBsYWluIGFycmF5XG5cdFx0aWYgKCFtYXBGbikge1xuXHRcdFx0aWYgKGlzQXJndW1lbnRzKGFycmF5TGlrZSkpIHtcblx0XHRcdFx0Ly8gU291cmNlOiBBcmd1bWVudHNcblx0XHRcdFx0bGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHRcdFx0aWYgKGxlbmd0aCAhPT0gMSkgcmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIGFycmF5TGlrZSk7XG5cdFx0XHRcdGFyciA9IG5ldyBBcnJheSgxKTtcblx0XHRcdFx0YXJyWzBdID0gYXJyYXlMaWtlWzBdO1xuXHRcdFx0XHRyZXR1cm4gYXJyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzQXJyYXkoYXJyYXlMaWtlKSkge1xuXHRcdFx0XHQvLyBTb3VyY2U6IEFycmF5XG5cdFx0XHRcdGFyciA9IG5ldyBBcnJheSgobGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aCkpO1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIGFycltpXSA9IGFycmF5TGlrZVtpXTtcblx0XHRcdFx0cmV0dXJuIGFycjtcblx0XHRcdH1cblx0XHR9XG5cdFx0YXJyID0gW107XG5cdH0gZWxzZSB7XG5cdFx0Ly8gUmVzdWx0OiBOb24gcGxhaW4gYXJyYXlcblx0XHRDb250ZXh0ID0gdGhpcztcblx0fVxuXG5cdGlmICghaXNBcnJheShhcnJheUxpa2UpKSB7XG5cdFx0aWYgKChnZXRJdGVyYXRvciA9IGFycmF5TGlrZVtpdGVyYXRvclN5bWJvbF0pICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIFNvdXJjZTogSXRlcmF0b3Jcblx0XHRcdGl0ZXJhdG9yID0gY2FsbGFibGUoZ2V0SXRlcmF0b3IpLmNhbGwoYXJyYXlMaWtlKTtcblx0XHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dCgpO1xuXHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0aSA9IDA7XG5cdFx0XHR3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdHZhbHVlID0gbWFwRm4gPyBjYWxsLmNhbGwobWFwRm4sIHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgaSkgOiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdFx0ZGVzYy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KGFyciwgaSwgZGVzYyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXJyW2ldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0XHRsZW5ndGggPSBpO1xuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoYXJyYXlMaWtlKSkge1xuXHRcdFx0Ly8gU291cmNlOiBTdHJpbmdcblx0XHRcdGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XG5cdFx0XHRpZiAoQ29udGV4dCkgYXJyID0gbmV3IENvbnRleHQoKTtcblx0XHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dmFsdWUgPSBhcnJheUxpa2VbaV07XG5cdFx0XHRcdGlmIChpICsgMSA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcblx0XHRcdFx0XHRpZiAoY29kZSA+PSAweGQ4MDAgJiYgY29kZSA8PSAweGRiZmYpIHZhbHVlICs9IGFycmF5TGlrZVsrK2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gbWFwRm4gPyBjYWxsLmNhbGwobWFwRm4sIHRoaXNBcmcsIHZhbHVlLCBqKSA6IHZhbHVlO1xuXHRcdFx0XHRpZiAoQ29udGV4dCkge1xuXHRcdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eShhcnIsIGosIGRlc2MpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFycltqXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCsrajtcblx0XHRcdH1cblx0XHRcdGxlbmd0aCA9IGo7XG5cdFx0fVxuXHR9XG5cdGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIFNvdXJjZTogYXJyYXkgb3IgYXJyYXktbGlrZVxuXHRcdGxlbmd0aCA9IHRvUG9zSW50KGFycmF5TGlrZS5sZW5ndGgpO1xuXHRcdGlmIChDb250ZXh0KSBhcnIgPSBuZXcgQ29udGV4dChsZW5ndGgpO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0dmFsdWUgPSBtYXBGbiA/IGNhbGwuY2FsbChtYXBGbiwgdGhpc0FyZywgYXJyYXlMaWtlW2ldLCBpKSA6IGFycmF5TGlrZVtpXTtcblx0XHRcdGlmIChDb250ZXh0KSB7XG5cdFx0XHRcdGRlc2MudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoYXJyLCBpLCBkZXNjKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFycltpXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAoQ29udGV4dCkge1xuXHRcdGRlc2MudmFsdWUgPSBudWxsO1xuXHRcdGFyci5sZW5ndGggPSBsZW5ndGg7XG5cdH1cblx0cmV0dXJuIGFycjtcbn07XG5cbn0se1wiLi4vLi4vZnVuY3Rpb24vaXMtYXJndW1lbnRzXCI6MjYsXCIuLi8uLi9mdW5jdGlvbi9pcy1mdW5jdGlvblwiOjI3LFwiLi4vLi4vbnVtYmVyL3RvLXBvcy1pbnRlZ2VyXCI6MzYsXCIuLi8uLi9vYmplY3QvaXMtdmFsdWVcIjo0NSxcIi4uLy4uL29iamVjdC92YWxpZC1jYWxsYWJsZVwiOjU1LFwiLi4vLi4vb2JqZWN0L3ZhbGlkLXZhbHVlXCI6NTYsXCIuLi8uLi9zdHJpbmcvaXMtc3RyaW5nXCI6NjAsXCJlczYtc3ltYm9sXCI6NzR9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAsIGlkID0gb2JqVG9TdHJpbmcuY2FsbCgoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBpZDsgfTtcblxufSx7fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgLCBpc0Z1bmN0aW9uU3RyaW5nVGFnID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL15bb2JqZWN0IFtBLVphLXowLTldKkZ1bmN0aW9uXSQvKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIGlzRnVuY3Rpb25TdHJpbmdUYWcob2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xufTtcblxufSx7fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eS1mdW5jdGlvblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7fTtcblxufSx7fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IE1hdGguc2lnbiA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG5cbn0se1wiLi9pcy1pbXBsZW1lbnRlZFwiOjMwLFwiLi9zaGltXCI6MzF9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzaWduID0gTWF0aC5zaWduO1xuXHRpZiAodHlwZW9mIHNpZ24gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gc2lnbigxMCkgPT09IDEgJiYgc2lnbigtMjApID09PSAtMTtcbn07XG5cbn0se31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHR2YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cdGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IDApIHJldHVybiB2YWx1ZTtcblx0cmV0dXJuIHZhbHVlID4gMCA/IDEgOiAtMTtcbn07XG5cbn0se31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBOdW1iZXIuaXNOYU4gOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjozMyxcIi4vc2hpbVwiOjM0fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgbnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU47XG5cdGlmICh0eXBlb2YgbnVtYmVySXNOYU4gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gIW51bWJlcklzTmFOKHt9KSAmJiBudW1iZXJJc05hTihOYU4pICYmICFudW1iZXJJc05hTigzNCk7XG59O1xuXG59LHt9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxufSx7fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzaWduICA9IHJlcXVpcmUoXCIuLi9tYXRoL3NpZ25cIilcbiAgLCBhYnMgICA9IE1hdGguYWJzXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gMDtcblx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHRpZiAodmFsdWUgPT09IDAgfHwgIWlzRmluaXRlKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuXHRyZXR1cm4gc2lnbih2YWx1ZSkgKiBmbG9vcihhYnModmFsdWUpKTtcbn07XG5cbn0se1wiLi4vbWF0aC9zaWduXCI6Mjl9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoXCIuL3RvLWludGVnZXJcIilcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIG1heCgwLCB0b0ludGVnZXIodmFsdWUpKTsgfTtcblxufSx7XCIuL3RvLWludGVnZXJcIjozNX1dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIEludGVybmFsIG1ldGhvZCwgdXNlZCBieSBpdGVyYXRpb24gZnVuY3Rpb25zLlxuLy8gQ2FsbHMgYSBmdW5jdGlvbiBmb3IgZWFjaCBrZXktdmFsdWUgcGFpciBmb3VuZCBpbiBvYmplY3Rcbi8vIE9wdGlvbmFsbHkgdGFrZXMgY29tcGFyZUZuIHRvIGl0ZXJhdGUgb2JqZWN0IGluIHNwZWNpZmljIG9yZGVyXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FsbGFibGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi92YWxpZC1jYWxsYWJsZVwiKVxuICAsIHZhbHVlICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWQtdmFsdWVcIilcbiAgLCBiaW5kICAgICAgICAgICAgICAgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gICwgY2FsbCAgICAgICAgICAgICAgICAgICAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbFxuICAsIGtleXMgICAgICAgICAgICAgICAgICAgID0gT2JqZWN0LmtleXNcbiAgLCBvYmpQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCwgZGVmVmFsKSB7XG5cdHJldHVybiBmdW5jdGlvbiAob2JqLCBjYi8qLCB0aGlzQXJnLCBjb21wYXJlRm4qLykge1xuXHRcdHZhciBsaXN0LCB0aGlzQXJnID0gYXJndW1lbnRzWzJdLCBjb21wYXJlRm4gPSBhcmd1bWVudHNbM107XG5cdFx0b2JqID0gT2JqZWN0KHZhbHVlKG9iaikpO1xuXHRcdGNhbGxhYmxlKGNiKTtcblxuXHRcdGxpc3QgPSBrZXlzKG9iaik7XG5cdFx0aWYgKGNvbXBhcmVGbikge1xuXHRcdFx0bGlzdC5zb3J0KHR5cGVvZiBjb21wYXJlRm4gPT09IFwiZnVuY3Rpb25cIiA/IGJpbmQuY2FsbChjb21wYXJlRm4sIG9iaikgOiB1bmRlZmluZWQpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIG1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSBtZXRob2QgPSBsaXN0W21ldGhvZF07XG5cdFx0cmV0dXJuIGNhbGwuY2FsbChtZXRob2QsIGxpc3QsIGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG5cdFx0XHRpZiAoIW9ialByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBrZXkpKSByZXR1cm4gZGVmVmFsO1xuXHRcdFx0cmV0dXJuIGNhbGwuY2FsbChjYiwgdGhpc0FyZywgb2JqW2tleV0sIGtleSwgb2JqLCBpbmRleCk7XG5cdFx0fSk7XG5cdH07XG59O1xuXG59LHtcIi4vdmFsaWQtY2FsbGFibGVcIjo1NSxcIi4vdmFsaWQtdmFsdWVcIjo1Nn1dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBPYmplY3QuYXNzaWduIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6MzksXCIuL3NoaW1cIjo0MH1dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sIG9iajtcblx0aWYgKHR5cGVvZiBhc3NpZ24gIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuXHRvYmogPSB7IGZvbzogXCJyYXpcIiB9O1xuXHRhc3NpZ24ob2JqLCB7IGJhcjogXCJkd2FcIiB9LCB7IHRyenk6IFwidHJ6eVwiIH0pO1xuXHRyZXR1cm4gb2JqLmZvbyArIG9iai5iYXIgKyBvYmoudHJ6eSA9PT0gXCJyYXpkd2F0cnp5XCI7XG59O1xuXG59LHt9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleXMgID0gcmVxdWlyZShcIi4uL2tleXNcIilcbiAgLCB2YWx1ZSA9IHJlcXVpcmUoXCIuLi92YWxpZC12YWx1ZVwiKVxuICAsIG1heCAgID0gTWF0aC5tYXg7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc3QsIHNyYy8qLCDigKZzcmNuKi8pIHtcblx0dmFyIGVycm9yLCBpLCBsZW5ndGggPSBtYXgoYXJndW1lbnRzLmxlbmd0aCwgMiksIGFzc2lnbjtcblx0ZGVzdCA9IE9iamVjdCh2YWx1ZShkZXN0KSk7XG5cdGFzc2lnbiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0XHR0cnkge1xuXHRcdFx0ZGVzdFtrZXldID0gc3JjW2tleV07XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlO1xuXHRcdH1cblx0fTtcblx0Zm9yIChpID0gMTsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0c3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdGtleXMoc3JjKS5mb3JFYWNoKGFzc2lnbik7XG5cdH1cblx0aWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHRocm93IGVycm9yO1xuXHRyZXR1cm4gZGVzdDtcbn07XG5cbn0se1wiLi4va2V5c1wiOjQ2LFwiLi4vdmFsaWQtdmFsdWVcIjo1Nn1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgYUZyb20gID0gcmVxdWlyZShcIi4uL2FycmF5L2Zyb21cIilcbiAgLCBhc3NpZ24gPSByZXF1aXJlKFwiLi9hc3NpZ25cIilcbiAgLCB2YWx1ZSAgPSByZXF1aXJlKFwiLi92YWxpZC12YWx1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLyosIHByb3BlcnR5TmFtZXMsIG9wdGlvbnMqLykge1xuXHR2YXIgY29weSA9IE9iamVjdCh2YWx1ZShvYmopKSwgcHJvcGVydHlOYW1lcyA9IGFyZ3VtZW50c1sxXSwgb3B0aW9ucyA9IE9iamVjdChhcmd1bWVudHNbMl0pO1xuXHRpZiAoY29weSAhPT0gb2JqICYmICFwcm9wZXJ0eU5hbWVzKSByZXR1cm4gY29weTtcblx0dmFyIHJlc3VsdCA9IHt9O1xuXHRpZiAocHJvcGVydHlOYW1lcykge1xuXHRcdGFGcm9tKHByb3BlcnR5TmFtZXMsIGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcblx0XHRcdGlmIChvcHRpb25zLmVuc3VyZSB8fCBwcm9wZXJ0eU5hbWUgaW4gb2JqKSByZXN1bHRbcHJvcGVydHlOYW1lXSA9IG9ialtwcm9wZXJ0eU5hbWVdO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGFzc2lnbihyZXN1bHQsIG9iaik7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbn0se1wiLi4vYXJyYXkvZnJvbVwiOjIzLFwiLi9hc3NpZ25cIjozOCxcIi4vdmFsaWQtdmFsdWVcIjo1Nn1dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIFdvcmthcm91bmQgZm9yIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTI4MDRcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBzaGltO1xuXG5pZiAoIXJlcXVpcmUoXCIuL3NldC1wcm90b3R5cGUtb2YvaXMtaW1wbGVtZW50ZWRcIikoKSkge1xuXHRzaGltID0gcmVxdWlyZShcIi4vc2V0LXByb3RvdHlwZS1vZi9zaGltXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBudWxsT2JqZWN0LCBwb2x5UHJvcHMsIGRlc2M7XG5cdGlmICghc2hpbSkgcmV0dXJuIGNyZWF0ZTtcblx0aWYgKHNoaW0ubGV2ZWwgIT09IDEpIHJldHVybiBjcmVhdGU7XG5cblx0bnVsbE9iamVjdCA9IHt9O1xuXHRwb2x5UHJvcHMgPSB7fTtcblx0ZGVzYyA9IHsgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG5cdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIikge1xuXHRcdFx0cG9seVByb3BzW25hbWVdID0ge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZFxuXHRcdFx0fTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cG9seVByb3BzW25hbWVdID0gZGVzYztcblx0fSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG51bGxPYmplY3QsIHBvbHlQcm9wcyk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHNoaW0sIFwibnVsbFBvbHlmaWxsXCIsIHtcblx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHR2YWx1ZTogbnVsbE9iamVjdFxuXHR9KTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHByb3RvdHlwZSwgcHJvcHMpIHtcblx0XHRyZXR1cm4gY3JlYXRlKHByb3RvdHlwZSA9PT0gbnVsbCA/IG51bGxPYmplY3QgOiBwcm90b3R5cGUsIHByb3BzKTtcblx0fTtcbn0pKCk7XG5cbn0se1wiLi9zZXQtcHJvdG90eXBlLW9mL2lzLWltcGxlbWVudGVkXCI6NTMsXCIuL3NldC1wcm90b3R5cGUtb2Yvc2hpbVwiOjU0fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vX2l0ZXJhdGVcIikoXCJmb3JFYWNoXCIpO1xuXG59LHtcIi4vX2l0ZXJhdGVcIjozN31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuL2lzLXZhbHVlXCIpO1xuXG52YXIgbWFwID0geyBmdW5jdGlvbjogdHJ1ZSwgb2JqZWN0OiB0cnVlIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAoaXNWYWx1ZSh2YWx1ZSkgJiYgbWFwW3R5cGVvZiB2YWx1ZV0pIHx8IGZhbHNlOyB9O1xuXG59LHtcIi4vaXMtdmFsdWVcIjo0NX1dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgX3VuZGVmaW5lZCA9IHJlcXVpcmUoXCIuLi9mdW5jdGlvbi9ub29wXCIpKCk7IC8vIFN1cHBvcnQgRVMzIGVuZ2luZXNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgIT09IF91bmRlZmluZWQgJiYgdmFsICE9PSBudWxsOyB9O1xuXG59LHtcIi4uL2Z1bmN0aW9uL25vb3BcIjoyOH1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBPYmplY3Qua2V5cyA6IHJlcXVpcmUoXCIuL3NoaW1cIik7XG5cbn0se1wiLi9pcy1pbXBsZW1lbnRlZFwiOjQ3LFwiLi9zaGltXCI6NDh9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmtleXMoXCJwcmltaXRpdmVcIik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbn0se31dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuLi9pcy12YWx1ZVwiKTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBrZXlzKGlzVmFsdWUob2JqZWN0KSA/IE9iamVjdChvYmplY3QpIDogb2JqZWN0KTsgfTtcblxufSx7XCIuLi9pcy12YWx1ZVwiOjQ1fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjYWxsYWJsZSA9IHJlcXVpcmUoXCIuL3ZhbGlkLWNhbGxhYmxlXCIpXG4gICwgZm9yRWFjaCAgPSByZXF1aXJlKFwiLi9mb3ItZWFjaFwiKVxuICAsIGNhbGwgICAgID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgY2IvKiwgdGhpc0FyZyovKSB7XG5cdHZhciByZXN1bHQgPSB7fSwgdGhpc0FyZyA9IGFyZ3VtZW50c1syXTtcblx0Y2FsbGFibGUoY2IpO1xuXHRmb3JFYWNoKG9iaiwgZnVuY3Rpb24gKHZhbHVlLCBrZXksIHRhcmdldE9iaiwgaW5kZXgpIHtcblx0XHRyZXN1bHRba2V5XSA9IGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdmFsdWUsIGtleSwgdGFyZ2V0T2JqLCBpbmRleCk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxufSx7XCIuL2Zvci1lYWNoXCI6NDMsXCIuL3ZhbGlkLWNhbGxhYmxlXCI6NTV9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi9pcy12YWx1ZVwiKTtcblxudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxudmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoc3JjLCBvYmopIHtcblx0dmFyIGtleTtcblx0Zm9yIChrZXkgaW4gc3JjKSBvYmpba2V5XSA9IHNyY1trZXldO1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzMS8qLCDigKZvcHRpb25zKi8pIHtcblx0dmFyIHJlc3VsdCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRpZiAoIWlzVmFsdWUob3B0aW9ucykpIHJldHVybjtcblx0XHRwcm9jZXNzKE9iamVjdChvcHRpb25zKSwgcmVzdWx0KTtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG59LHtcIi4vaXMtdmFsdWVcIjo0NX1dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZy8qLCDigKZhcmdzKi8pIHtcblx0dmFyIHNldCA9IGNyZWF0ZShudWxsKTtcblx0Zm9yRWFjaC5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24gKG5hbWUpIHsgc2V0W25hbWVdID0gdHJ1ZTsgfSk7XG5cdHJldHVybiBzZXQ7XG59O1xuXG59LHt9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pcy1pbXBsZW1lbnRlZFwiKSgpID8gT2JqZWN0LnNldFByb3RvdHlwZU9mIDogcmVxdWlyZShcIi4vc2hpbVwiKTtcblxufSx7XCIuL2lzLWltcGxlbWVudGVkXCI6NTMsXCIuL3NoaW1cIjo1NH1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIHBsYWluT2JqZWN0ID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC8qIEN1c3RvbUNyZWF0ZSovKSB7XG5cdHZhciBzZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiwgY3VzdG9tQ3JlYXRlID0gYXJndW1lbnRzWzBdIHx8IGNyZWF0ZTtcblx0aWYgKHR5cGVvZiBzZXRQcm90b3R5cGVPZiAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBnZXRQcm90b3R5cGVPZihzZXRQcm90b3R5cGVPZihjdXN0b21DcmVhdGUobnVsbCksIHBsYWluT2JqZWN0KSkgPT09IHBsYWluT2JqZWN0O1xufTtcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50IG5vLXByb3RvOiBcIm9mZlwiICovXG5cbi8vIEJpZyB0aGFua3MgdG8gQFdlYlJlZmxlY3Rpb24gZm9yIHNvcnRpbmcgdGhpcyBvdXRcbi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vNTU5MzU1NFxuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2JqZWN0ICAgICAgICAgPSByZXF1aXJlKFwiLi4vaXMtb2JqZWN0XCIpXG4gICwgdmFsdWUgICAgICAgICAgICA9IHJlcXVpcmUoXCIuLi92YWxpZC12YWx1ZVwiKVxuICAsIG9iaklzUHJvdG90eXBlT2YgPSBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2ZcbiAgLCBkZWZpbmVQcm9wZXJ0eSAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICwgbnVsbERlc2MgICAgICAgICA9IHsgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfVxuICAsIHZhbGlkYXRlO1xuXG52YWxpZGF0ZSA9IGZ1bmN0aW9uIChvYmosIHByb3RvdHlwZSkge1xuXHR2YWx1ZShvYmopO1xuXHRpZiAocHJvdG90eXBlID09PSBudWxsIHx8IGlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiBvYmo7XG5cdHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm90b3R5cGUgbXVzdCBiZSBudWxsIG9yIGFuIG9iamVjdFwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uIChzdGF0dXMpIHtcblx0dmFyIGZuLCBzZXQ7XG5cdGlmICghc3RhdHVzKSByZXR1cm4gbnVsbDtcblx0aWYgKHN0YXR1cy5sZXZlbCA9PT0gMikge1xuXHRcdGlmIChzdGF0dXMuc2V0KSB7XG5cdFx0XHRzZXQgPSBzdGF0dXMuc2V0O1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0c2V0LmNhbGwodmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLCBwcm90b3R5cGUpO1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiAob2JqLCBwcm90b3R5cGUpIHtcblx0XHRcdFx0dmFsaWRhdGUob2JqLCBwcm90b3R5cGUpLl9fcHJvdG9fXyA9IHByb3RvdHlwZTtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH07XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZuID0gZnVuY3Rpb24gc2VsZihvYmosIHByb3RvdHlwZSkge1xuXHRcdFx0dmFyIGlzTnVsbEJhc2U7XG5cdFx0XHR2YWxpZGF0ZShvYmosIHByb3RvdHlwZSk7XG5cdFx0XHRpc051bGxCYXNlID0gb2JqSXNQcm90b3R5cGVPZi5jYWxsKHNlbGYubnVsbFBvbHlmaWxsLCBvYmopO1xuXHRcdFx0aWYgKGlzTnVsbEJhc2UpIGRlbGV0ZSBzZWxmLm51bGxQb2x5ZmlsbC5fX3Byb3RvX187XG5cdFx0XHRpZiAocHJvdG90eXBlID09PSBudWxsKSBwcm90b3R5cGUgPSBzZWxmLm51bGxQb2x5ZmlsbDtcblx0XHRcdG9iai5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG5cdFx0XHRpZiAoaXNOdWxsQmFzZSkgZGVmaW5lUHJvcGVydHkoc2VsZi5udWxsUG9seWZpbGwsIFwiX19wcm90b19fXCIsIG51bGxEZXNjKTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBcImxldmVsXCIsIHtcblx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHdyaXRhYmxlOiBmYWxzZSxcblx0XHR2YWx1ZTogc3RhdHVzLmxldmVsXG5cdH0pO1xufSkoXG5cdChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRtcE9iajEgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cdFx0ICAsIHRtcE9iajIgPSB7fVxuXHRcdCAgLCBzZXRcblx0XHQgICwgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgXCJfX3Byb3RvX19cIik7XG5cblx0XHRpZiAoZGVzYykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c2V0ID0gZGVzYy5zZXQ7IC8vIE9wZXJhIGNyYXNoZXMgYXQgdGhpcyBwb2ludFxuXHRcdFx0XHRzZXQuY2FsbCh0bXBPYmoxLCB0bXBPYmoyKTtcblx0XHRcdH0gY2F0Y2ggKGlnbm9yZSkge31cblx0XHRcdGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodG1wT2JqMSkgPT09IHRtcE9iajIpIHJldHVybiB7IHNldDogc2V0LCBsZXZlbDogMiB9O1xuXHRcdH1cblxuXHRcdHRtcE9iajEuX19wcm90b19fID0gdG1wT2JqMjtcblx0XHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRtcE9iajEpID09PSB0bXBPYmoyKSByZXR1cm4geyBsZXZlbDogMiB9O1xuXG5cdFx0dG1wT2JqMSA9IHt9O1xuXHRcdHRtcE9iajEuX19wcm90b19fID0gdG1wT2JqMjtcblx0XHRpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRtcE9iajEpID09PSB0bXBPYmoyKSByZXR1cm4geyBsZXZlbDogMSB9O1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KSgpXG4pO1xuXG5yZXF1aXJlKFwiLi4vY3JlYXRlXCIpO1xuXG59LHtcIi4uL2NyZWF0ZVwiOjQyLFwiLi4vaXMtb2JqZWN0XCI6NDQsXCIuLi92YWxpZC12YWx1ZVwiOjU2fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArIFwiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRyZXR1cm4gZm47XG59O1xuXG59LHt9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgPSByZXF1aXJlKFwiLi9pcy12YWx1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0aWYgKCFpc1ZhbHVlKHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgbnVsbCBvciB1bmRlZmluZWRcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbn0se1wiLi9pcy12YWx1ZVwiOjQ1fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKSA/IFN0cmluZy5wcm90b3R5cGUuY29udGFpbnMgOiByZXF1aXJlKFwiLi9zaGltXCIpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjo1OCxcIi4vc2hpbVwiOjU5fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHIgPSBcInJhemR3YXRyenlcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc3RyLmNvbnRhaW5zICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHN0ci5jb250YWlucyhcImR3YVwiKSA9PT0gdHJ1ZSAmJiBzdHIuY29udGFpbnMoXCJmb29cIikgPT09IGZhbHNlO1xufTtcblxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbmRleE9mID0gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmcvKiwgcG9zaXRpb24qLykge1xuXHRyZXR1cm4gaW5kZXhPZi5jYWxsKHRoaXMsIHNlYXJjaFN0cmluZywgYXJndW1lbnRzWzFdKSA+IC0xO1xufTtcblxufSx7fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsIGlkID0gb2JqVG9TdHJpbmcuY2FsbChcIlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHxcblx0XHQodmFsdWUgJiZcblx0XHRcdHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuXHRcdFx0KHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBpZCkpIHx8XG5cdFx0ZmFsc2Vcblx0KTtcbn07XG5cbn0se31dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKVxuICAsIGNvbnRhaW5zICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvc3RyaW5nLyMvY29udGFpbnNcIilcbiAgLCBkICAgICAgICAgICAgICA9IHJlcXVpcmUoXCJkXCIpXG4gICwgU3ltYm9sICAgICAgICAgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZShcIi4vXCIpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIEFycmF5SXRlcmF0b3I7XG5cbkFycmF5SXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcnIsIGtpbmQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEFycmF5SXRlcmF0b3IpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3IgcmVxdWlyZXMgJ25ldydcIik7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgYXJyKTtcblx0aWYgKCFraW5kKSBraW5kID0gXCJ2YWx1ZVwiO1xuXHRlbHNlIGlmIChjb250YWlucy5jYWxsKGtpbmQsIFwia2V5K3ZhbHVlXCIpKSBraW5kID0gXCJrZXkrdmFsdWVcIjtcblx0ZWxzZSBpZiAoY29udGFpbnMuY2FsbChraW5kLCBcImtleVwiKSkga2luZCA9IFwia2V5XCI7XG5cdGVsc2Uga2luZCA9IFwidmFsdWVcIjtcblx0ZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX2tpbmRfX1wiLCBkKFwiXCIsIGtpbmQpKTtcbn07XG5pZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKEFycmF5SXRlcmF0b3IsIEl0ZXJhdG9yKTtcblxuLy8gSW50ZXJuYWwgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlIGRvZXNuJ3QgZXhwb3NlIGl0cyBjb25zdHJ1Y3RvclxuZGVsZXRlIEFycmF5SXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5BcnJheUl0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3IucHJvdG90eXBlLCB7XG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09IFwidmFsdWVcIikgcmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09IFwia2V5K3ZhbHVlXCIpIHJldHVybiBbaSwgdGhpcy5fX2xpc3RfX1tpXV07XG5cdFx0cmV0dXJuIGk7XG5cdH0pXG59KTtcbmRlZmluZVByb3BlcnR5KEFycmF5SXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoXCJjXCIsIFwiQXJyYXkgSXRlcmF0b3JcIikpO1xuXG59LHtcIi4vXCI6NjQsXCJkXCI6MTUsXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCI6NTIsXCJlczUtZXh0L3N0cmluZy8jL2NvbnRhaW5zXCI6NTcsXCJlczYtc3ltYm9sXCI6NzR9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZShcImVzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzXCIpXG4gICwgY2FsbGFibGUgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIilcbiAgLCBpc1N0cmluZyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIilcbiAgLCBnZXQgICAgICAgICA9IHJlcXVpcmUoXCIuL2dldFwiKTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwsIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGNiIC8qLCB0aGlzQXJnKi8pIHtcblx0dmFyIG1vZGUsIHRoaXNBcmcgPSBhcmd1bWVudHNbMl0sIHJlc3VsdCwgZG9CcmVhaywgYnJva2VuLCBpLCBsZW5ndGgsIGNoYXIsIGNvZGU7XG5cdGlmIChpc0FycmF5KGl0ZXJhYmxlKSB8fCBpc0FyZ3VtZW50cyhpdGVyYWJsZSkpIG1vZGUgPSBcImFycmF5XCI7XG5cdGVsc2UgaWYgKGlzU3RyaW5nKGl0ZXJhYmxlKSkgbW9kZSA9IFwic3RyaW5nXCI7XG5cdGVsc2UgaXRlcmFibGUgPSBnZXQoaXRlcmFibGUpO1xuXG5cdGNhbGxhYmxlKGNiKTtcblx0ZG9CcmVhayA9IGZ1bmN0aW9uICgpIHtcblx0XHRicm9rZW4gPSB0cnVlO1xuXHR9O1xuXHRpZiAobW9kZSA9PT0gXCJhcnJheVwiKSB7XG5cdFx0c29tZS5jYWxsKGl0ZXJhYmxlLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgdmFsdWUsIGRvQnJlYWspO1xuXHRcdFx0cmV0dXJuIGJyb2tlbjtcblx0XHR9KTtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKG1vZGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRsZW5ndGggPSBpdGVyYWJsZS5sZW5ndGg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHRjaGFyID0gaXRlcmFibGVbaV07XG5cdFx0XHRpZiAoaSArIDEgPCBsZW5ndGgpIHtcblx0XHRcdFx0Y29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0aWYgKGNvZGUgPj0gMHhkODAwICYmIGNvZGUgPD0gMHhkYmZmKSBjaGFyICs9IGl0ZXJhYmxlWysraV07XG5cdFx0XHR9XG5cdFx0XHRjYWxsLmNhbGwoY2IsIHRoaXNBcmcsIGNoYXIsIGRvQnJlYWspO1xuXHRcdFx0aWYgKGJyb2tlbikgYnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXHRyZXN1bHQgPSBpdGVyYWJsZS5uZXh0KCk7XG5cblx0d2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuXHRcdGNhbGwuY2FsbChjYiwgdGhpc0FyZywgcmVzdWx0LnZhbHVlLCBkb0JyZWFrKTtcblx0XHRpZiAoYnJva2VuKSByZXR1cm47XG5cdFx0cmVzdWx0ID0gaXRlcmFibGUubmV4dCgpO1xuXHR9XG59O1xuXG59LHtcIi4vZ2V0XCI6NjMsXCJlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiOjI2LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIjo1NSxcImVzNS1leHQvc3RyaW5nL2lzLXN0cmluZ1wiOjYwfV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0FyZ3VtZW50cyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L2Z1bmN0aW9uL2lzLWFyZ3VtZW50c1wiKVxuICAsIGlzU3RyaW5nICAgICAgID0gcmVxdWlyZShcImVzNS1leHQvc3RyaW5nL2lzLXN0cmluZ1wiKVxuICAsIEFycmF5SXRlcmF0b3IgID0gcmVxdWlyZShcIi4vYXJyYXlcIilcbiAgLCBTdHJpbmdJdGVyYXRvciA9IHJlcXVpcmUoXCIuL3N0cmluZ1wiKVxuICAsIGl0ZXJhYmxlICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWQtaXRlcmFibGVcIilcbiAgLCBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpLml0ZXJhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKHR5cGVvZiBpdGVyYWJsZShvYmopW2l0ZXJhdG9yU3ltYm9sXSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gb2JqW2l0ZXJhdG9yU3ltYm9sXSgpO1xuXHRpZiAoaXNBcmd1bWVudHMob2JqKSkgcmV0dXJuIG5ldyBBcnJheUl0ZXJhdG9yKG9iaik7XG5cdGlmIChpc1N0cmluZyhvYmopKSByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKG9iaik7XG5cdHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xufTtcblxufSx7XCIuL2FycmF5XCI6NjEsXCIuL3N0cmluZ1wiOjY2LFwiLi92YWxpZC1pdGVyYWJsZVwiOjY3LFwiZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIjoyNixcImVzNS1leHQvc3RyaW5nL2lzLXN0cmluZ1wiOjYwLFwiZXM2LXN5bWJvbFwiOjc0fV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjbGVhciAgICA9IHJlcXVpcmUoXCJlczUtZXh0L2FycmF5LyMvY2xlYXJcIilcbiAgLCBhc3NpZ24gICA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9hc3NpZ25cIilcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZVwiKVxuICAsIHZhbHVlICAgID0gcmVxdWlyZShcImVzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlXCIpXG4gICwgZCAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIGF1dG9CaW5kID0gcmVxdWlyZShcImQvYXV0by1iaW5kXCIpXG4gICwgU3ltYm9sICAgPSByZXF1aXJlKFwiZXM2LXN5bWJvbFwiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsIEl0ZXJhdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEl0ZXJhdG9yID0gZnVuY3Rpb24gKGxpc3QsIGNvbnRleHQpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEl0ZXJhdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIHJlcXVpcmVzICduZXcnXCIpO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRfX2xpc3RfXzogZChcIndcIiwgdmFsdWUobGlzdCkpLFxuXHRcdF9fY29udGV4dF9fOiBkKFwid1wiLCBjb250ZXh0KSxcblx0XHRfX25leHRJbmRleF9fOiBkKFwid1wiLCAwKVxuXHR9KTtcblx0aWYgKCFjb250ZXh0KSByZXR1cm47XG5cdGNhbGxhYmxlKGNvbnRleHQub24pO1xuXHRjb250ZXh0Lm9uKFwiX2FkZFwiLCB0aGlzLl9vbkFkZCk7XG5cdGNvbnRleHQub24oXCJfZGVsZXRlXCIsIHRoaXMuX29uRGVsZXRlKTtcblx0Y29udGV4dC5vbihcIl9jbGVhclwiLCB0aGlzLl9vbkNsZWFyKTtcbn07XG5cbi8vIEludGVybmFsICVJdGVyYXRvclByb3RvdHlwZSUgZG9lc24ndCBleHBvc2UgaXRzIGNvbnN0cnVjdG9yXG5kZWxldGUgSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5kZWZpbmVQcm9wZXJ0aWVzKFxuXHRJdGVyYXRvci5wcm90b3R5cGUsXG5cdGFzc2lnbihcblx0XHR7XG5cdFx0XHRfbmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRpZiAoIXRoaXMuX19saXN0X18pIHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVkb19fKSB7XG5cdFx0XHRcdFx0aSA9IHRoaXMuX19yZWRvX18uc2hpZnQoKTtcblx0XHRcdFx0XHRpZiAoaSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fX25leHRJbmRleF9fIDwgdGhpcy5fX2xpc3RfXy5sZW5ndGgpIHJldHVybiB0aGlzLl9fbmV4dEluZGV4X18rKztcblx0XHRcdFx0dGhpcy5fdW5CaW5kKCk7XG5cdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHR9KSxcblx0XHRcdG5leHQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlUmVzdWx0KHRoaXMuX25leHQoKSk7XG5cdFx0XHR9KSxcblx0XHRcdF9jcmVhdGVSZXN1bHQ6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0aWYgKGkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuXHRcdFx0XHRyZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuX3Jlc29sdmUoaSkgfTtcblx0XHRcdH0pLFxuXHRcdFx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX19saXN0X19baV07XG5cdFx0XHR9KSxcblx0XHRcdF91bkJpbmQ6IGQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGlzLl9fbGlzdF9fID0gbnVsbDtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX19yZWRvX187XG5cdFx0XHRcdGlmICghdGhpcy5fX2NvbnRleHRfXykgcmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fLm9mZihcIl9hZGRcIiwgdGhpcy5fb25BZGQpO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fLm9mZihcIl9kZWxldGVcIiwgdGhpcy5fb25EZWxldGUpO1xuXHRcdFx0XHR0aGlzLl9fY29udGV4dF9fLm9mZihcIl9jbGVhclwiLCB0aGlzLl9vbkNsZWFyKTtcblx0XHRcdFx0dGhpcy5fX2NvbnRleHRfXyA9IG51bGw7XG5cdFx0XHR9KSxcblx0XHRcdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIFwiW29iamVjdCBcIiArICh0aGlzW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgXCJPYmplY3RcIikgKyBcIl1cIjtcblx0XHRcdH0pXG5cdFx0fSxcblx0XHRhdXRvQmluZCh7XG5cdFx0XHRfb25BZGQ6IGQoZnVuY3Rpb24gKGluZGV4KSB7XG5cdFx0XHRcdGlmIChpbmRleCA+PSB0aGlzLl9fbmV4dEluZGV4X18pIHJldHVybjtcblx0XHRcdFx0Kyt0aGlzLl9fbmV4dEluZGV4X187XG5cdFx0XHRcdGlmICghdGhpcy5fX3JlZG9fXykge1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX19yZWRvX19cIiwgZChcImNcIiwgW2luZGV4XSkpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9fcmVkb19fLmZvckVhY2goZnVuY3Rpb24gKHJlZG8sIGkpIHtcblx0XHRcdFx0XHRpZiAocmVkbyA+PSBpbmRleCkgdGhpcy5fX3JlZG9fX1tpXSA9ICsrcmVkbztcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRcdHRoaXMuX19yZWRvX18ucHVzaChpbmRleCk7XG5cdFx0XHR9KSxcblx0XHRcdF9vbkRlbGV0ZTogZChmdW5jdGlvbiAoaW5kZXgpIHtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdGlmIChpbmRleCA+PSB0aGlzLl9fbmV4dEluZGV4X18pIHJldHVybjtcblx0XHRcdFx0LS10aGlzLl9fbmV4dEluZGV4X187XG5cdFx0XHRcdGlmICghdGhpcy5fX3JlZG9fXykgcmV0dXJuO1xuXHRcdFx0XHRpID0gdGhpcy5fX3JlZG9fXy5pbmRleE9mKGluZGV4KTtcblx0XHRcdFx0aWYgKGkgIT09IC0xKSB0aGlzLl9fcmVkb19fLnNwbGljZShpLCAxKTtcblx0XHRcdFx0dGhpcy5fX3JlZG9fXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWRvLCBqKSB7XG5cdFx0XHRcdFx0aWYgKHJlZG8gPiBpbmRleCkgdGhpcy5fX3JlZG9fX1tqXSA9IC0tcmVkbztcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHR9KSxcblx0XHRcdF9vbkNsZWFyOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWRvX18pIGNsZWFyLmNhbGwodGhpcy5fX3JlZG9fXyk7XG5cdFx0XHRcdHRoaXMuX19uZXh0SW5kZXhfXyA9IDA7XG5cdFx0XHR9KVxuXHRcdH0pXG5cdClcbik7XG5cbmRlZmluZVByb3BlcnR5KFxuXHRJdGVyYXRvci5wcm90b3R5cGUsXG5cdFN5bWJvbC5pdGVyYXRvcixcblx0ZChmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0pXG4pO1xuXG59LHtcImRcIjoxNSxcImQvYXV0by1iaW5kXCI6MTQsXCJlczUtZXh0L2FycmF5LyMvY2xlYXJcIjoyMSxcImVzNS1leHQvb2JqZWN0L2Fzc2lnblwiOjM4LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIjo1NSxcImVzNS1leHQvb2JqZWN0L3ZhbGlkLXZhbHVlXCI6NTYsXCJlczYtc3ltYm9sXCI6NzR9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZShcImVzNS1leHQvZnVuY3Rpb24vaXMtYXJndW1lbnRzXCIpXG4gICwgaXNWYWx1ZSAgICAgPSByZXF1aXJlKFwiZXM1LWV4dC9vYmplY3QvaXMtdmFsdWVcIilcbiAgLCBpc1N0cmluZyAgICA9IHJlcXVpcmUoXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIik7XG5cbnZhciBpdGVyYXRvclN5bWJvbCA9IHJlcXVpcmUoXCJlczYtc3ltYm9sXCIpLml0ZXJhdG9yXG4gICwgaXNBcnJheSAgICAgICAgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSByZXR1cm4gZmFsc2U7XG5cdGlmIChpc0FycmF5KHZhbHVlKSkgcmV0dXJuIHRydWU7XG5cdGlmIChpc1N0cmluZyh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAoaXNBcmd1bWVudHModmFsdWUpKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZVtpdGVyYXRvclN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIjtcbn07XG5cbn0se1wiZXM1LWV4dC9mdW5jdGlvbi9pcy1hcmd1bWVudHNcIjoyNixcImVzNS1leHQvb2JqZWN0L2lzLXZhbHVlXCI6NDUsXCJlczUtZXh0L3N0cmluZy9pcy1zdHJpbmdcIjo2MCxcImVzNi1zeW1ib2xcIjo3NH1dLDY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoYW5rcyBAbWF0aGlhc2J5bmVuc1xuLy8gaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlI2l0ZXJhdGluZy1vdmVyLXN5bWJvbHNcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpXG4gICwgZCAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIFN5bWJvbCAgICAgICAgID0gcmVxdWlyZShcImVzNi1zeW1ib2xcIilcbiAgLCBJdGVyYXRvciAgICAgICA9IHJlcXVpcmUoXCIuL1wiKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBTdHJpbmdJdGVyYXRvcjtcblxuU3RyaW5nSXRlcmF0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0cmluZ0l0ZXJhdG9yKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIHJlcXVpcmVzICduZXcnXCIpO1xuXHRzdHIgPSBTdHJpbmcoc3RyKTtcblx0SXRlcmF0b3IuY2FsbCh0aGlzLCBzdHIpO1xuXHRkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fbGVuZ3RoX19cIiwgZChcIlwiLCBzdHIubGVuZ3RoKSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihTdHJpbmdJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG4vLyBJbnRlcm5hbCAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUgZG9lc24ndCBleHBvc2UgaXRzIGNvbnN0cnVjdG9yXG5kZWxldGUgU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5TdHJpbmdJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRfbmV4dDogZChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9fbGlzdF9fKSByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdGlmICh0aGlzLl9fbmV4dEluZGV4X18gPCB0aGlzLl9fbGVuZ3RoX18pIHJldHVybiB0aGlzLl9fbmV4dEluZGV4X18rKztcblx0XHR0aGlzLl91bkJpbmQoKTtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9KSxcblx0X3Jlc29sdmU6IGQoZnVuY3Rpb24gKGkpIHtcblx0XHR2YXIgY2hhciA9IHRoaXMuX19saXN0X19baV0sIGNvZGU7XG5cdFx0aWYgKHRoaXMuX19uZXh0SW5kZXhfXyA9PT0gdGhpcy5fX2xlbmd0aF9fKSByZXR1cm4gY2hhcjtcblx0XHRjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXHRcdGlmIChjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZikgcmV0dXJuIGNoYXIgKyB0aGlzLl9fbGlzdF9fW3RoaXMuX19uZXh0SW5kZXhfXysrXTtcblx0XHRyZXR1cm4gY2hhcjtcblx0fSlcbn0pO1xuZGVmaW5lUHJvcGVydHkoU3RyaW5nSXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIGQoXCJjXCIsIFwiU3RyaW5nIEl0ZXJhdG9yXCIpKTtcblxufSx7XCIuL1wiOjY0LFwiZFwiOjE1LFwiZXM1LWV4dC9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiOjUyLFwiZXM2LXN5bWJvbFwiOjc0fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0l0ZXJhYmxlID0gcmVxdWlyZShcIi4vaXMtaXRlcmFibGVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNJdGVyYWJsZSh2YWx1ZSkpIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbn0se1wiLi9pcy1pdGVyYWJsZVwiOjY1fV0sNjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaXMtaW1wbGVtZW50ZWQnKSgpID8gTWFwIDogcmVxdWlyZSgnLi9wb2x5ZmlsbCcpO1xuXG59LHtcIi4vaXMtaW1wbGVtZW50ZWRcIjo2OSxcIi4vcG9seWZpbGxcIjo3M31dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBtYXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG5cdGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdHRyeSB7XG5cdFx0Ly8gV2ViS2l0IGRvZXNuJ3Qgc3VwcG9ydCBhcmd1bWVudHMgYW5kIGNyYXNoZXNcblx0XHRtYXAgPSBuZXcgTWFwKFtbJ3JheicsICdvbmUnXSwgWydkd2EnLCAndHdvJ10sIFsndHJ6eScsICd0aHJlZSddXSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKFN0cmluZyhtYXApICE9PSAnW29iamVjdCBNYXBdJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAobWFwLnNpemUgIT09IDMpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuY2xlYXIgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZGVsZXRlICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmVudHJpZXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXHRpZiAodHlwZW9mIG1hcC5nZXQgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuaGFzICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLmtleXMgIT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0aWYgKHR5cGVvZiBtYXAuc2V0ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgbWFwLnZhbHVlcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuXG5cdGl0ZXJhdG9yID0gbWFwLmVudHJpZXMoKTtcblx0cmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRpZiAocmVzdWx0LmRvbmUgIT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cdGlmICghcmVzdWx0LnZhbHVlKSByZXR1cm4gZmFsc2U7XG5cdGlmIChyZXN1bHQudmFsdWVbMF0gIT09ICdyYXonKSByZXR1cm4gZmFsc2U7XG5cdGlmIChyZXN1bHQudmFsdWVbMV0gIT09ICdvbmUnKSByZXR1cm4gZmFsc2U7XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG59LHt9XSw3MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBFeHBvcnRzIHRydWUgaWYgZW52aXJvbm1lbnQgcHJvdmlkZXMgbmF0aXZlIGBNYXBgIGltcGxlbWVudGF0aW9uLFxuLy8gd2hhdGV2ZXIgdGhhdCBpcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykgcmV0dXJuIGZhbHNlO1xuXHRyZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXcgTWFwKCkpID09PSAnW29iamVjdCBNYXBdJyk7XG59KCkpO1xuXG59LHt9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvcHJpbWl0aXZlLXNldCcpKCdrZXknLFxuXHQndmFsdWUnLCAna2V5K3ZhbHVlJyk7XG5cbn0se1wiZXM1LWV4dC9vYmplY3QvcHJpbWl0aXZlLXNldFwiOjUxfV0sNzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgICAgPSByZXF1aXJlKCdlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mJylcbiAgLCBkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2QnKVxuICAsIEl0ZXJhdG9yICAgICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yJylcbiAgLCB0b1N0cmluZ1RhZ1N5bWJvbCA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKS50b1N0cmluZ1RhZ1xuICAsIGtpbmRzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9pdGVyYXRvci1raW5kcycpXG5cbiAgLCBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgLCB1bkJpbmQgPSBJdGVyYXRvci5wcm90b3R5cGUuX3VuQmluZFxuICAsIE1hcEl0ZXJhdG9yO1xuXG5NYXBJdGVyYXRvciA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1hcCwga2luZCkge1xuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFwSXRlcmF0b3IpKSByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKG1hcCwga2luZCk7XG5cdEl0ZXJhdG9yLmNhbGwodGhpcywgbWFwLl9fbWFwS2V5c0RhdGFfXywgbWFwKTtcblx0aWYgKCFraW5kIHx8ICFraW5kc1traW5kXSkga2luZCA9ICdrZXkrdmFsdWUnO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHRfX2tpbmRfXzogZCgnJywga2luZCksXG5cdFx0X192YWx1ZXNfXzogZCgndycsIG1hcC5fX21hcFZhbHVlc0RhdGFfXylcblx0fSk7XG59O1xuaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihNYXBJdGVyYXRvciwgSXRlcmF0b3IpO1xuXG5NYXBJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yLnByb3RvdHlwZSwge1xuXHRjb25zdHJ1Y3RvcjogZChNYXBJdGVyYXRvciksXG5cdF9yZXNvbHZlOiBkKGZ1bmN0aW9uIChpKSB7XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICd2YWx1ZScpIHJldHVybiB0aGlzLl9fdmFsdWVzX19baV07XG5cdFx0aWYgKHRoaXMuX19raW5kX18gPT09ICdrZXknKSByZXR1cm4gdGhpcy5fX2xpc3RfX1tpXTtcblx0XHRyZXR1cm4gW3RoaXMuX19saXN0X19baV0sIHRoaXMuX192YWx1ZXNfX1tpXV07XG5cdH0pLFxuXHRfdW5CaW5kOiBkKGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9fdmFsdWVzX18gPSBudWxsO1xuXHRcdHVuQmluZC5jYWxsKHRoaXMpO1xuXHR9KSxcblx0dG9TdHJpbmc6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7IH0pXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBJdGVyYXRvci5wcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLFxuXHRkKCdjJywgJ01hcCBJdGVyYXRvcicpKTtcblxufSx7XCIuL2l0ZXJhdG9yLWtpbmRzXCI6NzEsXCJkXCI6MTUsXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCI6NTIsXCJlczYtaXRlcmF0b3JcIjo2NCxcImVzNi1zeW1ib2xcIjo3NH1dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGNsZWFyICAgICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9hcnJheS8jL2NsZWFyJylcbiAgLCBlSW5kZXhPZiAgICAgICA9IHJlcXVpcmUoJ2VzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mJylcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YnKVxuICAsIGNhbGxhYmxlICAgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGUnKVxuICAsIHZhbGlkVmFsdWUgICAgID0gcmVxdWlyZSgnZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWUnKVxuICAsIGQgICAgICAgICAgICAgID0gcmVxdWlyZSgnZCcpXG4gICwgZWUgICAgICAgICAgICAgPSByZXF1aXJlKCdldmVudC1lbWl0dGVyJylcbiAgLCBTeW1ib2wgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1zeW1ib2wnKVxuICAsIGl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnZXM2LWl0ZXJhdG9yL3ZhbGlkLWl0ZXJhYmxlJylcbiAgLCBmb3JPZiAgICAgICAgICA9IHJlcXVpcmUoJ2VzNi1pdGVyYXRvci9mb3Itb2YnKVxuICAsIEl0ZXJhdG9yICAgICAgID0gcmVxdWlyZSgnLi9saWIvaXRlcmF0b3InKVxuICAsIGlzTmF0aXZlICAgICAgID0gcmVxdWlyZSgnLi9pcy1uYXRpdmUtaW1wbGVtZW50ZWQnKVxuXG4gICwgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsXG4gICwgZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxuICAsIE1hcFBvbHk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwUG9seSA9IGZ1bmN0aW9uICgvKml0ZXJhYmxlKi8pIHtcblx0dmFyIGl0ZXJhYmxlID0gYXJndW1lbnRzWzBdLCBrZXlzLCB2YWx1ZXMsIHNlbGY7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYXBQb2x5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29uc3RydWN0b3IgcmVxdWlyZXMgXFwnbmV3XFwnJyk7XG5cdGlmIChpc05hdGl2ZSAmJiBzZXRQcm90b3R5cGVPZiAmJiAoTWFwICE9PSBNYXBQb2x5KSkge1xuXHRcdHNlbGYgPSBzZXRQcm90b3R5cGVPZihuZXcgTWFwKCksIGdldFByb3RvdHlwZU9mKHRoaXMpKTtcblx0fSBlbHNlIHtcblx0XHRzZWxmID0gdGhpcztcblx0fVxuXHRpZiAoaXRlcmFibGUgIT0gbnVsbCkgaXRlcmF0b3IoaXRlcmFibGUpO1xuXHRkZWZpbmVQcm9wZXJ0aWVzKHNlbGYsIHtcblx0XHRfX21hcEtleXNEYXRhX186IGQoJ2MnLCBrZXlzID0gW10pLFxuXHRcdF9fbWFwVmFsdWVzRGF0YV9fOiBkKCdjJywgdmFsdWVzID0gW10pXG5cdH0pO1xuXHRpZiAoIWl0ZXJhYmxlKSByZXR1cm4gc2VsZjtcblx0Zm9yT2YoaXRlcmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHZhciBrZXkgPSB2YWxpZFZhbHVlKHZhbHVlKVswXTtcblx0XHR2YWx1ZSA9IHZhbHVlWzFdO1xuXHRcdGlmIChlSW5kZXhPZi5jYWxsKGtleXMsIGtleSkgIT09IC0xKSByZXR1cm47XG5cdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0dmFsdWVzLnB1c2godmFsdWUpO1xuXHR9LCBzZWxmKTtcblx0cmV0dXJuIHNlbGY7XG59O1xuXG5pZiAoaXNOYXRpdmUpIHtcblx0aWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihNYXBQb2x5LCBNYXApO1xuXHRNYXBQb2x5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTWFwLnByb3RvdHlwZSwge1xuXHRcdGNvbnN0cnVjdG9yOiBkKE1hcFBvbHkpXG5cdH0pO1xufVxuXG5lZShkZWZpbmVQcm9wZXJ0aWVzKE1hcFBvbHkucHJvdG90eXBlLCB7XG5cdGNsZWFyOiBkKGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX19tYXBLZXlzRGF0YV9fLmxlbmd0aCkgcmV0dXJuO1xuXHRcdGNsZWFyLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18pO1xuXHRcdGNsZWFyLmNhbGwodGhpcy5fX21hcFZhbHVlc0RhdGFfXyk7XG5cdFx0dGhpcy5lbWl0KCdfY2xlYXInKTtcblx0fSksXG5cdGRlbGV0ZTogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIGluZGV4ID0gZUluZGV4T2YuY2FsbCh0aGlzLl9fbWFwS2V5c0RhdGFfXywga2V5KTtcblx0XHRpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cdFx0dGhpcy5fX21hcEtleXNEYXRhX18uc3BsaWNlKGluZGV4LCAxKTtcblx0XHR0aGlzLl9fbWFwVmFsdWVzRGF0YV9fLnNwbGljZShpbmRleCwgMSk7XG5cdFx0dGhpcy5lbWl0KCdfZGVsZXRlJywgaW5kZXgsIGtleSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0pLFxuXHRlbnRyaWVzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJyk7IH0pLFxuXHRmb3JFYWNoOiBkKGZ1bmN0aW9uIChjYi8qLCB0aGlzQXJnKi8pIHtcblx0XHR2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXSwgaXRlcmF0b3IsIHJlc3VsdDtcblx0XHRjYWxsYWJsZShjYik7XG5cdFx0aXRlcmF0b3IgPSB0aGlzLmVudHJpZXMoKTtcblx0XHRyZXN1bHQgPSBpdGVyYXRvci5fbmV4dCgpO1xuXHRcdHdoaWxlIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2FsbC5jYWxsKGNiLCB0aGlzQXJnLCB0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW3Jlc3VsdF0sXG5cdFx0XHRcdHRoaXMuX19tYXBLZXlzRGF0YV9fW3Jlc3VsdF0sIHRoaXMpO1xuXHRcdFx0cmVzdWx0ID0gaXRlcmF0b3IuX25leHQoKTtcblx0XHR9XG5cdH0pLFxuXHRnZXQ6IGQoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciBpbmRleCA9IGVJbmRleE9mLmNhbGwodGhpcy5fX21hcEtleXNEYXRhX18sIGtleSk7XG5cdFx0aWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuXHRcdHJldHVybiB0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW2luZGV4XTtcblx0fSksXG5cdGhhczogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0cmV0dXJuIChlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpICE9PSAtMSk7XG5cdH0pLFxuXHRrZXlzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAna2V5Jyk7IH0pLFxuXHRzZXQ6IGQoZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHR2YXIgaW5kZXggPSBlSW5kZXhPZi5jYWxsKHRoaXMuX19tYXBLZXlzRGF0YV9fLCBrZXkpLCBlbWl0O1xuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdGluZGV4ID0gdGhpcy5fX21hcEtleXNEYXRhX18ucHVzaChrZXkpIC0gMTtcblx0XHRcdGVtaXQgPSB0cnVlO1xuXHRcdH1cblx0XHR0aGlzLl9fbWFwVmFsdWVzRGF0YV9fW2luZGV4XSA9IHZhbHVlO1xuXHRcdGlmIChlbWl0KSB0aGlzLmVtaXQoJ19hZGQnLCBpbmRleCwga2V5KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSksXG5cdHNpemU6IGQuZ3MoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fX21hcEtleXNEYXRhX18ubGVuZ3RoOyB9KSxcblx0dmFsdWVzOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvcih0aGlzLCAndmFsdWUnKTsgfSksXG5cdHRvU3RyaW5nOiBkKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdbb2JqZWN0IE1hcF0nOyB9KVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFBvbHkucHJvdG90eXBlLCBTeW1ib2wuaXRlcmF0b3IsIGQoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwUG9seS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgZCgnYycsICdNYXAnKSk7XG5cbn0se1wiLi9pcy1uYXRpdmUtaW1wbGVtZW50ZWRcIjo3MCxcIi4vbGliL2l0ZXJhdG9yXCI6NzIsXCJkXCI6MTUsXCJlczUtZXh0L2FycmF5LyMvY2xlYXJcIjoyMSxcImVzNS1leHQvYXJyYXkvIy9lLWluZGV4LW9mXCI6MjIsXCJlczUtZXh0L29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCI6NTIsXCJlczUtZXh0L29iamVjdC92YWxpZC1jYWxsYWJsZVwiOjU1LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtdmFsdWVcIjo1NixcImVzNi1pdGVyYXRvci9mb3Itb2ZcIjo2MixcImVzNi1pdGVyYXRvci92YWxpZC1pdGVyYWJsZVwiOjY3LFwiZXM2LXN5bWJvbFwiOjc0LFwiZXZlbnQtZW1pdHRlclwiOjgyfV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaXMtaW1wbGVtZW50ZWRcIikoKVxuXHQ/IHJlcXVpcmUoXCJleHQvZ2xvYmFsLXRoaXNcIikuU3ltYm9sXG5cdDogcmVxdWlyZShcIi4vcG9seWZpbGxcIik7XG5cbn0se1wiLi9pcy1pbXBsZW1lbnRlZFwiOjc1LFwiLi9wb2x5ZmlsbFwiOjgwLFwiZXh0L2dsb2JhbC10aGlzXCI6ODV9XSw3NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGdsb2JhbCAgICAgPSByZXF1aXJlKFwiZXh0L2dsb2JhbC10aGlzXCIpXG4gICwgdmFsaWRUeXBlcyA9IHsgb2JqZWN0OiB0cnVlLCBzeW1ib2w6IHRydWUgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xuXHR2YXIgc3ltYm9sO1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdHN5bWJvbCA9IFN5bWJvbChcInRlc3Qgc3ltYm9sXCIpO1xuXHR0cnkgeyBTdHJpbmcoc3ltYm9sKTsgfVxuXHRjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBSZXR1cm4gJ3RydWUnIGFsc28gZm9yIHBvbHlmaWxsc1xuXHRpZiAoIXZhbGlkVHlwZXNbdHlwZW9mIFN5bWJvbC5pdGVyYXRvcl0pIHJldHVybiBmYWxzZTtcblx0aWYgKCF2YWxpZFR5cGVzW3R5cGVvZiBTeW1ib2wudG9QcmltaXRpdmVdKSByZXR1cm4gZmFsc2U7XG5cdGlmICghdmFsaWRUeXBlc1t0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnXSkgcmV0dXJuIGZhbHNlO1xuXG5cdHJldHVybiB0cnVlO1xufTtcblxufSx7XCJleHQvZ2xvYmFsLXRoaXNcIjo4NX1dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2U7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3ltYm9sXCIpIHJldHVybiB0cnVlO1xuXHRpZiAoIXZhbHVlLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cdGlmICh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSBcIlN5bWJvbFwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiB2YWx1ZVt2YWx1ZS5jb25zdHJ1Y3Rvci50b1N0cmluZ1RhZ10gPT09IFwiU3ltYm9sXCI7XG59O1xuXG59LHt9XSw3NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGQgPSByZXF1aXJlKFwiZFwiKTtcblxudmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBvYmpQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG52YXIgY3JlYXRlZCA9IGNyZWF0ZShudWxsKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlc2MpIHtcblx0dmFyIHBvc3RmaXggPSAwLCBuYW1lLCBpZTExQnVnV29ya2Fyb3VuZDtcblx0d2hpbGUgKGNyZWF0ZWRbZGVzYyArIChwb3N0Zml4IHx8IFwiXCIpXSkgKytwb3N0Zml4O1xuXHRkZXNjICs9IHBvc3RmaXggfHwgXCJcIjtcblx0Y3JlYXRlZFtkZXNjXSA9IHRydWU7XG5cdG5hbWUgPSBcIkBAXCIgKyBkZXNjO1xuXHRkZWZpbmVQcm9wZXJ0eShcblx0XHRvYmpQcm90b3R5cGUsXG5cdFx0bmFtZSxcblx0XHRkLmdzKG51bGwsIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0Ly8gRm9yIElFMTEgaXNzdWUgc2VlOlxuXHRcdFx0Ly8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2tkZXRhaWwvdmlldy8xOTI4NTA4L1xuXHRcdFx0Ly8gICAgaWUxMS1icm9rZW4tZ2V0dGVycy1vbi1kb20tb2JqZWN0c1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlrb28vZXM2LXN5bWJvbC9pc3N1ZXMvMTJcblx0XHRcdGlmIChpZTExQnVnV29ya2Fyb3VuZCkgcmV0dXJuO1xuXHRcdFx0aWUxMUJ1Z1dvcmthcm91bmQgPSB0cnVlO1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwgZCh2YWx1ZSkpO1xuXHRcdFx0aWUxMUJ1Z1dvcmthcm91bmQgPSBmYWxzZTtcblx0XHR9KVxuXHQpO1xuXHRyZXR1cm4gbmFtZTtcbn07XG5cbn0se1wiZFwiOjE1fV0sNzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIE5hdGl2ZVN5bWJvbCA9IHJlcXVpcmUoXCJleHQvZ2xvYmFsLXRoaXNcIikuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTeW1ib2xQb2x5ZmlsbCkge1xuXHRyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU3ltYm9sUG9seWZpbGwsIHtcblx0XHQvLyBUbyBlbnN1cmUgcHJvcGVyIGludGVyb3BlcmFiaWxpdHkgd2l0aCBvdGhlciBuYXRpdmUgZnVuY3Rpb25zIChlLmcuIEFycmF5LmZyb20pXG5cdFx0Ly8gZmFsbGJhY2sgdG8gZXZlbnR1YWwgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIGdpdmVuIHN5bWJvbFxuXHRcdGhhc0luc3RhbmNlOiBkKFxuXHRcdFx0XCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuaGFzSW5zdGFuY2UpIHx8IFN5bWJvbFBvbHlmaWxsKFwiaGFzSW5zdGFuY2VcIilcblx0XHQpLFxuXHRcdGlzQ29uY2F0U3ByZWFkYWJsZTogZChcblx0XHRcdFwiXCIsXG5cdFx0XHQoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUpIHx8XG5cdFx0XHRcdFN5bWJvbFBvbHlmaWxsKFwiaXNDb25jYXRTcHJlYWRhYmxlXCIpXG5cdFx0KSxcblx0XHRpdGVyYXRvcjogZChcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5pdGVyYXRvcikgfHwgU3ltYm9sUG9seWZpbGwoXCJpdGVyYXRvclwiKSksXG5cdFx0bWF0Y2g6IGQoXCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wubWF0Y2gpIHx8IFN5bWJvbFBvbHlmaWxsKFwibWF0Y2hcIikpLFxuXHRcdHJlcGxhY2U6IGQoXCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wucmVwbGFjZSkgfHwgU3ltYm9sUG9seWZpbGwoXCJyZXBsYWNlXCIpKSxcblx0XHRzZWFyY2g6IGQoXCJcIiwgKE5hdGl2ZVN5bWJvbCAmJiBOYXRpdmVTeW1ib2wuc2VhcmNoKSB8fCBTeW1ib2xQb2x5ZmlsbChcInNlYXJjaFwiKSksXG5cdFx0c3BlY2llczogZChcIlwiLCAoTmF0aXZlU3ltYm9sICYmIE5hdGl2ZVN5bWJvbC5zcGVjaWVzKSB8fCBTeW1ib2xQb2x5ZmlsbChcInNwZWNpZXNcIikpLFxuXHRcdHNwbGl0OiBkKFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnNwbGl0KSB8fCBTeW1ib2xQb2x5ZmlsbChcInNwbGl0XCIpKSxcblx0XHR0b1ByaW1pdGl2ZTogZChcblx0XHRcdFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnRvUHJpbWl0aXZlKSB8fCBTeW1ib2xQb2x5ZmlsbChcInRvUHJpbWl0aXZlXCIpXG5cdFx0KSxcblx0XHR0b1N0cmluZ1RhZzogZChcblx0XHRcdFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnRvU3RyaW5nVGFnKSB8fCBTeW1ib2xQb2x5ZmlsbChcInRvU3RyaW5nVGFnXCIpXG5cdFx0KSxcblx0XHR1bnNjb3BhYmxlczogZChcblx0XHRcdFwiXCIsIChOYXRpdmVTeW1ib2wgJiYgTmF0aXZlU3ltYm9sLnVuc2NvcGFibGVzKSB8fCBTeW1ib2xQb2x5ZmlsbChcInVuc2NvcGFibGVzXCIpXG5cdFx0KVxuXHR9KTtcbn07XG5cbn0se1wiZFwiOjE1LFwiZXh0L2dsb2JhbC10aGlzXCI6ODV9XSw3OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGQgICAgICAgICAgICAgID0gcmVxdWlyZShcImRcIilcbiAgLCB2YWxpZGF0ZVN5bWJvbCA9IHJlcXVpcmUoXCIuLi8uLi8uLi92YWxpZGF0ZS1zeW1ib2xcIik7XG5cbnZhciByZWdpc3RyeSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFN5bWJvbFBvbHlmaWxsKSB7XG5cdHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhTeW1ib2xQb2x5ZmlsbCwge1xuXHRcdGZvcjogZChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAocmVnaXN0cnlba2V5XSkgcmV0dXJuIHJlZ2lzdHJ5W2tleV07XG5cdFx0XHRyZXR1cm4gKHJlZ2lzdHJ5W2tleV0gPSBTeW1ib2xQb2x5ZmlsbChTdHJpbmcoa2V5KSkpO1xuXHRcdH0pLFxuXHRcdGtleUZvcjogZChmdW5jdGlvbiAoc3ltYm9sKSB7XG5cdFx0XHR2YXIga2V5O1xuXHRcdFx0dmFsaWRhdGVTeW1ib2woc3ltYm9sKTtcblx0XHRcdGZvciAoa2V5IGluIHJlZ2lzdHJ5KSB7XG5cdFx0XHRcdGlmIChyZWdpc3RyeVtrZXldID09PSBzeW1ib2wpIHJldHVybiBrZXk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH0pXG5cdH0pO1xufTtcblxufSx7XCIuLi8uLi8uLi92YWxpZGF0ZS1zeW1ib2xcIjo4MSxcImRcIjoxNX1dLDgwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIEVTMjAxNSBTeW1ib2wgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCAob3IgcGFydGlhbGx5KSBzdXBwb3J0IGl0XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZCAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKFwiZFwiKVxuICAsIHZhbGlkYXRlU3ltYm9sICAgICAgID0gcmVxdWlyZShcIi4vdmFsaWRhdGUtc3ltYm9sXCIpXG4gICwgTmF0aXZlU3ltYm9sICAgICAgICAgPSByZXF1aXJlKFwiZXh0L2dsb2JhbC10aGlzXCIpLlN5bWJvbFxuICAsIGdlbmVyYXRlTmFtZSAgICAgICAgID0gcmVxdWlyZShcIi4vbGliL3ByaXZhdGUvZ2VuZXJhdGUtbmFtZVwiKVxuICAsIHNldHVwU3RhbmRhcmRTeW1ib2xzID0gcmVxdWlyZShcIi4vbGliL3ByaXZhdGUvc2V0dXAvc3RhbmRhcmQtc3ltYm9sc1wiKVxuICAsIHNldHVwU3ltYm9sUmVnaXN0cnkgID0gcmVxdWlyZShcIi4vbGliL3ByaXZhdGUvc2V0dXAvc3ltYm9sLXJlZ2lzdHJ5XCIpO1xuXG52YXIgY3JlYXRlID0gT2JqZWN0LmNyZWF0ZVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgU3ltYm9sUG9seWZpbGwsIEhpZGRlblN5bWJvbCwgaXNOYXRpdmVTYWZlO1xuXG5pZiAodHlwZW9mIE5hdGl2ZVN5bWJvbCA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdHRyeSB7XG5cdFx0U3RyaW5nKE5hdGl2ZVN5bWJvbCgpKTtcblx0XHRpc05hdGl2ZVNhZmUgPSB0cnVlO1xuXHR9IGNhdGNoIChpZ25vcmUpIHt9XG59IGVsc2Uge1xuXHROYXRpdmVTeW1ib2wgPSBudWxsO1xufVxuXG4vLyBJbnRlcm5hbCBjb25zdHJ1Y3RvciAobm90IG9uZSBleHBvc2VkKSBmb3IgY3JlYXRpbmcgU3ltYm9sIGluc3RhbmNlcy5cbi8vIFRoaXMgb25lIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgYHNvbWVTeW1ib2wgaW5zdGFuY2VvZiBTeW1ib2xgIGFsd2F5cyByZXR1cm4gZmFsc2VcbkhpZGRlblN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbChkZXNjcmlwdGlvbikge1xuXHRpZiAodGhpcyBpbnN0YW5jZW9mIEhpZGRlblN5bWJvbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTtcblx0cmV0dXJuIFN5bWJvbFBvbHlmaWxsKGRlc2NyaXB0aW9uKTtcbn07XG5cbi8vIEV4cG9zZWQgYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIChyZXR1cm5zIGluc3RhbmNlcyBvZiBIaWRkZW5TeW1ib2wpXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbFBvbHlmaWxsID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XG5cdHZhciBzeW1ib2w7XG5cdGlmICh0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yXCIpO1xuXHRpZiAoaXNOYXRpdmVTYWZlKSByZXR1cm4gTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcblx0c3ltYm9sID0gY3JlYXRlKEhpZGRlblN5bWJvbC5wcm90b3R5cGUpO1xuXHRkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogU3RyaW5nKGRlc2NyaXB0aW9uKTtcblx0cmV0dXJuIGRlZmluZVByb3BlcnRpZXMoc3ltYm9sLCB7XG5cdFx0X19kZXNjcmlwdGlvbl9fOiBkKFwiXCIsIGRlc2NyaXB0aW9uKSxcblx0XHRfX25hbWVfXzogZChcIlwiLCBnZW5lcmF0ZU5hbWUoZGVzY3JpcHRpb24pKVxuXHR9KTtcbn07XG5cbnNldHVwU3RhbmRhcmRTeW1ib2xzKFN5bWJvbFBvbHlmaWxsKTtcbnNldHVwU3ltYm9sUmVnaXN0cnkoU3ltYm9sUG9seWZpbGwpO1xuXG4vLyBJbnRlcm5hbCB0d2Vha3MgZm9yIHJlYWwgc3ltYm9sIHByb2R1Y2VyXG5kZWZpbmVQcm9wZXJ0aWVzKEhpZGRlblN5bWJvbC5wcm90b3R5cGUsIHtcblx0Y29uc3RydWN0b3I6IGQoU3ltYm9sUG9seWZpbGwpLFxuXHR0b1N0cmluZzogZChcIlwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9fbmFtZV9fOyB9KVxufSk7XG5cbi8vIFByb3BlciBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGV4cG9zZWQgb24gU3ltYm9sLnByb3RvdHlwZVxuLy8gVGhleSB3b24ndCBiZSBhY2Nlc3NpYmxlIG9uIHByb2R1Y2VkIHN5bWJvbCBpbnN0YW5jZXMgYXMgdGhleSBkZXJpdmUgZnJvbSBIaWRkZW5TeW1ib2wucHJvdG90eXBlXG5kZWZpbmVQcm9wZXJ0aWVzKFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwge1xuXHR0b1N0cmluZzogZChmdW5jdGlvbiAoKSB7IHJldHVybiBcIlN5bWJvbCAoXCIgKyB2YWxpZGF0ZVN5bWJvbCh0aGlzKS5fX2Rlc2NyaXB0aW9uX18gKyBcIilcIjsgfSksXG5cdHZhbHVlT2Y6IGQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsaWRhdGVTeW1ib2wodGhpcyk7IH0pXG59KTtcbmRlZmluZVByb3BlcnR5KFxuXHRTeW1ib2xQb2x5ZmlsbC5wcm90b3R5cGUsXG5cdFN5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlLFxuXHRkKFwiXCIsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc3ltYm9sID0gdmFsaWRhdGVTeW1ib2wodGhpcyk7XG5cdFx0aWYgKHR5cGVvZiBzeW1ib2wgPT09IFwic3ltYm9sXCIpIHJldHVybiBzeW1ib2w7XG5cdFx0cmV0dXJuIHN5bWJvbC50b1N0cmluZygpO1xuXHR9KVxuKTtcbmRlZmluZVByb3BlcnR5KFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIGQoXCJjXCIsIFwiU3ltYm9sXCIpKTtcblxuLy8gUHJvcGVyIGltcGxlbWVudGF0b24gb2YgdG9QcmltaXRpdmUgYW5kIHRvU3RyaW5nVGFnIGZvciByZXR1cm5lZCBzeW1ib2wgaW5zdGFuY2VzXG5kZWZpbmVQcm9wZXJ0eShcblx0SGlkZGVuU3ltYm9sLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsXG5cdGQoXCJjXCIsIFN5bWJvbFBvbHlmaWxsLnByb3RvdHlwZVtTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZ10pXG4pO1xuXG4vLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0byBkZWZpbmUgYHRvUHJpbWl0aXZlYCBhcyBsYXN0IG9uZSwgYXMgc29tZSBpbXBsZW1lbnRhdGlvbnNcbi8vIGltcGxlbWVudCBgdG9QcmltaXRpdmVgIG5hdGl2ZWx5IHdpdGhvdXQgaW1wbGVtZW50aW5nIGB0b1N0cmluZ1RhZ2AgKG9yIG90aGVyIHNwZWNpZmllZCBzeW1ib2xzKVxuLy8gQW5kIHRoYXQgbWF5IGludm9rZSBlcnJvciBpbiBkZWZpbml0aW9uIGZsb3c6XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpa29vL2VzNi1zeW1ib2wvaXNzdWVzLzEzI2lzc3VlY29tbWVudC0xNjQxNDYxNDlcbmRlZmluZVByb3BlcnR5KFxuXHRIaWRkZW5TeW1ib2wucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1ByaW1pdGl2ZSxcblx0ZChcImNcIiwgU3ltYm9sUG9seWZpbGwucHJvdG90eXBlW1N5bWJvbFBvbHlmaWxsLnRvUHJpbWl0aXZlXSlcbik7XG5cbn0se1wiLi9saWIvcHJpdmF0ZS9nZW5lcmF0ZS1uYW1lXCI6NzcsXCIuL2xpYi9wcml2YXRlL3NldHVwL3N0YW5kYXJkLXN5bWJvbHNcIjo3OCxcIi4vbGliL3ByaXZhdGUvc2V0dXAvc3ltYm9sLXJlZ2lzdHJ5XCI6NzksXCIuL3ZhbGlkYXRlLXN5bWJvbFwiOjgxLFwiZFwiOjE1LFwiZXh0L2dsb2JhbC10aGlzXCI6ODV9XSw4MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzU3ltYm9sID0gcmVxdWlyZShcIi4vaXMtc3ltYm9sXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzU3ltYm9sKHZhbHVlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArIFwiIGlzIG5vdCBhIHN5bWJvbFwiKTtcblx0cmV0dXJuIHZhbHVlO1xufTtcblxufSx7XCIuL2lzLXN5bWJvbFwiOjc2fV0sODI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZCAgICAgICAgPSByZXF1aXJlKCdkJylcbiAgLCBjYWxsYWJsZSA9IHJlcXVpcmUoJ2VzNS1leHQvb2JqZWN0L3ZhbGlkLWNhbGxhYmxlJylcblxuICAsIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LCBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGxcbiAgLCBjcmVhdGUgPSBPYmplY3QuY3JlYXRlLCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eVxuICAsIGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllc1xuICAsIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIGRlc2NyaXB0b3IgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH1cblxuICAsIG9uLCBvbmNlLCBvZmYsIGVtaXQsIG1ldGhvZHMsIGRlc2NyaXB0b3JzLCBiYXNlO1xuXG5vbiA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuXHR2YXIgZGF0YTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkge1xuXHRcdGRhdGEgPSBkZXNjcmlwdG9yLnZhbHVlID0gY3JlYXRlKG51bGwpO1xuXHRcdGRlZmluZVByb3BlcnR5KHRoaXMsICdfX2VlX18nLCBkZXNjcmlwdG9yKTtcblx0XHRkZXNjcmlwdG9yLnZhbHVlID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRkYXRhID0gdGhpcy5fX2VlX187XG5cdH1cblx0aWYgKCFkYXRhW3R5cGVdKSBkYXRhW3R5cGVdID0gbGlzdGVuZXI7XG5cdGVsc2UgaWYgKHR5cGVvZiBkYXRhW3R5cGVdID09PSAnb2JqZWN0JykgZGF0YVt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0ZWxzZSBkYXRhW3R5cGVdID0gW2RhdGFbdHlwZV0sIGxpc3RlbmVyXTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbm9uY2UgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcblx0dmFyIG9uY2UsIHNlbGY7XG5cblx0Y2FsbGFibGUobGlzdGVuZXIpO1xuXHRzZWxmID0gdGhpcztcblx0b24uY2FsbCh0aGlzLCB0eXBlLCBvbmNlID0gZnVuY3Rpb24gKCkge1xuXHRcdG9mZi5jYWxsKHNlbGYsIHR5cGUsIG9uY2UpO1xuXHRcdGFwcGx5LmNhbGwobGlzdGVuZXIsIHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0pO1xuXG5cdG9uY2UuX19lZU9uY2VMaXN0ZW5lcl9fID0gbGlzdGVuZXI7XG5cdHJldHVybiB0aGlzO1xufTtcblxub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG5cdHZhciBkYXRhLCBsaXN0ZW5lcnMsIGNhbmRpZGF0ZSwgaTtcblxuXHRjYWxsYWJsZShsaXN0ZW5lcik7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuIHRoaXM7XG5cdGRhdGEgPSB0aGlzLl9fZWVfXztcblx0aWYgKCFkYXRhW3R5cGVdKSByZXR1cm4gdGhpcztcblx0bGlzdGVuZXJzID0gZGF0YVt0eXBlXTtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRmb3IgKGkgPSAwOyAoY2FuZGlkYXRlID0gbGlzdGVuZXJzW2ldKTsgKytpKSB7XG5cdFx0XHRpZiAoKGNhbmRpZGF0ZSA9PT0gbGlzdGVuZXIpIHx8XG5cdFx0XHRcdFx0KGNhbmRpZGF0ZS5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMikgZGF0YVt0eXBlXSA9IGxpc3RlbmVyc1tpID8gMCA6IDFdO1xuXHRcdFx0XHRlbHNlIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGlmICgobGlzdGVuZXJzID09PSBsaXN0ZW5lcikgfHxcblx0XHRcdFx0KGxpc3RlbmVycy5fX2VlT25jZUxpc3RlbmVyX18gPT09IGxpc3RlbmVyKSkge1xuXHRcdFx0ZGVsZXRlIGRhdGFbdHlwZV07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0dmFyIGksIGwsIGxpc3RlbmVyLCBsaXN0ZW5lcnMsIGFyZ3M7XG5cblx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfX2VlX18nKSkgcmV0dXJuO1xuXHRsaXN0ZW5lcnMgPSB0aGlzLl9fZWVfX1t0eXBlXTtcblx0aWYgKCFsaXN0ZW5lcnMpIHJldHVybjtcblxuXHRpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ29iamVjdCcpIHtcblx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcblx0XHRmb3IgKGkgPSAxOyBpIDwgbDsgKytpKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuXHRcdGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgpO1xuXHRcdGZvciAoaSA9IDA7IChsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXSk7ICsraSkge1xuXHRcdFx0YXBwbHkuY2FsbChsaXN0ZW5lciwgdGhpcywgYXJncyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGNhc2UgMTpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0Y2FsbC5jYWxsKGxpc3RlbmVycywgdGhpcywgYXJndW1lbnRzWzFdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMzpcblx0XHRcdGNhbGwuY2FsbChsaXN0ZW5lcnMsIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuXHRcdFx0Zm9yIChpID0gMTsgaSA8IGw7ICsraSkge1xuXHRcdFx0XHRhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdH1cblx0XHRcdGFwcGx5LmNhbGwobGlzdGVuZXJzLCB0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH1cbn07XG5cbm1ldGhvZHMgPSB7XG5cdG9uOiBvbixcblx0b25jZTogb25jZSxcblx0b2ZmOiBvZmYsXG5cdGVtaXQ6IGVtaXRcbn07XG5cbmRlc2NyaXB0b3JzID0ge1xuXHRvbjogZChvbiksXG5cdG9uY2U6IGQob25jZSksXG5cdG9mZjogZChvZmYpLFxuXHRlbWl0OiBkKGVtaXQpXG59O1xuXG5iYXNlID0gZGVmaW5lUHJvcGVydGllcyh7fSwgZGVzY3JpcHRvcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiAobykge1xuXHRyZXR1cm4gKG8gPT0gbnVsbCkgPyBjcmVhdGUoYmFzZSkgOiBkZWZpbmVQcm9wZXJ0aWVzKE9iamVjdChvKSwgZGVzY3JpcHRvcnMpO1xufTtcbmV4cG9ydHMubWV0aG9kcyA9IG1ldGhvZHM7XG5cbn0se1wiZFwiOjE1LFwiZXM1LWV4dC9vYmplY3QvdmFsaWQtY2FsbGFibGVcIjo1NX1dLDgzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBvYmplY3RDcmVhdGVQb2x5ZmlsbFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGxcbnZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgZnVuY3Rpb25CaW5kUG9seWZpbGxcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsICdfZXZlbnRzJykpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxudmFyIGhhc0RlZmluZVByb3BlcnR5O1xudHJ5IHtcbiAgdmFyIG8gPSB7fTtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sICd4JywgeyB2YWx1ZTogMCB9KTtcbiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7XG59IGNhdGNoIChlcnIpIHsgaGFzRGVmaW5lUHJvcGVydHkgPSBmYWxzZSB9XG5pZiAoaGFzRGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3JcbiAgICAgIC8vIGdyZWF0ZXIgYW5kIG5vdCBhIE5hTikuXG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBhcmcgIT09IGFyZylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBkZWZhdWx0TWF4TGlzdGVuZXJzO1xufVxuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiblwiIGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuLy8gVGhlc2Ugc3RhbmRhbG9uZSBlbWl0KiBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gb3B0aW1pemUgY2FsbGluZyBvZiBldmVudFxuLy8gaGFuZGxlcnMgZm9yIGZhc3QgY2FzZXMgYmVjYXVzZSBlbWl0KCkgaXRzZWxmIG9mdGVuIGhhcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmVcbi8vIHRoZSBzYW1lIG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHRodXMgZG8gbm90IGdldCBkZW9wdGltaXplZCwgc28gdGhlIGNvZGVcbi8vIGluc2lkZSB0aGVtIGNhbiBleGVjdXRlIGZhc3Rlci5cbmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSkge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmdzKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuYXBwbHkoc2VsZiwgYXJncyk7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBldmVudHM7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cylcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09IG51bGwpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSlcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICBjYXNlIDE6XG4gICAgICBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIGVtaXRPbmUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pO1xuICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICBkZWZhdWx0OlxuICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKCFldmVudHMpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmICghZXhpc3RpbmcpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgaWYgKHByZXBlbmQpIHtcbiAgICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgXCInICsgU3RyaW5nKHR5cGUpICsgJ1wiIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7XG4gICAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBhcmd1bWVudHNbMl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKCFsaXN0KVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmICghZXZsaXN0ZW5lcilcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0Lm93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpLlxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSlcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvYmplY3RDcmVhdGVQb2x5ZmlsbChwcm90bykge1xuICB2YXIgRiA9IGZ1bmN0aW9uKCkge307XG4gIEYucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBuZXcgRjtcbn1cbmZ1bmN0aW9uIG9iamVjdEtleXNQb2x5ZmlsbChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkge1xuICAgIGtleXMucHVzaChrKTtcbiAgfVxuICByZXR1cm4gaztcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQmluZFBvbHlmaWxsKGNvbnRleHQpIHtcbiAgdmFyIGZuID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxufSx7fV0sODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIG5haXZlRmFsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmKSByZXR1cm4gc2VsZjtcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93KSByZXR1cm4gd2luZG93O1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBnbG9iYWwgYHRoaXNgXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcykgcmV0dXJuIHRoaXM7XG5cblx0Ly8gVW5leHBlY3RlZCBzdHJpY3QgbW9kZSAobWF5IGhhcHBlbiBpZiBlLmcuIGJ1bmRsZWQgaW50byBFU00gbW9kdWxlKVxuXG5cdC8vIFRoYW5rcyBAbWF0aGlhc2J5bmVucyAtPiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuXHQvLyBJbiBhbGwgRVM1KyBlbmdpbmVzIGdsb2JhbCBvYmplY3QgaW5oZXJpdHMgZnJvbSBPYmplY3QucHJvdG90eXBlXG5cdC8vIChpZiB5b3UgYXBwcm9hY2hlZCBvbmUgdGhhdCBkb2Vzbid0IHBsZWFzZSByZXBvcnQpXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsIFwiX19nbG9iYWxfX1wiLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHR9KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBVbmZvcnR1bmF0ZSBjYXNlIG9mIE9iamVjdC5wcm90b3R5cGUgYmVpbmcgc2VhbGVkICh2aWEgcHJldmVudEV4dGVuc2lvbnMsIHNlYWwgb3IgZnJlZXplKVxuXHRcdHJldHVybiBuYWl2ZUZhbGxiYWNrKCk7XG5cdH1cblx0dHJ5IHtcblx0XHQvLyBTYWZhcmkgY2FzZSAod2luZG93Ll9fZ2xvYmFsX18gaXMgcmVzb2x2ZWQgd2l0aCBnbG9iYWwgY29udGV4dCwgYnV0IF9fZ2xvYmFsX18gZG9lcyBub3QpXG5cdFx0aWYgKCFfX2dsb2JhbF9fKSByZXR1cm4gbmFpdmVGYWxsYmFjaygpO1xuXHRcdHJldHVybiBfX2dsb2JhbF9fO1xuXHR9IGZpbmFsbHkge1xuXHRcdGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fZ2xvYmFsX187XG5cdH1cbn0pKCk7XG5cbn0se31dLDg1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2lzLWltcGxlbWVudGVkXCIpKCkgPyBnbG9iYWxUaGlzIDogcmVxdWlyZShcIi4vaW1wbGVtZW50YXRpb25cIik7XG5cbn0se1wiLi9pbXBsZW1lbnRhdGlvblwiOjg0LFwiLi9pcy1pbXBsZW1lbnRlZFwiOjg2fV0sODY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcblx0aWYgKCFnbG9iYWxUaGlzKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBnbG9iYWxUaGlzLkFycmF5ID09PSBBcnJheTtcbn07XG5cbn0se31dLDg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxufSx7fV0sODg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDg5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG59LHt9XSw5MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8qIFByb3RvY29sIC0gcHJvdG9jb2wgY29uc3RhbnRzICovXG52YXIgcHJvdG9jb2wgPSBtb2R1bGUuZXhwb3J0c1xuXG4vKiBDb21tYW5kIGNvZGUgPT4gbW5lbW9uaWMgKi9cbnByb3RvY29sLnR5cGVzID0ge1xuICAwOiAncmVzZXJ2ZWQnLFxuICAxOiAnY29ubmVjdCcsXG4gIDI6ICdjb25uYWNrJyxcbiAgMzogJ3B1Ymxpc2gnLFxuICA0OiAncHViYWNrJyxcbiAgNTogJ3B1YnJlYycsXG4gIDY6ICdwdWJyZWwnLFxuICA3OiAncHViY29tcCcsXG4gIDg6ICdzdWJzY3JpYmUnLFxuICA5OiAnc3ViYWNrJyxcbiAgMTA6ICd1bnN1YnNjcmliZScsXG4gIDExOiAndW5zdWJhY2snLFxuICAxMjogJ3BpbmdyZXEnLFxuICAxMzogJ3BpbmdyZXNwJyxcbiAgMTQ6ICdkaXNjb25uZWN0JyxcbiAgMTU6ICdhdXRoJ1xufVxuXG4vKiBNbmVtb25pYyA9PiBDb21tYW5kIGNvZGUgKi9cbnByb3RvY29sLmNvZGVzID0ge31cbmZvciAodmFyIGsgaW4gcHJvdG9jb2wudHlwZXMpIHtcbiAgdmFyIHYgPSBwcm90b2NvbC50eXBlc1trXVxuICBwcm90b2NvbC5jb2Rlc1t2XSA9IGtcbn1cblxuLyogSGVhZGVyICovXG5wcm90b2NvbC5DTURfU0hJRlQgPSA0XG5wcm90b2NvbC5DTURfTUFTSyA9IDB4RjBcbnByb3RvY29sLkRVUF9NQVNLID0gMHgwOFxucHJvdG9jb2wuUU9TX01BU0sgPSAweDAzXG5wcm90b2NvbC5RT1NfU0hJRlQgPSAxXG5wcm90b2NvbC5SRVRBSU5fTUFTSyA9IDB4MDFcblxuLyogTGVuZ3RoICovXG5wcm90b2NvbC5MRU5HVEhfTUFTSyA9IDB4N0ZcbnByb3RvY29sLkxFTkdUSF9GSU5fTUFTSyA9IDB4ODBcblxuLyogQ29ubmFjayAqL1xucHJvdG9jb2wuU0VTU0lPTlBSRVNFTlRfTUFTSyA9IDB4MDFcbnByb3RvY29sLlNFU1NJT05QUkVTRU5UX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9NQVNLXSlcbnByb3RvY29sLkNPTk5BQ0tfSEVBREVSID0gQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydjb25uYWNrJ10gPDwgcHJvdG9jb2wuQ01EX1NISUZUXSlcblxuLyogQ29ubmVjdCAqL1xucHJvdG9jb2wuVVNFUk5BTUVfTUFTSyA9IDB4ODBcbnByb3RvY29sLlBBU1NXT1JEX01BU0sgPSAweDQwXG5wcm90b2NvbC5XSUxMX1JFVEFJTl9NQVNLID0gMHgyMFxucHJvdG9jb2wuV0lMTF9RT1NfTUFTSyA9IDB4MThcbnByb3RvY29sLldJTExfUU9TX1NISUZUID0gM1xucHJvdG9jb2wuV0lMTF9GTEFHX01BU0sgPSAweDA0XG5wcm90b2NvbC5DTEVBTl9TRVNTSU9OX01BU0sgPSAweDAyXG5wcm90b2NvbC5DT05ORUNUX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snY29ubmVjdCddIDw8IHByb3RvY29sLkNNRF9TSElGVF0pXG5cbi8qIFByb3BlcnRpZXMgKi9cbnByb3RvY29sLnByb3BlcnRpZXMgPSB7XG4gIHNlc3Npb25FeHBpcnlJbnRlcnZhbDogMTcsXG4gIHdpbGxEZWxheUludGVydmFsOiAyNCxcbiAgcmVjZWl2ZU1heGltdW06IDMzLFxuICBtYXhpbXVtUGFja2V0U2l6ZTogMzksXG4gIHRvcGljQWxpYXNNYXhpbXVtOiAzNCxcbiAgcmVxdWVzdFJlc3BvbnNlSW5mb3JtYXRpb246IDI1LFxuICByZXF1ZXN0UHJvYmxlbUluZm9ybWF0aW9uOiAyMyxcbiAgdXNlclByb3BlcnRpZXM6IDM4LFxuICBhdXRoZW50aWNhdGlvbk1ldGhvZDogMjEsXG4gIGF1dGhlbnRpY2F0aW9uRGF0YTogMjIsXG4gIHBheWxvYWRGb3JtYXRJbmRpY2F0b3I6IDEsXG4gIG1lc3NhZ2VFeHBpcnlJbnRlcnZhbDogMixcbiAgY29udGVudFR5cGU6IDMsXG4gIHJlc3BvbnNlVG9waWM6IDgsXG4gIGNvcnJlbGF0aW9uRGF0YTogOSxcbiAgbWF4aW11bVFvUzogMzYsXG4gIHJldGFpbkF2YWlsYWJsZTogMzcsXG4gIGFzc2lnbmVkQ2xpZW50SWRlbnRpZmllcjogMTgsXG4gIHJlYXNvblN0cmluZzogMzEsXG4gIHdpbGRjYXJkU3Vic2NyaXB0aW9uQXZhaWxhYmxlOiA0MCxcbiAgc3Vic2NyaXB0aW9uSWRlbnRpZmllcnNBdmFpbGFibGU6IDQxLFxuICBzaGFyZWRTdWJzY3JpcHRpb25BdmFpbGFibGU6IDQyLFxuICBzZXJ2ZXJLZWVwQWxpdmU6IDE5LFxuICByZXNwb25zZUluZm9ybWF0aW9uOiAyNixcbiAgc2VydmVyUmVmZXJlbmNlOiAyOCxcbiAgdG9waWNBbGlhczogMzUsXG4gIHN1YnNjcmlwdGlvbklkZW50aWZpZXI6IDExXG59XG5wcm90b2NvbC5wcm9wZXJ0aWVzQ29kZXMgPSB7fVxuZm9yICh2YXIgcHJvcCBpbiBwcm90b2NvbC5wcm9wZXJ0aWVzKSB7XG4gIHZhciBpZCA9IHByb3RvY29sLnByb3BlcnRpZXNbcHJvcF1cbiAgcHJvdG9jb2wucHJvcGVydGllc0NvZGVzW2lkXSA9IHByb3Bcbn1cbnByb3RvY29sLnByb3BlcnRpZXNUeXBlcyA9IHtcbiAgc2Vzc2lvbkV4cGlyeUludGVydmFsOiAnaW50MzInLFxuICB3aWxsRGVsYXlJbnRlcnZhbDogJ2ludDMyJyxcbiAgcmVjZWl2ZU1heGltdW06ICdpbnQxNicsXG4gIG1heGltdW1QYWNrZXRTaXplOiAnaW50MzInLFxuICB0b3BpY0FsaWFzTWF4aW11bTogJ2ludDE2JyxcbiAgcmVxdWVzdFJlc3BvbnNlSW5mb3JtYXRpb246ICdieXRlJyxcbiAgcmVxdWVzdFByb2JsZW1JbmZvcm1hdGlvbjogJ2J5dGUnLFxuICB1c2VyUHJvcGVydGllczogJ3BhaXInLFxuICBhdXRoZW50aWNhdGlvbk1ldGhvZDogJ3N0cmluZycsXG4gIGF1dGhlbnRpY2F0aW9uRGF0YTogJ2JpbmFyeScsXG4gIHBheWxvYWRGb3JtYXRJbmRpY2F0b3I6ICdieXRlJyxcbiAgbWVzc2FnZUV4cGlyeUludGVydmFsOiAnaW50MzInLFxuICBjb250ZW50VHlwZTogJ3N0cmluZycsXG4gIHJlc3BvbnNlVG9waWM6ICdzdHJpbmcnLFxuICBjb3JyZWxhdGlvbkRhdGE6ICdiaW5hcnknLFxuICBtYXhpbXVtUW9TOiAnaW50OCcsXG4gIHJldGFpbkF2YWlsYWJsZTogJ2J5dGUnLFxuICBhc3NpZ25lZENsaWVudElkZW50aWZpZXI6ICdzdHJpbmcnLFxuICByZWFzb25TdHJpbmc6ICdzdHJpbmcnLFxuICB3aWxkY2FyZFN1YnNjcmlwdGlvbkF2YWlsYWJsZTogJ2J5dGUnLFxuICBzdWJzY3JpcHRpb25JZGVudGlmaWVyc0F2YWlsYWJsZTogJ2J5dGUnLFxuICBzaGFyZWRTdWJzY3JpcHRpb25BdmFpbGFibGU6ICdieXRlJyxcbiAgc2VydmVyS2VlcEFsaXZlOiAnaW50MzInLFxuICByZXNwb25zZUluZm9ybWF0aW9uOiAnc3RyaW5nJyxcbiAgc2VydmVyUmVmZXJlbmNlOiAnc3RyaW5nJyxcbiAgdG9waWNBbGlhczogJ2ludDE2JyxcbiAgc3Vic2NyaXB0aW9uSWRlbnRpZmllcjogJ3Zhcidcbn1cblxuZnVuY3Rpb24gZ2VuSGVhZGVyICh0eXBlKSB7XG4gIHJldHVybiBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChxb3MpIHtcbiAgICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAoZHVwKSB7XG4gICAgICByZXR1cm4gWzAsIDFdLm1hcChmdW5jdGlvbiAocmV0YWluKSB7XG4gICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKDEpXG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KFxuICAgICAgICAgIHByb3RvY29sLmNvZGVzW3R5cGVdIDw8IHByb3RvY29sLkNNRF9TSElGVCB8XG4gICAgICAgICAgKGR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMCkgfFxuICAgICAgICAgIHFvcyA8PCBwcm90b2NvbC5RT1NfU0hJRlQgfCByZXRhaW4sIDAsIHRydWUpXG4gICAgICAgIHJldHVybiBidWZcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLyogUHVibGlzaCAqL1xucHJvdG9jb2wuUFVCTElTSF9IRUFERVIgPSBnZW5IZWFkZXIoJ3B1Ymxpc2gnKVxuXG4vKiBTdWJzY3JpYmUgKi9cbnByb3RvY29sLlNVQlNDUklCRV9IRUFERVIgPSBnZW5IZWFkZXIoJ3N1YnNjcmliZScpXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19RT1NfTUFTSyA9IDB4MDNcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX05MX01BU0sgPSAweDAxXG5wcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19OTF9TSElGVCA9IDJcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JBUF9NQVNLID0gMHgwMVxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkFQX1NISUZUID0gM1xucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkhfTUFTSyA9IDB4MDNcbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1JIX1NISUZUID0gNFxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkggPSBbMHgwMCwgMHgxMCwgMHgyMF1cbnByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX05MID0gMHgwNFxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUkFQID0gMHgwOFxucHJvdG9jb2wuU1VCU0NSSUJFX09QVElPTlNfUU9TID0gWzB4MDAsIDB4MDEsIDB4MDJdXG5cbi8qIFVuc3Vic2NyaWJlICovXG5wcm90b2NvbC5VTlNVQlNDUklCRV9IRUFERVIgPSBnZW5IZWFkZXIoJ3Vuc3Vic2NyaWJlJylcblxuLyogQ29uZmlybWF0aW9ucyAqL1xucHJvdG9jb2wuQUNLUyA9IHtcbiAgdW5zdWJhY2s6IGdlbkhlYWRlcigndW5zdWJhY2snKSxcbiAgcHViYWNrOiBnZW5IZWFkZXIoJ3B1YmFjaycpLFxuICBwdWJjb21wOiBnZW5IZWFkZXIoJ3B1YmNvbXAnKSxcbiAgcHVicmVsOiBnZW5IZWFkZXIoJ3B1YnJlbCcpLFxuICBwdWJyZWM6IGdlbkhlYWRlcigncHVicmVjJylcbn1cblxucHJvdG9jb2wuU1VCQUNLX0hFQURFUiA9IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snc3ViYWNrJ10gPDwgcHJvdG9jb2wuQ01EX1NISUZUXSlcblxuLyogUHJvdG9jb2wgdmVyc2lvbnMgKi9cbnByb3RvY29sLlZFUlNJT04zID0gQnVmZmVyLmZyb20oWzNdKVxucHJvdG9jb2wuVkVSU0lPTjQgPSBCdWZmZXIuZnJvbShbNF0pXG5wcm90b2NvbC5WRVJTSU9ONSA9IEJ1ZmZlci5mcm9tKFs1XSlcblxuLyogUW9TICovXG5wcm90b2NvbC5RT1MgPSBbMCwgMSwgMl0ubWFwKGZ1bmN0aW9uIChxb3MpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtxb3NdKVxufSlcblxuLyogRW1wdHkgcGFja2V0cyAqL1xucHJvdG9jb2wuRU1QVFkgPSB7XG4gIHBpbmdyZXE6IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1sncGluZ3JlcSddIDw8IDQsIDBdKSxcbiAgcGluZ3Jlc3A6IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1sncGluZ3Jlc3AnXSA8PCA0LCAwXSksXG4gIGRpc2Nvbm5lY3Q6IEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5jb2Rlc1snZGlzY29ubmVjdCddIDw8IDQsIDBdKVxufVxuXG59LHtcInNhZmUtYnVmZmVyXCI6MTE4fV0sOTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIHdyaXRlVG9TdHJlYW0gPSByZXF1aXJlKCcuL3dyaXRlVG9TdHJlYW0nKVxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChwYWNrZXQsIG9wdHMpIHtcbiAgdmFyIHN0cmVhbSA9IG5ldyBBY2N1bXVsYXRvcigpXG4gIHdyaXRlVG9TdHJlYW0ocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gIHJldHVybiBzdHJlYW0uY29uY2F0KClcbn1cblxuZnVuY3Rpb24gQWNjdW11bGF0b3IgKCkge1xuICB0aGlzLl9hcnJheSA9IG5ldyBBcnJheSgyMClcbiAgdGhpcy5faSA9IDBcbn1cblxuaW5oZXJpdHMoQWNjdW11bGF0b3IsIEVFKVxuXG5BY2N1bXVsYXRvci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5fYXJyYXlbdGhpcy5faSsrXSA9IGNodW5rXG4gIHJldHVybiB0cnVlXG59XG5cbkFjY3VtdWxhdG9yLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsZW5ndGggPSAwXG4gIHZhciBsZW5ndGhzID0gbmV3IEFycmF5KHRoaXMuX2FycmF5Lmxlbmd0aClcbiAgdmFyIGxpc3QgPSB0aGlzLl9hcnJheVxuICB2YXIgcG9zID0gMFxuICB2YXIgaVxuICB2YXIgcmVzdWx0XG5cbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoICYmIGxpc3RbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0W2ldICE9PSAnc3RyaW5nJykgbGVuZ3Roc1tpXSA9IGxpc3RbaV0ubGVuZ3RoXG4gICAgZWxzZSBsZW5ndGhzW2ldID0gQnVmZmVyLmJ5dGVMZW5ndGgobGlzdFtpXSlcblxuICAgIGxlbmd0aCArPSBsZW5ndGhzW2ldXG4gIH1cblxuICByZXN1bHQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aCAmJiBsaXN0W2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgIGlmICh0eXBlb2YgbGlzdFtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxpc3RbaV0uY29weShyZXN1bHQsIHBvcylcbiAgICAgIHBvcyArPSBsZW5ndGhzW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC53cml0ZShsaXN0W2ldLCBwb3MpXG4gICAgICBwb3MgKz0gbGVuZ3Roc1tpXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVxuXG59LHtcIi4vd3JpdGVUb1N0cmVhbVwiOjk3LFwiZXZlbnRzXCI6ODMsXCJpbmhlcml0c1wiOjg4LFwic2FmZS1idWZmZXJcIjoxMTh9XSw5MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpXG5leHBvcnRzLmdlbmVyYXRlID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpXG5leHBvcnRzLndyaXRlVG9TdHJlYW0gPSByZXF1aXJlKCcuL3dyaXRlVG9TdHJlYW0nKVxuXG59LHtcIi4vZ2VuZXJhdGVcIjo5MSxcIi4vcGFyc2VyXCI6OTYsXCIuL3dyaXRlVG9TdHJlYW1cIjo5N31dLDkzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBEdXBsZXhTdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4JylcbiAgLCB1dGlsICAgICAgICAgPSByZXF1aXJlKCd1dGlsJylcbiAgLCBCdWZmZXIgICAgICAgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QgKGNhbGxiYWNrKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXJMaXN0KSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckxpc3QoY2FsbGJhY2spXG5cbiAgdGhpcy5fYnVmcyAgPSBbXVxuICB0aGlzLmxlbmd0aCA9IDBcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrXG5cbiAgICB2YXIgcGlwZXIgPSBmdW5jdGlvbiBwaXBlciAoZXJyKSB7XG4gICAgICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2soZXJyKVxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcylcblxuICAgIHRoaXMub24oJ3BpcGUnLCBmdW5jdGlvbiBvblBpcGUgKHNyYykge1xuICAgICAgc3JjLm9uKCdlcnJvcicsIHBpcGVyKVxuICAgIH0pXG4gICAgdGhpcy5vbigndW5waXBlJywgZnVuY3Rpb24gb25VbnBpcGUgKHNyYykge1xuICAgICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHBpcGVyKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hcHBlbmQoY2FsbGJhY2spXG4gIH1cblxuICBEdXBsZXhTdHJlYW0uY2FsbCh0aGlzKVxufVxuXG5cbnV0aWwuaW5oZXJpdHMoQnVmZmVyTGlzdCwgRHVwbGV4U3RyZWFtKVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9vZmZzZXQgPSBmdW5jdGlvbiBfb2Zmc2V0IChvZmZzZXQpIHtcbiAgdmFyIHRvdCA9IDAsIGkgPSAwLCBfdFxuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gWyAwLCAwIF1cbiAgZm9yICg7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgX3QgPSB0b3QgKyB0aGlzLl9idWZzW2ldLmxlbmd0aFxuICAgIGlmIChvZmZzZXQgPCBfdCB8fCBpID09IHRoaXMuX2J1ZnMubGVuZ3RoIC0gMSlcbiAgICAgIHJldHVybiBbIGksIG9mZnNldCAtIHRvdCBdXG4gICAgdG90ID0gX3RcbiAgfVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAoYnVmKSB7XG4gIHZhciBpID0gMFxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgIHRoaXMuX2FwcGVuZEJ1ZmZlcihidWYpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYnVmKSkge1xuICAgIGZvciAoOyBpIDwgYnVmLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5hcHBlbmQoYnVmW2ldKVxuICB9IGVsc2UgaWYgKGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpIHtcbiAgICAvLyB1bndyYXAgYXJndW1lbnQgaW50byBpbmRpdmlkdWFsIEJ1ZmZlckxpc3RzXG4gICAgZm9yICg7IGkgPCBidWYuX2J1ZnMubGVuZ3RoOyBpKyspXG4gICAgICB0aGlzLmFwcGVuZChidWYuX2J1ZnNbaV0pXG4gIH0gZWxzZSBpZiAoYnVmICE9IG51bGwpIHtcbiAgICAvLyBjb2VyY2UgbnVtYmVyIGFyZ3VtZW50cyB0byBzdHJpbmdzLCBzaW5jZSBCdWZmZXIobnVtYmVyKSBkb2VzXG4gICAgLy8gdW5pbml0aWFsaXplZCBtZW1vcnkgYWxsb2NhdGlvblxuICAgIGlmICh0eXBlb2YgYnVmID09ICdudW1iZXInKVxuICAgICAgYnVmID0gYnVmLnRvU3RyaW5nKClcblxuICAgIHRoaXMuX2FwcGVuZEJ1ZmZlcihCdWZmZXIuZnJvbShidWYpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX2FwcGVuZEJ1ZmZlciA9IGZ1bmN0aW9uIGFwcGVuZEJ1ZmZlciAoYnVmKSB7XG4gIHRoaXMuX2J1ZnMucHVzaChidWYpXG4gIHRoaXMubGVuZ3RoICs9IGJ1Zi5sZW5ndGhcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGJ1ZiwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX2FwcGVuZEJ1ZmZlcihidWYpXG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKVxuICAgIGNhbGxiYWNrKClcbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIF9yZWFkIChzaXplKSB7XG4gIGlmICghdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMucHVzaChudWxsKVxuXG4gIHNpemUgPSBNYXRoLm1pbihzaXplLCB0aGlzLmxlbmd0aClcbiAgdGhpcy5wdXNoKHRoaXMuc2xpY2UoMCwgc2l6ZSkpXG4gIHRoaXMuY29uc3VtZShzaXplKVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZCAoY2h1bmspIHtcbiAgRHVwbGV4U3RyZWFtLnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzLCBjaHVuaylcblxuICBpZiAodGhpcy5fY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jYWxsYmFjayhudWxsLCB0aGlzLnNsaWNlKCkpXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG4gIH1cbn1cblxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4KSB7XG4gIHJldHVybiB0aGlzLnNsaWNlKGluZGV4LCBpbmRleCArIDEpWzBdXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBpZiAodHlwZW9mIHN0YXJ0ID09ICdudW1iZXInICYmIHN0YXJ0IDwgMClcbiAgICBzdGFydCArPSB0aGlzLmxlbmd0aFxuICBpZiAodHlwZW9mIGVuZCA9PSAnbnVtYmVyJyAmJiBlbmQgPCAwKVxuICAgIGVuZCArPSB0aGlzLmxlbmd0aFxuICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIDAsIHN0YXJ0LCBlbmQpXG59XG5cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRzdCwgZHN0U3RhcnQsIHNyY1N0YXJ0LCBzcmNFbmQpIHtcbiAgaWYgKHR5cGVvZiBzcmNTdGFydCAhPSAnbnVtYmVyJyB8fCBzcmNTdGFydCA8IDApXG4gICAgc3JjU3RhcnQgPSAwXG4gIGlmICh0eXBlb2Ygc3JjRW5kICE9ICdudW1iZXInIHx8IHNyY0VuZCA+IHRoaXMubGVuZ3RoKVxuICAgIHNyY0VuZCA9IHRoaXMubGVuZ3RoXG4gIGlmIChzcmNTdGFydCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm4gZHN0IHx8IEJ1ZmZlci5hbGxvYygwKVxuICBpZiAoc3JjRW5kIDw9IDApXG4gICAgcmV0dXJuIGRzdCB8fCBCdWZmZXIuYWxsb2MoMClcblxuICB2YXIgY29weSAgID0gISFkc3RcbiAgICAsIG9mZiAgICA9IHRoaXMuX29mZnNldChzcmNTdGFydClcbiAgICAsIGxlbiAgICA9IHNyY0VuZCAtIHNyY1N0YXJ0XG4gICAgLCBieXRlcyAgPSBsZW5cbiAgICAsIGJ1Zm9mZiA9IChjb3B5ICYmIGRzdFN0YXJ0KSB8fCAwXG4gICAgLCBzdGFydCAgPSBvZmZbMV1cbiAgICAsIGxcbiAgICAsIGlcblxuICAvLyBjb3B5L3NsaWNlIGV2ZXJ5dGhpbmdcbiAgaWYgKHNyY1N0YXJ0ID09PSAwICYmIHNyY0VuZCA9PSB0aGlzLmxlbmd0aCkge1xuICAgIGlmICghY29weSkgeyAvLyBzbGljZSwgYnV0IGZ1bGwgY29uY2F0IGlmIG11bHRpcGxlIGJ1ZmZlcnNcbiAgICAgIHJldHVybiB0aGlzLl9idWZzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHRoaXMuX2J1ZnNbMF1cbiAgICAgICAgOiBCdWZmZXIuY29uY2F0KHRoaXMuX2J1ZnMsIHRoaXMubGVuZ3RoKVxuICAgIH1cblxuICAgIC8vIGNvcHksIG5lZWQgdG8gY29weSBpbmRpdmlkdWFsIGJ1ZmZlcnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmKVxuICAgICAgYnVmb2ZmICs9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIGRzdFxuICB9XG5cbiAgLy8gZWFzeSwgY2hlYXAgY2FzZSB3aGVyZSBpdCdzIGEgc3Vic2V0IG9mIG9uZSBvZiB0aGUgYnVmZmVyc1xuICBpZiAoYnl0ZXMgPD0gdGhpcy5fYnVmc1tvZmZbMF1dLmxlbmd0aCAtIHN0YXJ0KSB7XG4gICAgcmV0dXJuIGNvcHlcbiAgICAgID8gdGhpcy5fYnVmc1tvZmZbMF1dLmNvcHkoZHN0LCBkc3RTdGFydCwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICA6IHRoaXMuX2J1ZnNbb2ZmWzBdXS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgfVxuXG4gIGlmICghY29weSkgLy8gYSBzbGljZSwgd2UgbmVlZCBzb21ldGhpbmcgdG8gY29weSBpbiB0b1xuICAgIGRzdCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW4pXG5cbiAgZm9yIChpID0gb2ZmWzBdOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGwgPSB0aGlzLl9idWZzW2ldLmxlbmd0aCAtIHN0YXJ0XG5cbiAgICBpZiAoYnl0ZXMgPiBsKSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZzW2ldLmNvcHkoZHN0LCBidWZvZmYsIHN0YXJ0LCBzdGFydCArIGJ5dGVzKVxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBidWZvZmYgKz0gbFxuICAgIGJ5dGVzIC09IGxcblxuICAgIGlmIChzdGFydClcbiAgICAgIHN0YXJ0ID0gMFxuICB9XG5cbiAgcmV0dXJuIGRzdFxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGFsbG93U2xpY2UgPSBmdW5jdGlvbiBzaGFsbG93U2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IGVuZCB8fCB0aGlzLmxlbmd0aFxuXG4gIGlmIChzdGFydCA8IDApXG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8IDApXG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KHN0YXJ0KVxuICAgICwgZW5kT2Zmc2V0ID0gdGhpcy5fb2Zmc2V0KGVuZClcbiAgICAsIGJ1ZmZlcnMgPSB0aGlzLl9idWZzLnNsaWNlKHN0YXJ0T2Zmc2V0WzBdLCBlbmRPZmZzZXRbMF0gKyAxKVxuXG4gIGlmIChlbmRPZmZzZXRbMV0gPT0gMClcbiAgICBidWZmZXJzLnBvcCgpXG4gIGVsc2VcbiAgICBidWZmZXJzW2J1ZmZlcnMubGVuZ3RoLTFdID0gYnVmZmVyc1tidWZmZXJzLmxlbmd0aC0xXS5zbGljZSgwLCBlbmRPZmZzZXRbMV0pXG5cbiAgaWYgKHN0YXJ0T2Zmc2V0WzFdICE9IDApXG4gICAgYnVmZmVyc1swXSA9IGJ1ZmZlcnNbMF0uc2xpY2Uoc3RhcnRPZmZzZXRbMV0pXG5cbiAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0KGJ1ZmZlcnMpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gY29uc3VtZSAoYnl0ZXMpIHtcbiAgd2hpbGUgKHRoaXMuX2J1ZnMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzID49IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoKSB7XG4gICAgICBieXRlcyAtPSB0aGlzLl9idWZzWzBdLmxlbmd0aFxuICAgICAgdGhpcy5sZW5ndGggLT0gdGhpcy5fYnVmc1swXS5sZW5ndGhcbiAgICAgIHRoaXMuX2J1ZnMuc2hpZnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9idWZzWzBdID0gdGhpcy5fYnVmc1swXS5zbGljZShieXRlcylcbiAgICAgIHRoaXMubGVuZ3RoIC09IGJ5dGVzXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmR1cGxpY2F0ZSA9IGZ1bmN0aW9uIGR1cGxpY2F0ZSAoKSB7XG4gIHZhciBpID0gMFxuICAgICwgY29weSA9IG5ldyBCdWZmZXJMaXN0KClcblxuICBmb3IgKDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspXG4gICAgY29weS5hcHBlbmQodGhpcy5fYnVmc1tpXSlcblxuICByZXR1cm4gY29weVxufVxuXG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdGhpcy5fYnVmcy5sZW5ndGggPSAwXG4gIHRoaXMubGVuZ3RoID0gMFxuICB0aGlzLnB1c2gobnVsbClcbn1cblxuXG47KGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgICAncmVhZERvdWJsZUJFJyA6IDhcbiAgICAsICdyZWFkRG91YmxlTEUnIDogOFxuICAgICwgJ3JlYWRGbG9hdEJFJyAgOiA0XG4gICAgLCAncmVhZEZsb2F0TEUnICA6IDRcbiAgICAsICdyZWFkSW50MzJCRScgIDogNFxuICAgICwgJ3JlYWRJbnQzMkxFJyAgOiA0XG4gICAgLCAncmVhZFVJbnQzMkJFJyA6IDRcbiAgICAsICdyZWFkVUludDMyTEUnIDogNFxuICAgICwgJ3JlYWRJbnQxNkJFJyAgOiAyXG4gICAgLCAncmVhZEludDE2TEUnICA6IDJcbiAgICAsICdyZWFkVUludDE2QkUnIDogMlxuICAgICwgJ3JlYWRVSW50MTZMRScgOiAyXG4gICAgLCAncmVhZEludDgnICAgICA6IDFcbiAgICAsICdyZWFkVUludDgnICAgIDogMVxuICB9XG5cbiAgZm9yICh2YXIgbSBpbiBtZXRob2RzKSB7XG4gICAgKGZ1bmN0aW9uIChtKSB7XG4gICAgICBCdWZmZXJMaXN0LnByb3RvdHlwZVttXSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBtZXRob2RzW21dKVttXSgwKVxuICAgICAgfVxuICAgIH0obSkpXG4gIH1cbn0oKSlcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3RcblxufSx7XCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4XCI6MTA1LFwic2FmZS1idWZmZXJcIjoxMTgsXCJ1dGlsXCI6MTM2fV0sOTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIG1heCA9IDY1NTM2XG52YXIgY2FjaGUgPSB7fVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUJ1ZmZlciAoaSkge1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gIGJ1ZmZlci53cml0ZVVJbnQ4KGkgPj4gOCwgMClcbiAgYnVmZmVyLndyaXRlVUludDgoaSAmIDB4MDBGRiwgMCArIDEpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNhY2hlICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGNhY2hlW2ldID0gZ2VuZXJhdGVCdWZmZXIoaSlcbiAgfVxufVxuXG4vKipcbiAqIGNhbGNWYXJpYWJsZUJ5dGVJbnRMZW5ndGggLSBjYWxjdWxhdGUgdGhlIHZhcmlhYmxlIGJ5dGUgaW50ZWdlclxuICogbGVuZ3RoIGZpZWxkXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGNWYXJpYWJsZUJ5dGVJbnRMZW5ndGggKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID49IDAgJiYgbGVuZ3RoIDwgMTI4KSByZXR1cm4gMVxuICBlbHNlIGlmIChsZW5ndGggPj0gMTI4ICYmIGxlbmd0aCA8IDE2Mzg0KSByZXR1cm4gMlxuICBlbHNlIGlmIChsZW5ndGggPj0gMTYzODQgJiYgbGVuZ3RoIDwgMjA5NzE1MikgcmV0dXJuIDNcbiAgZWxzZSBpZiAobGVuZ3RoID49IDIwOTcxNTIgJiYgbGVuZ3RoIDwgMjY4NDM1NDU2KSByZXR1cm4gNFxuICBlbHNlIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGdlbkJ1ZlZhcmlhYmxlQnl0ZUludCAobnVtKSB7XG4gIHZhciBkaWdpdCA9IDBcbiAgdmFyIHBvcyA9IDBcbiAgdmFyIGxlbmd0aCA9IGNhbGNWYXJpYWJsZUJ5dGVJbnRMZW5ndGgobnVtKVxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcblxuICBkbyB7XG4gICAgZGlnaXQgPSBudW0gJSAxMjggfCAwXG4gICAgbnVtID0gbnVtIC8gMTI4IHwgMFxuICAgIGlmIChudW0gPiAwKSBkaWdpdCA9IGRpZ2l0IHwgMHg4MFxuXG4gICAgYnVmZmVyLndyaXRlVUludDgoZGlnaXQsIHBvcysrKVxuICB9IHdoaWxlIChudW0gPiAwKVxuXG4gIHJldHVybiB7XG4gICAgZGF0YTogYnVmZmVyLFxuICAgIGxlbmd0aDogbGVuZ3RoXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGU0Qnl0ZUJ1ZmZlciAobnVtKSB7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobnVtLCAwKVxuICByZXR1cm4gYnVmZmVyXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWNoZTogY2FjaGUsXG4gIGdlbmVyYXRlQ2FjaGU6IGdlbmVyYXRlQ2FjaGUsXG4gIGdlbmVyYXRlTnVtYmVyOiBnZW5lcmF0ZUJ1ZmZlcixcbiAgZ2VuQnVmVmFyaWFibGVCeXRlSW50OiBnZW5CdWZWYXJpYWJsZUJ5dGVJbnQsXG4gIGdlbmVyYXRlNEJ5dGVCdWZmZXI6IGdlbmVyYXRlNEJ5dGVCdWZmZXJcbn1cblxufSx7XCJzYWZlLWJ1ZmZlclwiOjExOH1dLDk1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuZnVuY3Rpb24gUGFja2V0ICgpIHtcbiAgdGhpcy5jbWQgPSBudWxsXG4gIHRoaXMucmV0YWluID0gZmFsc2VcbiAgdGhpcy5xb3MgPSAwXG4gIHRoaXMuZHVwID0gZmFsc2VcbiAgdGhpcy5sZW5ndGggPSAtMVxuICB0aGlzLnRvcGljID0gbnVsbFxuICB0aGlzLnBheWxvYWQgPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFja2V0XG5cbn0se31dLDk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0J1xuXG52YXIgYmwgPSByZXF1aXJlKCdibCcpXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbnZhciBQYWNrZXQgPSByZXF1aXJlKCcuL3BhY2tldCcpXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG5mdW5jdGlvbiBQYXJzZXIgKG9wdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFyc2VyKSkgcmV0dXJuIG5ldyBQYXJzZXIob3B0KVxuXG4gIHRoaXMuc2V0dGluZ3MgPSBvcHQgfHwge31cblxuICB0aGlzLl9zdGF0ZXMgPSBbXG4gICAgJ19wYXJzZUhlYWRlcicsXG4gICAgJ19wYXJzZUxlbmd0aCcsXG4gICAgJ19wYXJzZVBheWxvYWQnLFxuICAgICdfbmV3UGFja2V0J1xuICBdXG5cbiAgdGhpcy5fcmVzZXRTdGF0ZSgpXG59XG5cbmluaGVyaXRzKFBhcnNlciwgRUUpXG5cblBhcnNlci5wcm90b3R5cGUuX3Jlc2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucGFja2V0ID0gbmV3IFBhY2tldCgpXG4gIHRoaXMuZXJyb3IgPSBudWxsXG4gIHRoaXMuX2xpc3QgPSBibCgpXG4gIHRoaXMuX3N0YXRlQ291bnRlciA9IDBcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMuZXJyb3IpIHRoaXMuX3Jlc2V0U3RhdGUoKVxuXG4gIHRoaXMuX2xpc3QuYXBwZW5kKGJ1ZilcblxuICB3aGlsZSAoKHRoaXMucGFja2V0Lmxlbmd0aCAhPT0gLTEgfHwgdGhpcy5fbGlzdC5sZW5ndGggPiAwKSAmJlxuICB0aGlzW3RoaXMuX3N0YXRlc1t0aGlzLl9zdGF0ZUNvdW50ZXJdXSgpICYmXG4gICF0aGlzLmVycm9yKSB7XG4gICAgdGhpcy5fc3RhdGVDb3VudGVyKytcblxuICAgIGlmICh0aGlzLl9zdGF0ZUNvdW50ZXIgPj0gdGhpcy5fc3RhdGVzLmxlbmd0aCkgdGhpcy5fc3RhdGVDb3VudGVyID0gMFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2xpc3QubGVuZ3RoXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgYnl0ZSBpbiB0aGUgYnVmZmVyXG4gIHZhciB6ZXJvID0gdGhpcy5fbGlzdC5yZWFkVUludDgoMClcbiAgdGhpcy5wYWNrZXQuY21kID0gY29uc3RhbnRzLnR5cGVzW3plcm8gPj4gY29uc3RhbnRzLkNNRF9TSElGVF1cbiAgdGhpcy5wYWNrZXQucmV0YWluID0gKHplcm8gJiBjb25zdGFudHMuUkVUQUlOX01BU0spICE9PSAwXG4gIHRoaXMucGFja2V0LnFvcyA9ICh6ZXJvID4+IGNvbnN0YW50cy5RT1NfU0hJRlQpICYgY29uc3RhbnRzLlFPU19NQVNLXG4gIHRoaXMucGFja2V0LmR1cCA9ICh6ZXJvICYgY29uc3RhbnRzLkRVUF9NQVNLKSAhPT0gMFxuXG4gIHRoaXMuX2xpc3QuY29uc3VtZSgxKVxuXG4gIHJldHVybiB0cnVlXG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgYnl0ZSBpbiB0aGUgbGlzdFxuICB2YXIgcmVzdWx0ID0gdGhpcy5fcGFyc2VWYXJCeXRlTnVtKHRydWUpXG5cbiAgaWYgKHJlc3VsdCkge1xuICAgIHRoaXMucGFja2V0Lmxlbmd0aCA9IHJlc3VsdC52YWx1ZVxuICAgIHRoaXMuX2xpc3QuY29uc3VtZShyZXN1bHQuYnl0ZXMpXG4gIH1cblxuICByZXR1cm4gISFyZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmVzdWx0ID0gZmFsc2VcblxuICAvLyBEbyB3ZSBoYXZlIGEgcGF5bG9hZD8gRG8gd2UgaGF2ZSBlbm91Z2ggZGF0YSB0byBjb21wbGV0ZSB0aGUgcGF5bG9hZD9cbiAgLy8gUElOR3MgaGF2ZSBubyBwYXlsb2FkXG4gIGlmICh0aGlzLnBhY2tldC5sZW5ndGggPT09IDAgfHwgdGhpcy5fbGlzdC5sZW5ndGggPj0gdGhpcy5wYWNrZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5fcG9zID0gMFxuXG4gICAgc3dpdGNoICh0aGlzLnBhY2tldC5jbWQpIHtcbiAgICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgICB0aGlzLl9wYXJzZUNvbm5lY3QoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnY29ubmFjayc6XG4gICAgICAgIHRoaXMuX3BhcnNlQ29ubmFjaygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwdWJsaXNoJzpcbiAgICAgICAgdGhpcy5fcGFyc2VQdWJsaXNoKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgICBjYXNlICdwdWJyZWMnOlxuICAgICAgY2FzZSAncHVicmVsJzpcbiAgICAgIGNhc2UgJ3B1YmNvbXAnOlxuICAgICAgICB0aGlzLl9wYXJzZUNvbmZpcm1hdGlvbigpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdWJzY3JpYmUnOlxuICAgICAgICB0aGlzLl9wYXJzZVN1YnNjcmliZSgpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdWJhY2snOlxuICAgICAgICB0aGlzLl9wYXJzZVN1YmFjaygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnN1YnNjcmliZSc6XG4gICAgICAgIHRoaXMuX3BhcnNlVW5zdWJzY3JpYmUoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgICB0aGlzLl9wYXJzZVVuc3ViYWNrKClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3BpbmdyZXEnOlxuICAgICAgY2FzZSAncGluZ3Jlc3AnOlxuICAgICAgICAvLyBUaGVzZSBhcmUgZW1wdHksIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3QnOlxuICAgICAgICB0aGlzLl9wYXJzZURpc2Nvbm5lY3QoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnYXV0aCc6XG4gICAgICAgIHRoaXMuX3BhcnNlQXV0aCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkJykpXG4gICAgfVxuXG4gICAgcmVzdWx0ID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcm90b2NvbElkIC8vIFByb3RvY29sIElEXG4gIHZhciBjbGllbnRJZCAvLyBDbGllbnQgSURcbiAgdmFyIHRvcGljIC8vIFdpbGwgdG9waWNcbiAgdmFyIHBheWxvYWQgLy8gV2lsbCBwYXlsb2FkXG4gIHZhciBwYXNzd29yZCAvLyBQYXNzd29yZFxuICB2YXIgdXNlcm5hbWUgLy8gVXNlcm5hbWVcbiAgdmFyIGZsYWdzID0ge31cbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG5cbiAgLy8gUGFyc2UgcHJvdG9jb2xJZFxuICBwcm90b2NvbElkID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuXG4gIGlmIChwcm90b2NvbElkID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHByb3RvY29sSWQnKSlcbiAgaWYgKHByb3RvY29sSWQgIT09ICdNUVRUJyAmJiBwcm90b2NvbElkICE9PSAnTVFJc2RwJykge1xuICAgIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sSWQnKSlcbiAgfVxuXG4gIHBhY2tldC5wcm90b2NvbElkID0gcHJvdG9jb2xJZFxuXG4gIC8vIFBhcnNlIGNvbnN0YW50cyB2ZXJzaW9uIG51bWJlclxuICBpZiAodGhpcy5fcG9zID49IHRoaXMuX2xpc3QubGVuZ3RoKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignUGFja2V0IHRvbyBzaG9ydCcpKVxuXG4gIHBhY2tldC5wcm90b2NvbFZlcnNpb24gPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpXG5cbiAgaWYgKHBhY2tldC5wcm90b2NvbFZlcnNpb24gIT09IDMgJiYgcGFja2V0LnByb3RvY29sVmVyc2lvbiAhPT0gNCAmJiBwYWNrZXQucHJvdG9jb2xWZXJzaW9uICE9PSA1KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2wgdmVyc2lvbicpKVxuICB9XG5cbiAgdGhpcy5fcG9zKytcblxuICBpZiAodGhpcy5fcG9zID49IHRoaXMuX2xpc3QubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcbiAgfVxuXG4gIC8vIFBhcnNlIGNvbm5lY3QgZmxhZ3NcbiAgZmxhZ3MudXNlcm5hbWUgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5VU0VSTkFNRV9NQVNLKVxuICBmbGFncy5wYXNzd29yZCA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICYgY29uc3RhbnRzLlBBU1NXT1JEX01BU0spXG4gIGZsYWdzLndpbGwgPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5XSUxMX0ZMQUdfTUFTSylcblxuICBpZiAoZmxhZ3Mud2lsbCkge1xuICAgIHBhY2tldC53aWxsID0ge31cbiAgICBwYWNrZXQud2lsbC5yZXRhaW4gPSAodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKSAmIGNvbnN0YW50cy5XSUxMX1JFVEFJTl9NQVNLKSAhPT0gMFxuICAgIHBhY2tldC53aWxsLnFvcyA9ICh0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpICZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLldJTExfUU9TX01BU0spID4+IGNvbnN0YW50cy5XSUxMX1FPU19TSElGVFxuICB9XG5cbiAgcGFja2V0LmNsZWFuID0gKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcykgJiBjb25zdGFudHMuQ0xFQU5fU0VTU0lPTl9NQVNLKSAhPT0gMFxuICB0aGlzLl9wb3MrK1xuXG4gIC8vIFBhcnNlIGtlZXBhbGl2ZVxuICBwYWNrZXQua2VlcGFsaXZlID0gdGhpcy5fcGFyc2VOdW0oKVxuICBpZiAocGFja2V0LmtlZXBhbGl2ZSA9PT0gLTEpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdQYWNrZXQgdG9vIHNob3J0JykpXG5cbiAgLy8gcGFyc2UgcHJvcGVydGllc1xuICBpZiAocGFja2V0LnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cbiAgLy8gUGFyc2UgY2xpZW50SWRcbiAgY2xpZW50SWQgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gIGlmIChjbGllbnRJZCA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1BhY2tldCB0b28gc2hvcnQnKSlcbiAgcGFja2V0LmNsaWVudElkID0gY2xpZW50SWRcblxuICBpZiAoZmxhZ3Mud2lsbCkge1xuICAgIGlmIChwYWNrZXQucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICB2YXIgd2lsbFByb3BlcnRpZXMgPSB0aGlzLl9wYXJzZVByb3BlcnRpZXMoKVxuICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbGxQcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0LndpbGwucHJvcGVydGllcyA9IHdpbGxQcm9wZXJ0aWVzXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhcnNlIHdpbGwgdG9waWNcbiAgICB0b3BpYyA9IHRoaXMuX3BhcnNlU3RyaW5nKClcbiAgICBpZiAodG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2Ugd2lsbCB0b3BpYycpKVxuICAgIHBhY2tldC53aWxsLnRvcGljID0gdG9waWNcblxuICAgIC8vIFBhcnNlIHdpbGwgcGF5bG9hZFxuICAgIHBheWxvYWQgPSB0aGlzLl9wYXJzZUJ1ZmZlcigpXG4gICAgaWYgKHBheWxvYWQgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2Ugd2lsbCBwYXlsb2FkJykpXG4gICAgcGFja2V0LndpbGwucGF5bG9hZCA9IHBheWxvYWRcbiAgfVxuXG4gIC8vIFBhcnNlIHVzZXJuYW1lXG4gIGlmIChmbGFncy51c2VybmFtZSkge1xuICAgIHVzZXJuYW1lID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmICh1c2VybmFtZSA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB1c2VybmFtZScpKVxuICAgIHBhY2tldC51c2VybmFtZSA9IHVzZXJuYW1lXG4gIH1cblxuICAvLyBQYXJzZSBwYXNzd29yZFxuICBpZiAoZmxhZ3MucGFzc3dvcmQpIHtcbiAgICBwYXNzd29yZCA9IHRoaXMuX3BhcnNlQnVmZmVyKClcbiAgICBpZiAocGFzc3dvcmQgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgcGFzc3dvcmQnKSlcbiAgICBwYWNrZXQucGFzc3dvcmQgPSBwYXNzd29yZFxuICB9XG4gIC8vIG5lZWQgZm9yIHJpZ2h0IHBhcnNlIGF1dGggcGFja2V0IGFuZCBzZWxmIHNldCB1cFxuICB0aGlzLnNldHRpbmdzID0gcGFja2V0XG5cbiAgcmV0dXJuIHBhY2tldFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUNvbm5hY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA8IDIpIHJldHVybiBudWxsXG5cbiAgcGFja2V0LnNlc3Npb25QcmVzZW50ID0gISEodGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspICYgY29uc3RhbnRzLlNFU1NJT05QUkVTRU5UX01BU0spXG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHBhY2tldC5yZWFzb25Db2RlID0gdGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspXG4gIH0gZWxzZSB7XG4gICAgcGFja2V0LnJldHVybkNvZGUgPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MrKylcbiAgfVxuXG4gIGlmIChwYWNrZXQucmV0dXJuQ29kZSA9PT0gLTEgfHwgcGFja2V0LnJlYXNvbkNvZGUgPT09IC0xKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHJldHVybiBjb2RlJykpXG4gIC8vIG1xdHQgNSBwcm9wZXJ0aWVzXG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQdWJsaXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcbiAgcGFja2V0LnRvcGljID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuXG4gIGlmIChwYWNrZXQudG9waWMgPT09IG51bGwpIHJldHVybiB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdG9waWMnKSlcblxuICAvLyBQYXJzZSBtZXNzYWdlSWRcbiAgaWYgKHBhY2tldC5xb3MgPiAwKSBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgfVxuICB9XG5cbiAgcGFja2V0LnBheWxvYWQgPSB0aGlzLl9saXN0LnNsaWNlKHRoaXMuX3BvcywgcGFja2V0Lmxlbmd0aClcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VTdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuICB2YXIgdG9waWNcbiAgdmFyIG9wdGlvbnNcbiAgdmFyIHFvc1xuICB2YXIgcmhcbiAgdmFyIHJhcFxuICB2YXIgbmxcbiAgdmFyIHN1YnNjcmlwdGlvblxuXG4gIGlmIChwYWNrZXQucW9zICE9PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1dyb25nIHN1YnNjcmliZSBoZWFkZXInKSlcbiAgfVxuXG4gIHBhY2tldC5zdWJzY3JpcHRpb25zID0gW11cblxuICBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHRoaXMuX3BvcyA8IHBhY2tldC5sZW5ndGgpIHtcbiAgICAvLyBQYXJzZSB0b3BpY1xuICAgIHRvcGljID0gdGhpcy5fcGFyc2VTdHJpbmcoKVxuICAgIGlmICh0b3BpYyA9PT0gbnVsbCkgcmV0dXJuIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB0b3BpYycpKVxuXG4gICAgb3B0aW9ucyA9IHRoaXMuX3BhcnNlQnl0ZSgpXG4gICAgcW9zID0gb3B0aW9ucyAmIGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19RT1NfTUFTS1xuICAgIG5sID0gKChvcHRpb25zID4+IGNvbnN0YW50cy5TVUJTQ1JJQkVfT1BUSU9OU19OTF9TSElGVCkgJiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfTkxfTUFTSykgIT09IDBcbiAgICByYXAgPSAoKG9wdGlvbnMgPj4gY29uc3RhbnRzLlNVQlNDUklCRV9PUFRJT05TX1JBUF9TSElGVCkgJiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfUkFQX01BU0spICE9PSAwXG4gICAgcmggPSAob3B0aW9ucyA+PiBjb25zdGFudHMuU1VCU0NSSUJFX09QVElPTlNfUkhfU0hJRlQpICYgY29uc3RhbnRzLlNVQlNDUklCRV9PUFRJT05TX1JIX01BU0tcblxuICAgIHN1YnNjcmlwdGlvbiA9IHsgdG9waWM6IHRvcGljLCBxb3M6IHFvcyB9XG5cbiAgICAvLyBtcXR0IDUgb3B0aW9uc1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm5sID0gbmxcbiAgICAgIHN1YnNjcmlwdGlvbi5yYXAgPSByYXBcbiAgICAgIHN1YnNjcmlwdGlvbi5yaCA9IHJoXG4gICAgfVxuXG4gICAgLy8gUHVzaCBwYWlyIHRvIHN1YnNjcmlwdGlvbnNcbiAgICBwYWNrZXQuc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbilcbiAgfVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN1YmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhY2tldCA9IHRoaXMucGFja2V0XG4gIHRoaXMucGFja2V0LmdyYW50ZWQgPSBbXVxuXG4gIGlmICghdGhpcy5fcGFyc2VNZXNzYWdlSWQoKSkgeyByZXR1cm4gfVxuXG4gIC8vIFByb3BlcnRpZXMgbXF0dCA1XG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBncmFudGVkIFFvU2VzXG4gIHdoaWxlICh0aGlzLl9wb3MgPCB0aGlzLnBhY2tldC5sZW5ndGgpIHtcbiAgICB0aGlzLnBhY2tldC5ncmFudGVkLnB1c2godGhpcy5fbGlzdC5yZWFkVUludDgodGhpcy5fcG9zKyspKVxuICB9XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlVW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIHBhY2tldC51bnN1YnNjcmlwdGlvbnMgPSBbXVxuXG4gIC8vIFBhcnNlIG1lc3NhZ2VJZFxuICBpZiAoIXRoaXMuX3BhcnNlTWVzc2FnZUlkKCkpIHsgcmV0dXJuIH1cblxuICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHRoaXMuX3BvcyA8IHBhY2tldC5sZW5ndGgpIHtcbiAgICB2YXIgdG9waWNcblxuICAgIC8vIFBhcnNlIHRvcGljXG4gICAgdG9waWMgPSB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgaWYgKHRvcGljID09PSBudWxsKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIHRvcGljJykpXG5cbiAgICAvLyBQdXNoIHRvcGljIHRvIHVuc3Vic2NyaXB0aW9uc1xuICAgIHBhY2tldC51bnN1YnNjcmlwdGlvbnMucHVzaCh0b3BpYylcbiAgfVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVVuc3ViYWNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcbiAgaWYgKCF0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpKSByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIG1lc3NhZ2VJZCcpKVxuICAvLyBQcm9wZXJ0aWVzIG1xdHQgNVxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgICAgcGFja2V0LnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzXG4gICAgfVxuICAgIC8vIFBhcnNlIGdyYW50ZWQgUW9TZXNcbiAgICBwYWNrZXQuZ3JhbnRlZCA9IFtdXG4gICAgd2hpbGUgKHRoaXMuX3BvcyA8IHRoaXMucGFja2V0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5wYWNrZXQuZ3JhbnRlZC5wdXNoKHRoaXMuX2xpc3QucmVhZFVJbnQ4KHRoaXMuX3BvcysrKSlcbiAgICB9XG4gIH1cbn1cblxuLy8gcGFyc2UgcGFja2V0cyBsaWtlIHB1YmFjaywgcHVicmVjLCBwdWJyZWwsIHB1YmNvbXBcblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQ29uZmlybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICB0aGlzLl9wYXJzZU1lc3NhZ2VJZCgpXG5cbiAgaWYgKHRoaXMuc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgaWYgKHBhY2tldC5sZW5ndGggPiAyKSB7XG4gICAgICAvLyByZXNwb25zZSBjb2RlXG4gICAgICBwYWNrZXQucmVhc29uQ29kZSA9IHRoaXMuX3BhcnNlQnl0ZSgpXG4gICAgICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX3BhcnNlUHJvcGVydGllcygpXG4gICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIHBhcnNlIGRpc2Nvbm5lY3QgcGFja2V0XG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZURpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIGlmICh0aGlzLnNldHRpbmdzLnByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgIC8vIHJlc3BvbnNlIGNvZGVcbiAgICBwYWNrZXQucmVhc29uQ29kZSA9IHRoaXMuX3BhcnNlQnl0ZSgpXG4gICAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcGVydGllcykubGVuZ3RoKSB7XG4gICAgICBwYWNrZXQucHJvcGVydGllcyA9IHByb3BlcnRpZXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBwYXJzZSBhdXRoIHBhY2tldFxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VBdXRoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFja2V0ID0gdGhpcy5wYWNrZXRcblxuICBpZiAodGhpcy5zZXR0aW5ncy5wcm90b2NvbFZlcnNpb24gIT09IDUpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBhdXRoIHBhY2tldCBmb3IgdGhpcyB2ZXJzaW9uIE1RVFQnKSlcbiAgfVxuXG4gIC8vIHJlc3BvbnNlIGNvZGVcbiAgcGFja2V0LnJlYXNvbkNvZGUgPSB0aGlzLl9wYXJzZUJ5dGUoKVxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcGFyc2VQcm9wZXJ0aWVzKClcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpLmxlbmd0aCkge1xuICAgIHBhY2tldC5wcm9wZXJ0aWVzID0gcHJvcGVydGllc1xuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VNZXNzYWdlSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYWNrZXQgPSB0aGlzLnBhY2tldFxuXG4gIHBhY2tldC5tZXNzYWdlSWQgPSB0aGlzLl9wYXJzZU51bSgpXG5cbiAgaWYgKHBhY2tldC5tZXNzYWdlSWQgPT09IG51bGwpIHtcbiAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIChtYXliZUJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5fcGFyc2VOdW0oKVxuICB2YXIgcmVzdWx0XG4gIHZhciBlbmQgPSBsZW5ndGggKyB0aGlzLl9wb3NcblxuICBpZiAobGVuZ3RoID09PSAtMSB8fCBlbmQgPiB0aGlzLl9saXN0Lmxlbmd0aCB8fCBlbmQgPiB0aGlzLnBhY2tldC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgcmVzdWx0ID0gdGhpcy5fbGlzdC50b1N0cmluZygndXRmOCcsIHRoaXMuX3BvcywgZW5kKVxuICB0aGlzLl9wb3MgKz0gbGVuZ3RoXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVN0cmluZ1BhaXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogdGhpcy5fcGFyc2VTdHJpbmcoKSxcbiAgICB2YWx1ZTogdGhpcy5fcGFyc2VTdHJpbmcoKVxuICB9XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5fcGFyc2VOdW0oKVxuICB2YXIgcmVzdWx0XG4gIHZhciBlbmQgPSBsZW5ndGggKyB0aGlzLl9wb3NcblxuICBpZiAobGVuZ3RoID09PSAtMSB8fCBlbmQgPiB0aGlzLl9saXN0Lmxlbmd0aCB8fCBlbmQgPiB0aGlzLnBhY2tldC5sZW5ndGgpIHJldHVybiBudWxsXG5cbiAgcmVzdWx0ID0gdGhpcy5fbGlzdC5zbGljZSh0aGlzLl9wb3MsIGVuZClcblxuICB0aGlzLl9wb3MgKz0gbGVuZ3RoXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZU51bSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2xpc3QubGVuZ3RoIC0gdGhpcy5fcG9zIDwgMikgcmV0dXJuIC0xXG5cbiAgdmFyIHJlc3VsdCA9IHRoaXMuX2xpc3QucmVhZFVJbnQxNkJFKHRoaXMuX3BvcylcbiAgdGhpcy5fcG9zICs9IDJcblxuICByZXR1cm4gcmVzdWx0XG59XG5cblBhcnNlci5wcm90b3R5cGUuX3BhcnNlNEJ5dGVOdW0gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9saXN0Lmxlbmd0aCAtIHRoaXMuX3BvcyA8IDQpIHJldHVybiAtMVxuXG4gIHZhciByZXN1bHQgPSB0aGlzLl9saXN0LnJlYWRVSW50MzJCRSh0aGlzLl9wb3MpXG4gIHRoaXMuX3BvcyArPSA0XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZVZhckJ5dGVOdW0gPSBmdW5jdGlvbiAoZnVsbEluZm9GbGFnKSB7XG4gIHZhciBieXRlcyA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIGxlbmd0aCA9IDBcbiAgdmFyIHJlc3VsdCA9IHRydWVcbiAgdmFyIGN1cnJlbnRcbiAgdmFyIHBhZGRpbmcgPSB0aGlzLl9wb3MgPyB0aGlzLl9wb3MgOiAwXG5cbiAgd2hpbGUgKGJ5dGVzIDwgNSkge1xuICAgIGN1cnJlbnQgPSB0aGlzLl9saXN0LnJlYWRVSW50OChwYWRkaW5nICsgYnl0ZXMrKylcbiAgICBsZW5ndGggKz0gbXVsICogKGN1cnJlbnQgJiBjb25zdGFudHMuTEVOR1RIX01BU0spXG4gICAgbXVsICo9IDB4ODBcblxuICAgIGlmICgoY3VycmVudCAmIGNvbnN0YW50cy5MRU5HVEhfRklOX01BU0spID09PSAwKSBicmVha1xuICAgIGlmICh0aGlzLl9saXN0Lmxlbmd0aCA8PSBieXRlcykge1xuICAgICAgcmVzdWx0ID0gZmFsc2VcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHBhZGRpbmcpIHtcbiAgICB0aGlzLl9wb3MgKz0gYnl0ZXNcbiAgfVxuXG4gIHJlc3VsdCA9IHJlc3VsdFxuICAgID8gZnVsbEluZm9GbGFnID8ge1xuICAgICAgYnl0ZXM6IGJ5dGVzLFxuICAgICAgdmFsdWU6IGxlbmd0aFxuICAgIH0gOiBsZW5ndGhcbiAgICA6IGZhbHNlXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9wYXJzZUJ5dGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLl9saXN0LnJlYWRVSW50OCh0aGlzLl9wb3MpXG4gIHRoaXMuX3BvcysrXG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdieXRlJzoge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQnl0ZSgpICE9PSAwXG4gICAgfVxuICAgIGNhc2UgJ2ludDgnOiB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VCeXRlKClcbiAgICB9XG4gICAgY2FzZSAnaW50MTYnOiB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VOdW0oKVxuICAgIH1cbiAgICBjYXNlICdpbnQzMic6IHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZTRCeXRlTnVtKClcbiAgICB9XG4gICAgY2FzZSAndmFyJzoge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVmFyQnl0ZU51bSgpXG4gICAgfVxuICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJzZVN0cmluZygpXG4gICAgfVxuICAgIGNhc2UgJ3BhaXInOiB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VTdHJpbmdQYWlyKClcbiAgICB9XG4gICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQnVmZmVyKClcbiAgICB9XG4gIH1cbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5fcGFyc2VWYXJCeXRlTnVtKClcbiAgdmFyIHN0YXJ0ID0gdGhpcy5fcG9zXG4gIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aFxuICB2YXIgcmVzdWx0ID0ge31cbiAgd2hpbGUgKHRoaXMuX3BvcyA8IGVuZCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fcGFyc2VCeXRlKClcbiAgICB2YXIgbmFtZSA9IGNvbnN0YW50cy5wcm9wZXJ0aWVzQ29kZXNbdHlwZV1cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgRXJyb3IoJ1Vua25vd24gcHJvcGVydHknKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyB1c2VyIHByb3BlcnRpZXMgcHJvY2Vzc1xuICAgIGlmIChuYW1lID09PSAndXNlclByb3BlcnRpZXMnKSB7XG4gICAgICBpZiAoIXJlc3VsdFtuYW1lXSkge1xuICAgICAgICByZXN1bHRbbmFtZV0gPSB7fVxuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRVc2VyUHJvcGVydHkgPSB0aGlzLl9wYXJzZUJ5VHlwZShjb25zdGFudHMucHJvcGVydGllc1R5cGVzW25hbWVdKVxuICAgICAgcmVzdWx0W25hbWVdW2N1cnJlbnRVc2VyUHJvcGVydHkubmFtZV0gPSBjdXJyZW50VXNlclByb3BlcnR5LnZhbHVlXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICByZXN1bHRbbmFtZV0gPSB0aGlzLl9wYXJzZUJ5VHlwZShjb25zdGFudHMucHJvcGVydGllc1R5cGVzW25hbWVdKVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5fbmV3UGFja2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wYWNrZXQpIHtcbiAgICB0aGlzLl9saXN0LmNvbnN1bWUodGhpcy5wYWNrZXQubGVuZ3RoKVxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgdGhpcy5wYWNrZXQpXG4gIH1cblxuICB0aGlzLnBhY2tldCA9IG5ldyBQYWNrZXQoKVxuXG4gIHRoaXMuX3BvcyA9IDBcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5QYXJzZXIucHJvdG90eXBlLl9lbWl0RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHRoaXMuZXJyb3IgPSBlcnJcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJcblxufSx7XCIuL2NvbnN0YW50c1wiOjkwLFwiLi9wYWNrZXRcIjo5NSxcImJsXCI6OTMsXCJldmVudHNcIjo4MyxcImluaGVyaXRzXCI6ODh9XSw5NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxudmFyIHByb3RvY29sID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgZW1wdHkgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMClcbnZhciB6ZXJvQnVmID0gQnVmZmVyLmZyb20oWzBdKVxudmFyIG51bWJlcnMgPSByZXF1aXJlKCcuL251bWJlcnMnKVxudmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKS5uZXh0VGlja1xuXG52YXIgbnVtQ2FjaGUgPSBudW1iZXJzLmNhY2hlXG52YXIgZ2VuZXJhdGVOdW1iZXIgPSBudW1iZXJzLmdlbmVyYXRlTnVtYmVyXG52YXIgZ2VuZXJhdGVDYWNoZSA9IG51bWJlcnMuZ2VuZXJhdGVDYWNoZVxudmFyIGdlbkJ1ZlZhcmlhYmxlQnl0ZUludCA9IG51bWJlcnMuZ2VuQnVmVmFyaWFibGVCeXRlSW50XG52YXIgZ2VuZXJhdGU0Qnl0ZUJ1ZmZlciA9IG51bWJlcnMuZ2VuZXJhdGU0Qnl0ZUJ1ZmZlclxudmFyIHdyaXRlTnVtYmVyID0gd3JpdGVOdW1iZXJDYWNoZWRcbnZhciB0b0dlbmVyYXRlID0gdHJ1ZVxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgaWYgKHN0cmVhbS5jb3JrKSB7XG4gICAgc3RyZWFtLmNvcmsoKVxuICAgIG5leHRUaWNrKHVuY29yaywgc3RyZWFtKVxuICB9XG5cbiAgaWYgKHRvR2VuZXJhdGUpIHtcbiAgICB0b0dlbmVyYXRlID0gZmFsc2VcbiAgICBnZW5lcmF0ZUNhY2hlKClcbiAgfVxuXG4gIHN3aXRjaCAocGFja2V0LmNtZCkge1xuICAgIGNhc2UgJ2Nvbm5lY3QnOlxuICAgICAgcmV0dXJuIGNvbm5lY3QocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgY2FzZSAnY29ubmFjayc6XG4gICAgICByZXR1cm4gY29ubmFjayhwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdwdWJsaXNoJzpcbiAgICAgIHJldHVybiBwdWJsaXNoKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3B1YmFjayc6XG4gICAgY2FzZSAncHVicmVjJzpcbiAgICBjYXNlICdwdWJyZWwnOlxuICAgIGNhc2UgJ3B1YmNvbXAnOlxuICAgICAgcmV0dXJuIGNvbmZpcm1hdGlvbihwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdzdWJzY3JpYmUnOlxuICAgICAgcmV0dXJuIHN1YnNjcmliZShwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdzdWJhY2snOlxuICAgICAgcmV0dXJuIHN1YmFjayhwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICd1bnN1YnNjcmliZSc6XG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmUocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgY2FzZSAndW5zdWJhY2snOlxuICAgICAgcmV0dXJuIHVuc3ViYWNrKHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ3BpbmdyZXEnOlxuICAgIGNhc2UgJ3BpbmdyZXNwJzpcbiAgICAgIHJldHVybiBlbXB0eVBhY2tldChwYWNrZXQsIHN0cmVhbSwgb3B0cylcbiAgICBjYXNlICdkaXNjb25uZWN0JzpcbiAgICAgIHJldHVybiBkaXNjb25uZWN0KHBhY2tldCwgc3RyZWFtLCBvcHRzKVxuICAgIGNhc2UgJ2F1dGgnOlxuICAgICAgcmV0dXJuIGF1dGgocGFja2V0LCBzdHJlYW0sIG9wdHMpXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignVW5rbm93biBjb21tYW5kJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuLyoqXG4gKiBDb250cm9scyBudW1iZXJzIGNhY2hlLlxuICogU2V0IHRvIFwiZmFsc2VcIiB0byBhbGxvY2F0ZSBidWZmZXJzIG9uLXRoZS1mbGlnaHQgaW5zdGVhZCBvZiBwcmUtZ2VuZXJhdGVkIGNhY2hlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZW5lcmF0ZSwgJ2NhY2hlTnVtYmVycycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHdyaXRlTnVtYmVyID09PSB3cml0ZU51bWJlckNhY2hlZFxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCFudW1DYWNoZSB8fCBPYmplY3Qua2V5cyhudW1DYWNoZSkubGVuZ3RoID09PSAwKSB0b0dlbmVyYXRlID0gdHJ1ZVxuICAgICAgd3JpdGVOdW1iZXIgPSB3cml0ZU51bWJlckNhY2hlZFxuICAgIH0gZWxzZSB7XG4gICAgICB0b0dlbmVyYXRlID0gZmFsc2VcbiAgICAgIHdyaXRlTnVtYmVyID0gd3JpdGVOdW1iZXJHZW5lcmF0ZWRcbiAgICB9XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIHVuY29yayAoc3RyZWFtKSB7XG4gIHN0cmVhbS51bmNvcmsoKVxufVxuXG5mdW5jdGlvbiBjb25uZWN0IChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIHByb3RvY29sSWQgPSBzZXR0aW5ncy5wcm90b2NvbElkIHx8ICdNUVRUJ1xuICB2YXIgcHJvdG9jb2xWZXJzaW9uID0gc2V0dGluZ3MucHJvdG9jb2xWZXJzaW9uIHx8IDRcbiAgdmFyIHdpbGwgPSBzZXR0aW5ncy53aWxsXG4gIHZhciBjbGVhbiA9IHNldHRpbmdzLmNsZWFuXG4gIHZhciBrZWVwYWxpdmUgPSBzZXR0aW5ncy5rZWVwYWxpdmUgfHwgMFxuICB2YXIgY2xpZW50SWQgPSBzZXR0aW5ncy5jbGllbnRJZCB8fCAnJ1xuICB2YXIgdXNlcm5hbWUgPSBzZXR0aW5ncy51c2VybmFtZVxuICB2YXIgcGFzc3dvcmQgPSBzZXR0aW5ncy5wYXNzd29yZFxuICAvKiBtcXR0NSBuZXcgb3ByaW9ucyAqL1xuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcblxuICBpZiAoY2xlYW4gPT09IHVuZGVmaW5lZCkgY2xlYW4gPSB0cnVlXG5cbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBNdXN0IGJlIGEgc3RyaW5nIGFuZCBub24tZmFsc3lcbiAgaWYgKCFwcm90b2NvbElkIHx8XG4gICAgICh0eXBlb2YgcHJvdG9jb2xJZCAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihwcm90b2NvbElkKSkpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvdG9jb2xJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IHByb3RvY29sSWQubGVuZ3RoICsgMlxuXG4gIC8vIE11c3QgYmUgMyBvciA0IG9yIDVcbiAgaWYgKHByb3RvY29sVmVyc2lvbiAhPT0gMyAmJiBwcm90b2NvbFZlcnNpb24gIT09IDQgJiYgcHJvdG9jb2xWZXJzaW9uICE9PSA1KSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHByb3RvY29sIHZlcnNpb24nKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGxlbmd0aCArPSAxXG5cbiAgLy8gQ2xpZW50SWQgbWlnaHQgYmUgb21pdHRlZCBpbiAzLjEuMSwgYnV0IG9ubHkgaWYgY2xlYW5TZXNzaW9uIGlzIHNldCB0byAxXG4gIGlmICgodHlwZW9mIGNsaWVudElkID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIoY2xpZW50SWQpKSAmJlxuICAgICAoY2xpZW50SWQgfHwgcHJvdG9jb2xWZXJzaW9uID09PSA0KSAmJiAoY2xpZW50SWQgfHwgY2xlYW4pKSB7XG4gICAgbGVuZ3RoICs9IGNsaWVudElkLmxlbmd0aCArIDJcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvdG9jb2xWZXJzaW9uIDwgNCkge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdjbGllbnRJZCBtdXN0IGJlIHN1cHBsaWVkIGJlZm9yZSAzLjEuMScpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICgoY2xlYW4gKiAxKSA9PT0gMCkge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdjbGllbnRJZCBtdXN0IGJlIGdpdmVuIGlmIGNsZWFuU2Vzc2lvbiBzZXQgdG8gMCcpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gTXVzdCBiZSBhIHR3byBieXRlIG51bWJlclxuICBpZiAodHlwZW9mIGtlZXBhbGl2ZSAhPT0gJ251bWJlcicgfHxcbiAgICAgIGtlZXBhbGl2ZSA8IDAgfHxcbiAgICAgIGtlZXBhbGl2ZSA+IDY1NTM1IHx8XG4gICAgICBrZWVwYWxpdmUgJSAxICE9PSAwKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIGtlZXBhbGl2ZScpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDJcblxuICAvLyBDb25uZWN0IGZsYWdzXG4gIGxlbmd0aCArPSAxXG5cbiAgLy8gUHJvcGVydGllc1xuICBpZiAocHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgdmFyIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllcyhzdHJlYW0sIHByb3BlcnRpZXMpXG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgLy8gSWYgd2lsbCBleGlzdHMuLi5cbiAgaWYgKHdpbGwpIHtcbiAgICAvLyBJdCBtdXN0IGJlIGFuIG9iamVjdFxuICAgIGlmICh0eXBlb2Ygd2lsbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCB3aWxsJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gSXQgbXVzdCBoYXZlIHRvcGljIHR5cGVvZiBzdHJpbmdcbiAgICBpZiAoIXdpbGwudG9waWMgfHwgdHlwZW9mIHdpbGwudG9waWMgIT09ICdzdHJpbmcnKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgd2lsbCB0b3BpYycpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh3aWxsLnRvcGljKSArIDJcbiAgICB9XG5cbiAgICAvLyBQYXlsb2FkXG4gICAgaWYgKHdpbGwucGF5bG9hZCkge1xuICAgICAgaWYgKHdpbGwucGF5bG9hZC5sZW5ndGggPj0gMCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbGwucGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgod2lsbC5wYXlsb2FkKSArIDJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggKz0gd2lsbC5wYXlsb2FkLmxlbmd0aCArIDJcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHdpbGwgcGF5bG9hZCcpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgLy8gd2lsbCBwcm9wZXJ0aWVzXG4gICAgICB2YXIgd2lsbFByb3BlcnRpZXMgPSB7fVxuICAgICAgaWYgKHByb3RvY29sVmVyc2lvbiA9PT0gNSkge1xuICAgICAgICB3aWxsUHJvcGVydGllcyA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCB3aWxsLnByb3BlcnRpZXMpXG4gICAgICAgIGxlbmd0aCArPSB3aWxsUHJvcGVydGllcy5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBVc2VybmFtZVxuICB2YXIgcHJvdmlkZWRVc2VybmFtZSA9IGZhbHNlXG4gIGlmICh1c2VybmFtZSAhPSBudWxsKSB7XG4gICAgaWYgKGlzU3RyaW5nT3JCdWZmZXIodXNlcm5hbWUpKSB7XG4gICAgICBwcm92aWRlZFVzZXJuYW1lID0gdHJ1ZVxuICAgICAgbGVuZ3RoICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHVzZXJuYW1lKSArIDJcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXJuYW1lJykpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBQYXNzd29yZFxuICBpZiAocGFzc3dvcmQgIT0gbnVsbCkge1xuICAgIGlmICghcHJvdmlkZWRVc2VybmFtZSkge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdVc2VybmFtZSBpcyByZXF1aXJlZCB0byB1c2UgcGFzc3dvcmQnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChpc1N0cmluZ09yQnVmZmVyKHBhc3N3b3JkKSkge1xuICAgICAgbGVuZ3RoICs9IGJ5dGVMZW5ndGgocGFzc3dvcmQpICsgMlxuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQ09OTkVDVF9IRUFERVIpXG5cbiAgLy8gR2VuZXJhdGUgbGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBHZW5lcmF0ZSBwcm90b2NvbCBJRFxuICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgcHJvdG9jb2xJZClcbiAgc3RyZWFtLndyaXRlKFxuICAgIHByb3RvY29sVmVyc2lvbiA9PT0gNFxuICAgICAgPyBwcm90b2NvbC5WRVJTSU9ONFxuICAgICAgOiBwcm90b2NvbFZlcnNpb24gPT09IDVcbiAgICAgICAgPyBwcm90b2NvbC5WRVJTSU9ONVxuICAgICAgICA6IHByb3RvY29sLlZFUlNJT04zXG4gIClcblxuICAvLyBDb25uZWN0IGZsYWdzXG4gIHZhciBmbGFncyA9IDBcbiAgZmxhZ3MgfD0gKHVzZXJuYW1lICE9IG51bGwpID8gcHJvdG9jb2wuVVNFUk5BTUVfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHBhc3N3b3JkICE9IG51bGwpID8gcHJvdG9jb2wuUEFTU1dPUkRfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHdpbGwgJiYgd2lsbC5yZXRhaW4pID8gcHJvdG9jb2wuV0lMTF9SRVRBSU5fTUFTSyA6IDBcbiAgZmxhZ3MgfD0gKHdpbGwgJiYgd2lsbC5xb3MpID8gd2lsbC5xb3MgPDwgcHJvdG9jb2wuV0lMTF9RT1NfU0hJRlQgOiAwXG4gIGZsYWdzIHw9IHdpbGwgPyBwcm90b2NvbC5XSUxMX0ZMQUdfTUFTSyA6IDBcbiAgZmxhZ3MgfD0gY2xlYW4gPyBwcm90b2NvbC5DTEVBTl9TRVNTSU9OX01BU0sgOiAwXG5cbiAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtmbGFnc10pKVxuXG4gIC8vIEtlZXBhbGl2ZVxuICB3cml0ZU51bWJlcihzdHJlYW0sIGtlZXBhbGl2ZSlcblxuICAvLyBQcm9wZXJ0aWVzXG4gIGlmIChwcm90b2NvbFZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICAvLyBDbGllbnQgSURcbiAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIGNsaWVudElkKVxuXG4gIC8vIFdpbGxcbiAgaWYgKHdpbGwpIHtcbiAgICBpZiAocHJvdG9jb2xWZXJzaW9uID09PSA1KSB7XG4gICAgICB3aWxsUHJvcGVydGllcy53cml0ZSgpXG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwgd2lsbC50b3BpYylcbiAgICB3cml0ZVN0cmluZ09yQnVmZmVyKHN0cmVhbSwgd2lsbC5wYXlsb2FkKVxuICB9XG5cbiAgLy8gVXNlcm5hbWUgYW5kIHBhc3N3b3JkXG4gIGlmICh1c2VybmFtZSAhPSBudWxsKSB7XG4gICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHVzZXJuYW1lKVxuICB9XG4gIGlmIChwYXNzd29yZCAhPSBudWxsKSB7XG4gICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHBhc3N3b3JkKVxuICB9XG4gIC8vIFRoaXMgaXMgYSBzbWFsbCBwYWNrZXQgdGhhdCBoYXBwZW5zIG9ubHkgb25jZSBvbiBhIHN0cmVhbVxuICAvLyBXZSBhc3N1bWUgdGhlIHN0cmVhbSBpcyBhbHdheXMgZnJlZSB0byByZWNlaXZlIG1vcmUgZGF0YSBhZnRlciB0aGlzXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbm5hY2sgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIHJjID0gdmVyc2lvbiA9PT0gNSA/IHNldHRpbmdzLnJlYXNvbkNvZGUgOiBzZXR0aW5ncy5yZXR1cm5Db2RlXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICB2YXIgbGVuZ3RoID0gMiAvLyBsZW5ndGggb2YgcmMgYW5kIHNlc3Npb25IZWFkZXJcblxuICAvLyBDaGVjayByZXR1cm4gY29kZVxuICBpZiAodHlwZW9mIHJjICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCByZXR1cm4gY29kZScpKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIC8vIG1xdHQ1IHByb3BlcnRpZXNcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllcyhzdHJlYW0sIHByb3BlcnRpZXMpXG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLkNPTk5BQ0tfSEVBREVSKVxuICAvLyBsZW5ndGhcbiAgd3JpdGVWYXJCeXRlSW50KHN0cmVhbSwgbGVuZ3RoKVxuICBzdHJlYW0ud3JpdGUoc2V0dGluZ3Muc2Vzc2lvblByZXNlbnQgPyBwcm90b2NvbC5TRVNTSU9OUFJFU0VOVF9IRUFERVIgOiB6ZXJvQnVmKVxuXG4gIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcmNdKSlcbiAgaWYgKHByb3BlcnRpZXNEYXRhICE9IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcHVibGlzaCAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgcW9zID0gc2V0dGluZ3MucW9zIHx8IDBcbiAgdmFyIHJldGFpbiA9IHNldHRpbmdzLnJldGFpbiA/IHByb3RvY29sLlJFVEFJTl9NQVNLIDogMFxuICB2YXIgdG9waWMgPSBzZXR0aW5ncy50b3BpY1xuICB2YXIgcGF5bG9hZCA9IHNldHRpbmdzLnBheWxvYWQgfHwgZW1wdHlcbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gVG9waWMgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgQnVmZmVyXG4gIGlmICh0eXBlb2YgdG9waWMgPT09ICdzdHJpbmcnKSBsZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgodG9waWMpICsgMlxuICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIodG9waWMpKSBsZW5ndGggKz0gdG9waWMubGVuZ3RoICsgMlxuICBlbHNlIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdG9waWMnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEdldCB0aGUgcGF5bG9hZCBsZW5ndGhcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGF5bG9hZCkpIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChwYXlsb2FkKVxuICBlbHNlIGxlbmd0aCArPSBwYXlsb2FkLmxlbmd0aFxuXG4gIC8vIE1lc3NhZ2UgSUQgbXVzdCBhIG51bWJlciBpZiBxb3MgPiAwXG4gIGlmIChxb3MgJiYgdHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChxb3MpIGxlbmd0aCArPSAyXG5cbiAgLy8gbXF0dDUgcHJvcGVydGllc1xuICB2YXIgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlBVQkxJU0hfSEVBREVSW3Fvc11bc2V0dGluZ3MuZHVwID8gMSA6IDBdW3JldGFpbiA/IDEgOiAwXSlcblxuICAvLyBSZW1haW5pbmcgbGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBUb3BpY1xuICB3cml0ZU51bWJlcihzdHJlYW0sIGJ5dGVMZW5ndGgodG9waWMpKVxuICBzdHJlYW0ud3JpdGUodG9waWMpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICBpZiAocW9zID4gMCkgd3JpdGVOdW1iZXIoc3RyZWFtLCBpZClcblxuICAvLyBQcm9wZXJ0aWVzXG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPSBudWxsKSB7XG4gICAgcHJvcGVydGllc0RhdGEud3JpdGUoKVxuICB9XG5cbiAgLy8gUGF5bG9hZFxuICByZXR1cm4gc3RyZWFtLndyaXRlKHBheWxvYWQpXG59XG5cbi8qIFB1YmFjaywgcHVicmVjLCBwdWJyZWwgYW5kIHB1YmNvbXAgKi9cbmZ1bmN0aW9uIGNvbmZpcm1hdGlvbiAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgdHlwZSA9IHNldHRpbmdzLmNtZCB8fCAncHViYWNrJ1xuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIGR1cCA9IChzZXR0aW5ncy5kdXAgJiYgdHlwZSA9PT0gJ3B1YnJlbCcpID8gcHJvdG9jb2wuRFVQX01BU0sgOiAwXG4gIHZhciBxb3MgPSAwXG4gIHZhciByZWFzb25Db2RlID0gc2V0dGluZ3MucmVhc29uQ29kZVxuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcbiAgdmFyIGxlbmd0aCA9IHZlcnNpb24gPT09IDUgPyAzIDogMlxuXG4gIGlmICh0eXBlID09PSAncHVicmVsJykgcW9zID0gMVxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIHZhciBwcm9wZXJ0aWVzRGF0YSA9IG51bGxcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXNCeU1heGltdW1QYWNrZXRTaXplKHN0cmVhbSwgcHJvcGVydGllcywgb3B0cywgbGVuZ3RoKVxuICAgIGlmICghcHJvcGVydGllc0RhdGEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLkFDS1NbdHlwZV1bcW9zXVtkdXBdWzBdKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gTWVzc2FnZSBJRFxuICB3cml0ZU51bWJlcihzdHJlYW0sIGlkKVxuXG4gIC8vIHJlYXNvbiBjb2RlIGluIGhlYWRlclxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcmVhc29uQ29kZV0pKVxuICB9XG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlIChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICB2YXIgdmVyc2lvbiA9IG9wdHMgPyBvcHRzLnByb3RvY29sVmVyc2lvbiA6IDRcbiAgdmFyIHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIHZhciBkdXAgPSBzZXR0aW5ncy5kdXAgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDBcbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBzdWJzID0gc2V0dGluZ3Muc3Vic2NyaXB0aW9uc1xuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcblxuICB2YXIgbGVuZ3RoID0gMFxuXG4gIC8vIENoZWNrIG1lc3NhZ2UgSURcbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUlkJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBsZW5ndGggKz0gMlxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllcyhzdHJlYW0sIHByb3BlcnRpZXMpXG4gICAgbGVuZ3RoICs9IHByb3BlcnRpZXNEYXRhLmxlbmd0aFxuICB9XG5cbiAgLy8gQ2hlY2sgc3Vic2NyaXB0aW9uc1xuICBpZiAodHlwZW9mIHN1YnMgPT09ICdvYmplY3QnICYmIHN1YnMubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgaXRvcGljID0gc3Vic1tpXS50b3BpY1xuICAgICAgdmFyIGlxb3MgPSBzdWJzW2ldLnFvc1xuXG4gICAgICBpZiAodHlwZW9mIGl0b3BpYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIHRvcGljJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpcW9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2NyaXB0aW9ucyAtIGludmFsaWQgcW9zJykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgICAgICB2YXIgbmwgPSBzdWJzW2ldLm5sIHx8IGZhbHNlXG4gICAgICAgIGlmICh0eXBlb2YgbmwgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBzdWJzY3JpcHRpb25zIC0gaW52YWxpZCBObyBMb2NhbCcpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHZhciByYXAgPSBzdWJzW2ldLnJhcCB8fCBmYWxzZVxuICAgICAgICBpZiAodHlwZW9mIHJhcCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIFJldGFpbiBhcyBQdWJsaXNoZWQnKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmggPSBzdWJzW2ldLnJoIHx8IDBcbiAgICAgICAgaWYgKHR5cGVvZiByaCAhPT0gJ251bWJlcicgfHwgcmggPiAyKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMgLSBpbnZhbGlkIFJldGFpbiBIYW5kbGluZycpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChpdG9waWMpICsgMiArIDFcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNjcmlwdGlvbnMnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuU1VCU0NSSUJFX0hFQURFUlsxXVtkdXAgPyAxIDogMF1bMF0pXG5cbiAgLy8gR2VuZXJhdGUgbGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBHZW5lcmF0ZSBtZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJ1ZVxuXG4gIC8vIEdlbmVyYXRlIHN1YnNcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIHN1YiA9IHN1YnNbal1cbiAgICB2YXIganRvcGljID0gc3ViLnRvcGljXG4gICAgdmFyIGpxb3MgPSBzdWIucW9zXG4gICAgdmFyIGpubCA9ICtzdWIubmxcbiAgICB2YXIganJhcCA9ICtzdWIucmFwXG4gICAgdmFyIGpyaCA9IHN1Yi5yaFxuICAgIHZhciBqb3B0aW9uc1xuXG4gICAgLy8gV3JpdGUgdG9waWMgc3RyaW5nXG4gICAgd3JpdGVTdHJpbmcoc3RyZWFtLCBqdG9waWMpXG5cbiAgICAvLyBvcHRpb25zIHByb2Nlc3NcbiAgICBqb3B0aW9ucyA9IHByb3RvY29sLlNVQlNDUklCRV9PUFRJT05TX1FPU1tqcW9zXVxuICAgIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgICBqb3B0aW9ucyB8PSBqbmwgPyBwcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19OTCA6IDBcbiAgICAgIGpvcHRpb25zIHw9IGpyYXAgPyBwcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19SQVAgOiAwXG4gICAgICBqb3B0aW9ucyB8PSBqcmggPyBwcm90b2NvbC5TVUJTQ1JJQkVfT1BUSU9OU19SSFtqcmhdIDogMFxuICAgIH1cbiAgICAvLyBXcml0ZSBvcHRpb25zXG4gICAgcmVzdWx0ID0gc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtqb3B0aW9uc10pKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBzdWJhY2sgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBncmFudGVkID0gc2V0dGluZ3MuZ3JhbnRlZFxuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcbiAgdmFyIGxlbmd0aCA9IDBcblxuICAvLyBDaGVjayBtZXNzYWdlIElEXG4gIGlmICh0eXBlb2YgaWQgIT09ICdudW1iZXInKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2VJZCcpKVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgbGVuZ3RoICs9IDJcblxuICAvLyBDaGVjayBncmFudGVkIHFvcyB2ZWN0b3JcbiAgaWYgKHR5cGVvZiBncmFudGVkID09PSAnb2JqZWN0JyAmJiBncmFudGVkLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhbnRlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVvZiBncmFudGVkW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcW9zIHZlY3RvcicpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGxlbmd0aCArPSAxXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBxb3MgdmVjdG9yJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIHZhciBwcm9wZXJ0aWVzRGF0YSA9IG51bGxcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXNCeU1heGltdW1QYWNrZXRTaXplKHN0cmVhbSwgcHJvcGVydGllcywgb3B0cywgbGVuZ3RoKVxuICAgIGlmICghcHJvcGVydGllc0RhdGEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBoZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlNVQkFDS19IRUFERVIpXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICByZXR1cm4gc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKGdyYW50ZWQpKVxufVxuXG5mdW5jdGlvbiB1bnN1YnNjcmliZSAocGFja2V0LCBzdHJlYW0sIG9wdHMpIHtcbiAgdmFyIHZlcnNpb24gPSBvcHRzID8gb3B0cy5wcm90b2NvbFZlcnNpb24gOiA0XG4gIHZhciBzZXR0aW5ncyA9IHBhY2tldCB8fCB7fVxuICB2YXIgaWQgPSBzZXR0aW5ncy5tZXNzYWdlSWRcbiAgdmFyIGR1cCA9IHNldHRpbmdzLmR1cCA/IHByb3RvY29sLkRVUF9NQVNLIDogMFxuICB2YXIgdW5zdWJzID0gc2V0dGluZ3MudW5zdWJzY3JpcHRpb25zXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuXG4gIHZhciBsZW5ndGggPSAwXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggKz0gMlxuICB9XG4gIC8vIENoZWNrIHVuc3Vic1xuICBpZiAodHlwZW9mIHVuc3VicyA9PT0gJ29iamVjdCcgJiYgdW5zdWJzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5zdWJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodHlwZW9mIHVuc3Vic1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHVuc3Vic2NyaXB0aW9ucycpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh1bnN1YnNbaV0pICsgMlxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgdW5zdWJzY3JpcHRpb25zJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICB2YXIgcHJvcGVydGllc0RhdGEgPSBudWxsXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG4gIH1cblxuICAvLyBIZWFkZXJcbiAgc3RyZWFtLndyaXRlKHByb3RvY29sLlVOU1VCU0NSSUJFX0hFQURFUlsxXVtkdXAgPyAxIDogMF1bMF0pXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICAvLyBVbnN1YnNcbiAgdmFyIHJlc3VsdCA9IHRydWVcbiAgZm9yICh2YXIgaiA9IDA7IGogPCB1bnN1YnMubGVuZ3RoOyBqKyspIHtcbiAgICByZXN1bHQgPSB3cml0ZVN0cmluZyhzdHJlYW0sIHVuc3Vic1tqXSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdW5zdWJhY2sgKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIGlkID0gc2V0dGluZ3MubWVzc2FnZUlkXG4gIHZhciBkdXAgPSBzZXR0aW5ncy5kdXAgPyBwcm90b2NvbC5EVVBfTUFTSyA6IDBcbiAgdmFyIGdyYW50ZWQgPSBzZXR0aW5ncy5ncmFudGVkXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICB2YXIgdHlwZSA9IHNldHRpbmdzLmNtZFxuICB2YXIgcW9zID0gMFxuXG4gIHZhciBsZW5ndGggPSAyXG5cbiAgLy8gQ2hlY2sgbWVzc2FnZSBJRFxuICBpZiAodHlwZW9mIGlkICE9PSAnbnVtYmVyJykge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlSWQnKSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIENoZWNrIGdyYW50ZWRcbiAgaWYgKHZlcnNpb24gPT09IDUpIHtcbiAgICBpZiAodHlwZW9mIGdyYW50ZWQgPT09ICdvYmplY3QnICYmIGdyYW50ZWQubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYW50ZWQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBncmFudGVkW2ldICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBxb3MgdmVjdG9yJykpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkIHFvcyB2ZWN0b3InKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpXG4gICAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUocHJvdG9jb2wuQUNLU1t0eXBlXVtxb3NdW2R1cF1bMF0pXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyBNZXNzYWdlIElEXG4gIHdyaXRlTnVtYmVyKHN0cmVhbSwgaWQpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cblxuICAvLyBwYXlsb2FkXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKGdyYW50ZWQpKVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGVtcHR5UGFja2V0IChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKHByb3RvY29sLkVNUFRZW3BhY2tldC5jbWRdKVxufVxuXG5mdW5jdGlvbiBkaXNjb25uZWN0IChwYWNrZXQsIHN0cmVhbSwgb3B0cykge1xuICB2YXIgdmVyc2lvbiA9IG9wdHMgPyBvcHRzLnByb3RvY29sVmVyc2lvbiA6IDRcbiAgdmFyIHNldHRpbmdzID0gcGFja2V0IHx8IHt9XG4gIHZhciByZWFzb25Db2RlID0gc2V0dGluZ3MucmVhc29uQ29kZVxuICB2YXIgcHJvcGVydGllcyA9IHNldHRpbmdzLnByb3BlcnRpZXNcbiAgdmFyIGxlbmd0aCA9IHZlcnNpb24gPT09IDUgPyAxIDogMFxuXG4gIC8vIHByb3BlcmllcyBtcXR0IDVcbiAgdmFyIHByb3BlcnRpZXNEYXRhID0gbnVsbFxuICBpZiAodmVyc2lvbiA9PT0gNSkge1xuICAgIHByb3BlcnRpZXNEYXRhID0gZ2V0UHJvcGVydGllc0J5TWF4aW11bVBhY2tldFNpemUoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpXG4gICAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGxlbmd0aCArPSBwcm9wZXJ0aWVzRGF0YS5sZW5ndGhcbiAgfVxuXG4gIC8vIEhlYWRlclxuICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLmNvZGVzWydkaXNjb25uZWN0J10gPDwgNF0pKVxuXG4gIC8vIExlbmd0aFxuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBsZW5ndGgpXG5cbiAgLy8gcmVhc29uIGNvZGUgaW4gaGVhZGVyXG4gIGlmICh2ZXJzaW9uID09PSA1KSB7XG4gICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtyZWFzb25Db2RlXSkpXG4gIH1cblxuICAvLyBwcm9wZXJpZXMgbXF0dCA1XG4gIGlmIChwcm9wZXJ0aWVzRGF0YSAhPT0gbnVsbCkge1xuICAgIHByb3BlcnRpZXNEYXRhLndyaXRlKClcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGF1dGggKHBhY2tldCwgc3RyZWFtLCBvcHRzKSB7XG4gIHZhciB2ZXJzaW9uID0gb3B0cyA/IG9wdHMucHJvdG9jb2xWZXJzaW9uIDogNFxuICB2YXIgc2V0dGluZ3MgPSBwYWNrZXQgfHwge31cbiAgdmFyIHJlYXNvbkNvZGUgPSBzZXR0aW5ncy5yZWFzb25Db2RlXG4gIHZhciBwcm9wZXJ0aWVzID0gc2V0dGluZ3MucHJvcGVydGllc1xuICB2YXIgbGVuZ3RoID0gdmVyc2lvbiA9PT0gNSA/IDEgOiAwXG5cbiAgaWYgKHZlcnNpb24gIT09IDUpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBtcXR0IHZlcnNpb24gZm9yIGF1dGggcGFja2V0JykpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICB2YXIgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzQnlNYXhpbXVtUGFja2V0U2l6ZShzdHJlYW0sIHByb3BlcnRpZXMsIG9wdHMsIGxlbmd0aClcbiAgaWYgKCFwcm9wZXJ0aWVzRGF0YSkgeyByZXR1cm4gZmFsc2UgfVxuICBsZW5ndGggKz0gcHJvcGVydGllc0RhdGEubGVuZ3RoXG5cbiAgLy8gSGVhZGVyXG4gIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wuY29kZXNbJ2F1dGgnXSA8PCA0XSkpXG5cbiAgLy8gTGVuZ3RoXG4gIHdyaXRlVmFyQnl0ZUludChzdHJlYW0sIGxlbmd0aClcblxuICAvLyByZWFzb24gY29kZSBpbiBoZWFkZXJcbiAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtyZWFzb25Db2RlXSkpXG5cbiAgLy8gcHJvcGVyaWVzIG1xdHQgNVxuICBpZiAocHJvcGVydGllc0RhdGEgIT09IG51bGwpIHtcbiAgICBwcm9wZXJ0aWVzRGF0YS53cml0ZSgpXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiB3cml0ZVZhckJ5dGVJbnQgLSB3cml0ZSBhbiBNUVRUIHN0eWxlIHZhcmlhYmxlIGJ5dGUgaW50ZWdlciB0byB0aGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPE51bWJlcj4gcG9zIC0gb2Zmc2V0XG4gKiBAcGFyYW0gPE51bWJlcj4gbGVuZ3RoIC0gbGVuZ3RoICg+MClcbiAqIEByZXR1cm5zIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHZhckJ5dGVJbnRDYWNoZSA9IHt9XG5mdW5jdGlvbiB3cml0ZVZhckJ5dGVJbnQgKHN0cmVhbSwgbnVtKSB7XG4gIHZhciBidWZmZXIgPSB2YXJCeXRlSW50Q2FjaGVbbnVtXVxuXG4gIGlmICghYnVmZmVyKSB7XG4gICAgYnVmZmVyID0gZ2VuQnVmVmFyaWFibGVCeXRlSW50KG51bSkuZGF0YVxuICAgIGlmIChudW0gPCAxNjM4NCkgdmFyQnl0ZUludENhY2hlW251bV0gPSBidWZmZXJcbiAgfVxuXG4gIHN0cmVhbS53cml0ZShidWZmZXIpXG59XG5cbi8qKlxuICogd3JpdGVTdHJpbmcgLSB3cml0ZSBhIHV0Zjggc3RyaW5nIHRvIHRoZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8U3RyaW5nPiBzdHJpbmcgLSBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm4gPE51bWJlcj4gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB3cml0ZVN0cmluZyAoc3RyZWFtLCBzdHJpbmcpIHtcbiAgdmFyIHN0cmxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0cmluZylcbiAgd3JpdGVOdW1iZXIoc3RyZWFtLCBzdHJsZW4pXG5cbiAgc3RyZWFtLndyaXRlKHN0cmluZywgJ3V0ZjgnKVxufVxuXG4vKipcbiAqIHdyaXRlU3RyaW5nUGFpciAtIHdyaXRlIGEgdXRmOCBzdHJpbmcgcGFpcnMgdG8gdGhlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSA8QnVmZmVyPiBidWZmZXIgLSBkZXN0aW5hdGlvblxuICogQHBhcmFtIDxTdHJpbmc+IG5hbWUgLSBzdHJpbmcgbmFtZSB0byB3cml0ZVxuICogQHBhcmFtIDxTdHJpbmc+IHZhbHVlIC0gc3RyaW5nIHZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nUGFpciAoc3RyZWFtLCBuYW1lLCB2YWx1ZSkge1xuICB3cml0ZVN0cmluZyhzdHJlYW0sIG5hbWUpXG4gIHdyaXRlU3RyaW5nKHN0cmVhbSwgdmFsdWUpXG59XG5cbi8qKlxuICogd3JpdGVOdW1iZXIgLSB3cml0ZSBhIHR3byBieXRlIG51bWJlciB0byB0aGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIDxCdWZmZXI+IGJ1ZmZlciAtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gPE51bWJlcj4gcG9zIC0gb2Zmc2V0XG4gKiBAcGFyYW0gPFN0cmluZz4gbnVtYmVyIC0gbnVtYmVyIHRvIHdyaXRlXG4gKiBAcmV0dXJuIDxOdW1iZXI+IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHdyaXRlTnVtYmVyQ2FjaGVkIChzdHJlYW0sIG51bWJlcikge1xuICByZXR1cm4gc3RyZWFtLndyaXRlKG51bUNhY2hlW251bWJlcl0pXG59XG5mdW5jdGlvbiB3cml0ZU51bWJlckdlbmVyYXRlZCAoc3RyZWFtLCBudW1iZXIpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShnZW5lcmF0ZU51bWJlcihudW1iZXIpKVxufVxuZnVuY3Rpb24gd3JpdGU0Qnl0ZU51bWJlciAoc3RyZWFtLCBudW1iZXIpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZShnZW5lcmF0ZTRCeXRlQnVmZmVyKG51bWJlcikpXG59XG4vKipcbiAqIHdyaXRlU3RyaW5nT3JCdWZmZXIgLSB3cml0ZSBhIFN0cmluZyBvciBCdWZmZXIgd2l0aCB0aGUgaXRzIGxlbmd0aCBwcmVmaXhcbiAqXG4gKiBAcGFyYW0gPEJ1ZmZlcj4gYnVmZmVyIC0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSA8TnVtYmVyPiBwb3MgLSBvZmZzZXRcbiAqIEBwYXJhbSA8U3RyaW5nPiB0b1dyaXRlIC0gU3RyaW5nIG9yIEJ1ZmZlclxuICogQHJldHVybiA8TnVtYmVyPiBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxuICovXG5mdW5jdGlvbiB3cml0ZVN0cmluZ09yQnVmZmVyIChzdHJlYW0sIHRvV3JpdGUpIHtcbiAgaWYgKHR5cGVvZiB0b1dyaXRlID09PSAnc3RyaW5nJykge1xuICAgIHdyaXRlU3RyaW5nKHN0cmVhbSwgdG9Xcml0ZSlcbiAgfSBlbHNlIGlmICh0b1dyaXRlKSB7XG4gICAgd3JpdGVOdW1iZXIoc3RyZWFtLCB0b1dyaXRlLmxlbmd0aClcbiAgICBzdHJlYW0ud3JpdGUodG9Xcml0ZSlcbiAgfSBlbHNlIHdyaXRlTnVtYmVyKHN0cmVhbSwgMClcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllcyAoc3RyZWFtLCBwcm9wZXJ0aWVzKSB7XG4gIC8qIGNvbm5lY3QgcHJvcGVydGllcyAqL1xuICBpZiAodHlwZW9mIHByb3BlcnRpZXMgIT09ICdvYmplY3QnIHx8IHByb3BlcnRpZXMubGVuZ3RoICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVuZ3RoOiAxLFxuICAgICAgd3JpdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd3JpdGVQcm9wZXJ0aWVzKHN0cmVhbSwge30sIDApXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBwcm9wZXJ0aWVzTGVuZ3RoID0gMFxuICBmdW5jdGlvbiBnZXRMZW5ndGhQcm9wZXJ0eSAobmFtZSkge1xuICAgIHZhciB0eXBlID0gcHJvdG9jb2wucHJvcGVydGllc1R5cGVzW25hbWVdXG4gICAgdmFyIHZhbHVlID0gcHJvcGVydGllc1tuYW1lXVxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdieXRlJzoge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgMVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnaW50OCc6IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgMVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSAxICsgQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpICsgMlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAnaW50MTYnOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkICcgKyBuYW1lKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIDJcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2ludDMyJzoge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCAnICsgbmFtZSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoICs9IDEgKyA0XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICd2YXInOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkICcgKyBuYW1lKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIGdlbkJ1ZlZhcmlhYmxlQnl0ZUludCh2YWx1ZSkubGVuZ3RoXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdJbnZhbGlkICcgKyBuYW1lKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gMSArIDIgKyBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZS50b1N0cmluZygpKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSAncGFpcic6IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIG5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCArPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIG5hbWUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gMSArIDIgKyBCdWZmZXIuYnl0ZUxlbmd0aChuYW1lLnRvU3RyaW5nKCkpICsgMiArIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlW25hbWVdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9LCAwKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgJyArIG5hbWUpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aFxuICB9XG4gIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcGVydGllcykge1xuICAgICAgdmFyIHByb3BMZW5ndGggPSBnZXRMZW5ndGhQcm9wZXJ0eShwcm9wTmFtZSlcbiAgICAgIGlmICghcHJvcExlbmd0aCkgcmV0dXJuIGZhbHNlXG4gICAgICBwcm9wZXJ0aWVzTGVuZ3RoICs9IHByb3BMZW5ndGhcbiAgICB9XG4gIH1cbiAgdmFyIHByb3BlcnRpZXNMZW5ndGhMZW5ndGggPSBnZW5CdWZWYXJpYWJsZUJ5dGVJbnQocHJvcGVydGllc0xlbmd0aCkubGVuZ3RoXG5cbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IHByb3BlcnRpZXNMZW5ndGhMZW5ndGggKyBwcm9wZXJ0aWVzTGVuZ3RoLFxuICAgIHdyaXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB3cml0ZVByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzTGVuZ3RoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0aWVzQnlNYXhpbXVtUGFja2V0U2l6ZSAoc3RyZWFtLCBwcm9wZXJ0aWVzLCBvcHRzLCBsZW5ndGgpIHtcbiAgdmFyIG1heUVtcHR5UHJvcHMgPSBbJ3JlYXNvblN0cmluZycsICd1c2VyUHJvcGVydGllcyddXG4gIHZhciBtYXhpbXVtUGFja2V0U2l6ZSA9IG9wdHMgJiYgb3B0cy5wcm9wZXJ0aWVzICYmIG9wdHMucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSA/IG9wdHMucHJvcGVydGllcy5tYXhpbXVtUGFja2V0U2l6ZSA6IDBcblxuICB2YXIgcHJvcGVydGllc0RhdGEgPSBnZXRQcm9wZXJ0aWVzKHN0cmVhbSwgcHJvcGVydGllcylcbiAgaWYgKG1heGltdW1QYWNrZXRTaXplKSB7XG4gICAgd2hpbGUgKGxlbmd0aCArIHByb3BlcnRpZXNEYXRhLmxlbmd0aCA+IG1heGltdW1QYWNrZXRTaXplKSB7XG4gICAgICB2YXIgY3VycmVudE1heUVtcHR5UHJvcCA9IG1heUVtcHR5UHJvcHMuc2hpZnQoKVxuICAgICAgaWYgKGN1cnJlbnRNYXlFbXB0eVByb3AgJiYgcHJvcGVydGllc1tjdXJyZW50TWF5RW1wdHlQcm9wXSkge1xuICAgICAgICBkZWxldGUgcHJvcGVydGllc1tjdXJyZW50TWF5RW1wdHlQcm9wXVxuICAgICAgICBwcm9wZXJ0aWVzRGF0YSA9IGdldFByb3BlcnRpZXMoc3RyZWFtLCBwcm9wZXJ0aWVzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wZXJ0aWVzRGF0YVxufVxuXG5mdW5jdGlvbiB3cml0ZVByb3BlcnRpZXMgKHN0cmVhbSwgcHJvcGVydGllcywgcHJvcGVydGllc0xlbmd0aCkge1xuICAvKiB3cml0ZSBwcm9wZXJ0aWVzIHRvIHN0cmVhbSAqL1xuICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCBwcm9wZXJ0aWVzTGVuZ3RoKVxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmIHByb3BlcnRpZXNbcHJvcE5hbWVdICE9PSBudWxsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXVxuICAgICAgdmFyIHR5cGUgPSBwcm90b2NvbC5wcm9wZXJ0aWVzVHlwZXNbcHJvcE5hbWVdXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnYnl0ZSc6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFsrdmFsdWVdKSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2ludDgnOiB7XG4gICAgICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5wcm9wZXJ0aWVzW3Byb3BOYW1lXV0pKVxuICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbdmFsdWVdKSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgd3JpdGVTdHJpbmdPckJ1ZmZlcihzdHJlYW0sIHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnaW50MTYnOiB7XG4gICAgICAgICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKFtwcm90b2NvbC5wcm9wZXJ0aWVzW3Byb3BOYW1lXV0pKVxuICAgICAgICAgIHdyaXRlTnVtYmVyKHN0cmVhbSwgdmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdpbnQzMic6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgd3JpdGU0Qnl0ZU51bWJlcihzdHJlYW0sIHZhbHVlKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAndmFyJzoge1xuICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgICAgICB3cml0ZVZhckJ5dGVJbnQoc3RyZWFtLCB2YWx1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICBzdHJlYW0ud3JpdGUoQnVmZmVyLmZyb20oW3Byb3RvY29sLnByb3BlcnRpZXNbcHJvcE5hbWVdXSkpXG4gICAgICAgICAgd3JpdGVTdHJpbmcoc3RyZWFtLCB2YWx1ZSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3BhaXInOiB7XG4gICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShbcHJvdG9jb2wucHJvcGVydGllc1twcm9wTmFtZV1dKSlcbiAgICAgICAgICAgIHdyaXRlU3RyaW5nUGFpcihzdHJlYW0sIG5hbWUudG9TdHJpbmcoKSwgdmFsdWVbbmFtZV0udG9TdHJpbmcoKSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBwcm9wZXJ0eSAnICsgcHJvcE5hbWUpKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGJ1Zk9yU3RyaW5nKSB7XG4gIGlmICghYnVmT3JTdHJpbmcpIHJldHVybiAwXG4gIGVsc2UgaWYgKGJ1Zk9yU3RyaW5nIGluc3RhbmNlb2YgQnVmZmVyKSByZXR1cm4gYnVmT3JTdHJpbmcubGVuZ3RoXG4gIGVsc2UgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGJ1Zk9yU3RyaW5nKVxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ09yQnVmZmVyIChmaWVsZCkge1xuICByZXR1cm4gdHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyB8fCBmaWVsZCBpbnN0YW5jZW9mIEJ1ZmZlclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlXG5cbn0se1wiLi9jb25zdGFudHNcIjo5MCxcIi4vbnVtYmVyc1wiOjk0LFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcIjo5OSxcInNhZmUtYnVmZmVyXCI6MTE4fV0sOTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxufSx7XCJ3cmFwcHlcIjoxMzl9XSw5OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCJfcHJvY2Vzc1wiOjEwMH1dLDEwMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG59LHt9XSwxMDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxMDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxufSx7fV0sMTAzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG59LHt9XSwxMDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5cbn0se1wiLi9kZWNvZGVcIjoxMDIsXCIuL2VuY29kZVwiOjEwM31dLDEwNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5cbn0se1wiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIjoxMDZ9XSwxMDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07XG59LHtcIi4vX3N0cmVhbV9yZWFkYWJsZVwiOjEwOCxcIi4vX3N0cmVhbV93cml0YWJsZVwiOjExMCxcImNvcmUtdXRpbC1pc1wiOjEzLFwiaW5oZXJpdHNcIjo4OCxcInByb2Nlc3MtbmV4dGljay1hcmdzXCI6OTl9XSwxMDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG59LHtcIi4vX3N0cmVhbV90cmFuc2Zvcm1cIjoxMDksXCJjb3JlLXV0aWwtaXNcIjoxMyxcImluaGVyaXRzXCI6ODh9XSwxMDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9fc3RyZWFtX2R1cGxleFwiOjEwNixcIi4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0XCI6MTExLFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3lcIjoxMTIsXCIuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtXCI6MTEzLFwiX3Byb2Nlc3NcIjoxMDAsXCJjb3JlLXV0aWwtaXNcIjoxMyxcImV2ZW50c1wiOjgzLFwiaW5oZXJpdHNcIjo4OCxcImlzYXJyYXlcIjoxMTQsXCJwcm9jZXNzLW5leHRpY2stYXJnc1wiOjk5LFwic2FmZS1idWZmZXJcIjoxMTgsXCJzdHJpbmdfZGVjb2Rlci9cIjoxMTUsXCJ1dGlsXCI6MTF9XSwxMDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbn0se1wiLi9fc3RyZWFtX2R1cGxleFwiOjEwNixcImNvcmUtdXRpbC1pc1wiOjEzLFwiaW5oZXJpdHNcIjo4OH1dLDExMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLHNldEltbWVkaWF0ZSl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcInRpbWVyc1wiKS5zZXRJbW1lZGlhdGUpXG59LHtcIi4vX3N0cmVhbV9kdXBsZXhcIjoxMDYsXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVwiOjExMixcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cIjoxMTMsXCJfcHJvY2Vzc1wiOjEwMCxcImNvcmUtdXRpbC1pc1wiOjEzLFwiaW5oZXJpdHNcIjo4OCxcInByb2Nlc3MtbmV4dGljay1hcmdzXCI6OTksXCJzYWZlLWJ1ZmZlclwiOjExOCxcInRpbWVyc1wiOjEyMCxcInV0aWwtZGVwcmVjYXRlXCI6MTM0fV0sMTExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufVxufSx7XCJzYWZlLWJ1ZmZlclwiOjExOCxcInV0aWxcIjoxMX1dLDExMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59O1xufSx7XCJwcm9jZXNzLW5leHRpY2stYXJnc1wiOjk5fV0sMTEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG59LHtcImV2ZW50c1wiOjgzfV0sMTE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG59LHt9XSwxMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59XG59LHtcInNhZmUtYnVmZmVyXCI6MTE4fV0sMTE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbn0se1wiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIjoxMDYsXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCI6MTA3LFwiLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qc1wiOjEwOCxcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCI6MTA5LFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiOjExMH1dLDExNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gUmVJbnRlcnZhbCAoY2FsbGJhY2ssIGludGVydmFsLCBhcmdzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB0aGlzLl9hcmdzID0gYXJncztcblxuICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGNhbGxiYWNrLCBpbnRlcnZhbCwgdGhpcy5fYXJncyk7XG5cbiAgdGhpcy5yZXNjaGVkdWxlID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgLy8gaWYgbm8gaW50ZXJ2YWwgZW50ZXJlZCwgdXNlIHRoZSBpbnRlcnZhbCBwYXNzZWQgaW4gb24gY3JlYXRpb25cbiAgICBpZiAoIWludGVydmFsKVxuICAgICAgaW50ZXJ2YWwgPSBzZWxmLl9pbnRlcnZhbDtcblxuICAgIGlmIChzZWxmLl9pbnRlcnZhbClcbiAgICAgIGNsZWFySW50ZXJ2YWwoc2VsZi5faW50ZXJ2YWwpO1xuICAgIHNlbGYuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoc2VsZi5fY2FsbGJhY2ssIGludGVydmFsLCBzZWxmLl9hcmdzKTtcbiAgfTtcblxuICB0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9pbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9pbnRlcnZhbCk7XG4gICAgICBzZWxmLl9pbnRlcnZhbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG4gIFxuICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYuX2ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHNlbGYuX2ludGVydmFsKTtcbiAgICB9XG4gICAgc2VsZi5fY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgc2VsZi5faW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgc2VsZi5fYXJncyA9IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVJbnRlcnZhbCAoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbmVlZGVkJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVydmFsIG5lZWRlZCcpO1xuXG4gIHZhciBhcmdzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFJlSW50ZXJ2YWwoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlSW50ZXJ2YWw7XG5cbn0se31dLDExODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuXG59LHtcImJ1ZmZlclwiOjEyfV0sMTE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gc2hpZnRcblxuZnVuY3Rpb24gc2hpZnQgKHN0cmVhbSkge1xuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGVcbiAgaWYgKCFycykgcmV0dXJuIG51bGxcbiAgcmV0dXJuIChycy5vYmplY3RNb2RlIHx8IHR5cGVvZiBzdHJlYW0uX2R1cGxleFN0YXRlID09PSAnbnVtYmVyJykgPyBzdHJlYW0ucmVhZCgpIDogc3RyZWFtLnJlYWQoZ2V0U3RhdGVMZW5ndGgocnMpKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUxlbmd0aCAoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAvLyBTaW5jZSBub2RlIDYuMy4wIHN0YXRlLmJ1ZmZlciBpcyBhIEJ1ZmZlckxpc3Qgbm90IGFuIGFycmF5XG4gICAgaWYgKHN0YXRlLmJ1ZmZlci5oZWFkKSB7XG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aFxufVxuXG59LHt9XSwxMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChzZXRJbW1lZGlhdGUsY2xlYXJJbW1lZGlhdGUpe1xudmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcInRpbWVyc1wiKS5zZXRJbW1lZGlhdGUscmVxdWlyZShcInRpbWVyc1wiKS5jbGVhckltbWVkaWF0ZSlcbn0se1wicHJvY2Vzcy9icm93c2VyLmpzXCI6MTAwLFwidGltZXJzXCI6MTIwfV0sMTIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKFwiLi4vcHJvdG90eXBlL2lzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcblxuXHRpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFwibGVuZ3RoXCIpKSByZXR1cm4gZmFsc2U7XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIHZhbHVlLmxlbmd0aCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0eXBlb2YgdmFsdWUuY2FsbCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZS5hcHBseSAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuICFpc1Byb3RvdHlwZSh2YWx1ZSk7XG59O1xuXG59LHtcIi4uL3Byb3RvdHlwZS9pc1wiOjEyOH1dLDEyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGlzVmFsdWUgICAgICAgPSByZXF1aXJlKFwiLi4vdmFsdWUvaXNcIilcbiAgLCBpc09iamVjdCAgICAgID0gcmVxdWlyZShcIi4uL29iamVjdC9pc1wiKVxuICAsIHN0cmluZ0NvZXJjZSAgPSByZXF1aXJlKFwiLi4vc3RyaW5nL2NvZXJjZVwiKVxuICAsIHRvU2hvcnRTdHJpbmcgPSByZXF1aXJlKFwiLi90by1zaG9ydC1zdHJpbmdcIik7XG5cbnZhciByZXNvbHZlTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCB2YWx1ZSkge1xuXHRyZXR1cm4gbWVzc2FnZS5yZXBsYWNlKFwiJXZcIiwgdG9TaG9ydFN0cmluZyh2YWx1ZSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIGRlZmF1bHRNZXNzYWdlLCBpbnB1dE9wdGlvbnMpIHtcblx0aWYgKCFpc09iamVjdChpbnB1dE9wdGlvbnMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlc29sdmVNZXNzYWdlKGRlZmF1bHRNZXNzYWdlLCB2YWx1ZSkpO1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSB7XG5cdFx0aWYgKFwiZGVmYXVsdFwiIGluIGlucHV0T3B0aW9ucykgcmV0dXJuIGlucHV0T3B0aW9uc1tcImRlZmF1bHRcIl07XG5cdFx0aWYgKGlucHV0T3B0aW9ucy5pc09wdGlvbmFsKSByZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgZXJyb3JNZXNzYWdlID0gc3RyaW5nQ29lcmNlKGlucHV0T3B0aW9ucy5lcnJvck1lc3NhZ2UpO1xuXHRpZiAoIWlzVmFsdWUoZXJyb3JNZXNzYWdlKSkgZXJyb3JNZXNzYWdlID0gZGVmYXVsdE1lc3NhZ2U7XG5cdHRocm93IG5ldyBUeXBlRXJyb3IocmVzb2x2ZU1lc3NhZ2UoZXJyb3JNZXNzYWdlLCB2YWx1ZSkpO1xufTtcblxufSx7XCIuLi9vYmplY3QvaXNcIjoxMjUsXCIuLi9zdHJpbmcvY29lcmNlXCI6MTI5LFwiLi4vdmFsdWUvaXNcIjoxMzEsXCIuL3RvLXNob3J0LXN0cmluZ1wiOjEyNH1dLDEyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHR0cnkgeyByZXR1cm4gU3RyaW5nKHZhbHVlKTsgfVxuXHRcdGNhdGNoIChlcnJvcjIpIHsgcmV0dXJuIG51bGw7IH1cblx0fVxufTtcblxufSx7fV0sMTI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgc2FmZVRvU3RyaW5nID0gcmVxdWlyZShcIi4vc2FmZS10by1zdHJpbmdcIik7XG5cbnZhciByZU5ld0xpbmUgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nID0gc2FmZVRvU3RyaW5nKHZhbHVlKTtcblx0aWYgKHN0cmluZyA9PT0gbnVsbCkgcmV0dXJuIFwiPE5vbi1jb2VyY2libGUgdG8gc3RyaW5nIHZhbHVlPlwiO1xuXHQvLyBUcmltIGlmIHRvbyBsb25nXG5cdGlmIChzdHJpbmcubGVuZ3RoID4gMTAwKSBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgOTkpICsgXCLigKZcIjtcblx0Ly8gUmVwbGFjZSBldmVudHVhbCBuZXcgbGluZXNcblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVOZXdMaW5lLCBmdW5jdGlvbiAoY2hhcikge1xuXHRcdHN3aXRjaCAoY2hhcikge1xuXHRcdFx0Y2FzZSBcIlxcblwiOlxuXHRcdFx0XHRyZXR1cm4gXCJcXFxcblwiO1xuXHRcdFx0Y2FzZSBcIlxcclwiOlxuXHRcdFx0XHRyZXR1cm4gXCJcXFxcclwiO1xuXHRcdFx0Y2FzZSBcIlxcdTIwMjhcIjpcblx0XHRcdFx0cmV0dXJuIFwiXFxcXHUyMDI4XCI7XG5cdFx0XHRjYXNlIFwiXFx1MjAyOVwiOlxuXHRcdFx0XHRyZXR1cm4gXCJcXFxcdTIwMjlcIjtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlclwiKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gc3RyaW5nO1xufTtcblxufSx7XCIuL3NhZmUtdG8tc3RyaW5nXCI6MTIzfV0sMTI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSA9IHJlcXVpcmUoXCIuLi92YWx1ZS9pc1wiKTtcblxuLy8gcHJldHRpZXItaWdub3JlXG52YXIgcG9zc2libGVUeXBlcyA9IHsgXCJvYmplY3RcIjogdHJ1ZSwgXCJmdW5jdGlvblwiOiB0cnVlLCBcInVuZGVmaW5lZFwiOiB0cnVlIC8qIGRvY3VtZW50LmFsbCAqLyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzVmFsdWUodmFsdWUpKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHBvc3NpYmxlVHlwZXMsIHR5cGVvZiB2YWx1ZSk7XG59O1xuXG59LHtcIi4uL3ZhbHVlL2lzXCI6MTMxfV0sMTI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVzb2x2ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoXCIuLi9saWIvcmVzb2x2ZS1leGNlcHRpb25cIilcbiAgLCBpcyAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vaXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHRpZiAoaXModmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiByZXNvbHZlRXhjZXB0aW9uKHZhbHVlLCBcIiV2IGlzIG5vdCBhIHBsYWluIGZ1bmN0aW9uXCIsIGFyZ3VtZW50c1sxXSk7XG59O1xuXG59LHtcIi4uL2xpYi9yZXNvbHZlLWV4Y2VwdGlvblwiOjEyMixcIi4vaXNcIjoxMjd9XSwxMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZShcIi4uL2Z1bmN0aW9uL2lzXCIpO1xuXG52YXIgY2xhc3NSZSA9IC9eXFxzKmNsYXNzW1xcc3svfV0vLCBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gZmFsc2U7XG5cdGlmIChjbGFzc1JlLnRlc3QoZnVuY3Rpb25Ub1N0cmluZy5jYWxsKHZhbHVlKSkpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHRydWU7XG59O1xuXG59LHtcIi4uL2Z1bmN0aW9uL2lzXCI6MTIxfV0sMTI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKFwiLi4vb2JqZWN0L2lzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRpZiAoIWlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuXHR0cnkge1xuXHRcdGlmICghdmFsdWUuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbn0se1wiLi4vb2JqZWN0L2lzXCI6MTI1fV0sMTI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNWYWx1ZSAgPSByZXF1aXJlKFwiLi4vdmFsdWUvaXNcIilcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoXCIuLi9vYmplY3QvaXNcIik7XG5cbnZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdGlmICghaXNWYWx1ZSh2YWx1ZSkpIHJldHVybiBudWxsO1xuXHRpZiAoaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0Ly8gUmVqZWN0IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgY29lcmNpb25cblx0XHR2YXIgdmFsdWVUb1N0cmluZyA9IHZhbHVlLnRvU3RyaW5nO1xuXHRcdGlmICh0eXBlb2YgdmFsdWVUb1N0cmluZyAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcblx0XHRpZiAodmFsdWVUb1N0cmluZyA9PT0gb2JqZWN0VG9TdHJpbmcpIHJldHVybiBudWxsO1xuXHRcdC8vIE5vdGU6IEl0IGNhbiBiZSBvYmplY3QgY29taW5nIGZyb20gb3RoZXIgcmVhbG0sIHN0aWxsIGFzIHRoZXJlJ3Mgbm8gRVMzIGFuZCBDU1AgY29tcGxpYW50XG5cdFx0Ly8gd2F5IHRvIHJlc29sdmUgaXRzIHJlYWxtJ3MgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyBpdCdzIGxlZnQgYXMgbm90IGFkZHJlc3NlZCBlZGdlIGNhc2Vcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBcIlwiICsgdmFsdWU7IC8vIEVuc3VyZSBpbXBsaWNpdCBjb2VyY2lvblxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59O1xuXG59LHtcIi4uL29iamVjdC9pc1wiOjEyNSxcIi4uL3ZhbHVlL2lzXCI6MTMxfV0sMTMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVzb2x2ZUV4Y2VwdGlvbiA9IHJlcXVpcmUoXCIuLi9saWIvcmVzb2x2ZS1leGNlcHRpb25cIilcbiAgLCBpcyAgICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vaXNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLyosIG9wdGlvbnMqLykge1xuXHRpZiAoaXModmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cdHJldHVybiByZXNvbHZlRXhjZXB0aW9uKHZhbHVlLCBcIkNhbm5vdCB1c2UgJXZcIiwgYXJndW1lbnRzWzFdKTtcbn07XG5cbn0se1wiLi4vbGliL3Jlc29sdmUtZXhjZXB0aW9uXCI6MTIyLFwiLi9pc1wiOjEzMX1dLDEzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuLy8gRVMzIHNhZmVcbnZhciBfdW5kZWZpbmVkID0gdm9pZCAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IF91bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGw7IH07XG5cbn0se31dLDEzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxufSx7XCIuL3V0aWxcIjoxMzMsXCJwdW55Y29kZVwiOjEwMSxcInF1ZXJ5c3RyaW5nXCI6MTA0fV0sMTMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcblxufSx7fV0sMTM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxufSx7fV0sMTM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL3N1cHBvcnQvaXNCdWZmZXJcIjoxMzUsXCJfcHJvY2Vzc1wiOjEwMCxcImluaGVyaXRzXCI6ODh9XSwxMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCdcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybVxudmFyIGR1cGxleGlmeSA9IHJlcXVpcmUoJ2R1cGxleGlmeScpXG52YXIgV1MgPSByZXF1aXJlKCd3cycpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRTdHJlYW1cblxuZnVuY3Rpb24gYnVpbGRQcm94eSAob3B0aW9ucywgc29ja2V0V3JpdGUsIHNvY2tldEVuZCkge1xuICB2YXIgcHJveHkgPSBuZXcgVHJhbnNmb3JtKHtcbiAgICBvYmplY3RNb2RlOiBvcHRpb25zLm9iamVjdE1vZGVcbiAgfSlcblxuICBwcm94eS5fd3JpdGUgPSBzb2NrZXRXcml0ZVxuICBwcm94eS5fZmx1c2ggPSBzb2NrZXRFbmRcblxuICByZXR1cm4gcHJveHlcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0U3RyZWFtKHRhcmdldCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIHZhciBzdHJlYW0sIHNvY2tldFxuXG4gIHZhciBpc0Jyb3dzZXIgPSBwcm9jZXNzLnRpdGxlID09PSAnYnJvd3NlcidcbiAgdmFyIGlzTmF0aXZlID0gISFnbG9iYWwuV2ViU29ja2V0XG4gIHZhciBzb2NrZXRXcml0ZSA9IGlzQnJvd3NlciA/IHNvY2tldFdyaXRlQnJvd3NlciA6IHNvY2tldFdyaXRlTm9kZVxuXG4gIGlmIChwcm90b2NvbHMgJiYgIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIHByb3RvY29scykge1xuICAgIC8vIGFjY2VwdCB0aGUgXCJvcHRpb25zXCIgT2JqZWN0IGFzIHRoZSAybmQgYXJndW1lbnRcbiAgICBvcHRpb25zID0gcHJvdG9jb2xzXG4gICAgcHJvdG9jb2xzID0gbnVsbFxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnByb3RvY29sID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMucHJvdG9jb2wpKSB7XG4gICAgICBwcm90b2NvbHMgPSBvcHRpb25zLnByb3RvY29sO1xuICAgIH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgaWYgKG9wdGlvbnMub2JqZWN0TW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9ucy5vYmplY3RNb2RlID0gIShvcHRpb25zLmJpbmFyeSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmJpbmFyeSA9PT0gdW5kZWZpbmVkKVxuICB9XG5cbiAgdmFyIHByb3h5ID0gYnVpbGRQcm94eShvcHRpb25zLCBzb2NrZXRXcml0ZSwgc29ja2V0RW5kKVxuXG4gIGlmICghb3B0aW9ucy5vYmplY3RNb2RlKSB7XG4gICAgcHJveHkuX3dyaXRldiA9IHdyaXRldlxuICB9XG5cbiAgLy8gYnJvd3NlciBvbmx5OiBzZXRzIHRoZSBtYXhpbXVtIHNvY2tldCBidWZmZXIgc2l6ZSBiZWZvcmUgdGhyb3R0bGluZ1xuICB2YXIgYnVmZmVyU2l6ZSA9IG9wdGlvbnMuYnJvd3NlckJ1ZmZlclNpemUgfHwgMTAyNCAqIDUxMlxuXG4gIC8vIGJyb3dzZXIgb25seTogaG93IGxvbmcgdG8gd2FpdCB3aGVuIHRocm90dGxpbmdcbiAgdmFyIGJ1ZmZlclRpbWVvdXQgPSBvcHRpb25zLmJyb3dzZXJCdWZmZXJUaW1lb3V0IHx8IDEwMDBcblxuICAvLyB1c2UgZXhpc3RpbmcgV2ViU29ja2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgc29ja2V0ID0gdGFyZ2V0XG4gIC8vIG90aGVyd2lzZSBtYWtlIGEgbmV3IG9uZVxuICB9IGVsc2Uge1xuICAgIC8vIHNwZWNpYWwgY29uc3RydWN0b3IgdHJlYXRtZW50IGZvciBuYXRpdmUgd2Vic29ja2V0cyBpbiBicm93c2Vycywgc2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21heG9nZGVuL3dlYnNvY2tldC1zdHJlYW0vaXNzdWVzLzgyXG4gICAgaWYgKGlzTmF0aXZlICYmIGlzQnJvd3Nlcikge1xuICAgICAgc29ja2V0ID0gbmV3IFdTKHRhcmdldCwgcHJvdG9jb2xzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzb2NrZXQgPSBuZXcgV1ModGFyZ2V0LCBwcm90b2NvbHMsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgc29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gIH1cblxuICAvLyB3YXMgYWxyZWFkeSBvcGVuIHdoZW4gcGFzc2VkIGluXG4gIGlmIChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gc29ja2V0Lk9QRU4pIHtcbiAgICBzdHJlYW0gPSBwcm94eVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IGR1cGxleGlmeS5vYmooKVxuICAgIHNvY2tldC5vbm9wZW4gPSBvbm9wZW5cbiAgfVxuXG4gIHN0cmVhbS5zb2NrZXQgPSBzb2NrZXRcblxuICBzb2NrZXQub25jbG9zZSA9IG9uY2xvc2VcbiAgc29ja2V0Lm9uZXJyb3IgPSBvbmVycm9yXG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBvbm1lc3NhZ2VcblxuICBwcm94eS5vbignY2xvc2UnLCBkZXN0cm95KVxuXG4gIHZhciBjb2VyY2VUb0J1ZmZlciA9ICFvcHRpb25zLm9iamVjdE1vZGVcblxuICBmdW5jdGlvbiBzb2NrZXRXcml0ZU5vZGUoY2h1bmssIGVuYywgbmV4dCkge1xuICAgIC8vIGF2b2lkIGVycm9ycywgdGhpcyBuZXZlciBoYXBwZW5zIHVubGVzc1xuICAgIC8vIGRlc3Ryb3koKSBpcyBjYWxsZWRcbiAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgIT09IHNvY2tldC5PUEVOKSB7XG4gICAgICBuZXh0KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjb2VyY2VUb0J1ZmZlciAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCAndXRmOCcpXG4gICAgfVxuICAgIHNvY2tldC5zZW5kKGNodW5rLCBuZXh0KVxuICB9XG5cbiAgZnVuY3Rpb24gc29ja2V0V3JpdGVCcm93c2VyKGNodW5rLCBlbmMsIG5leHQpIHtcbiAgICBpZiAoc29ja2V0LmJ1ZmZlcmVkQW1vdW50ID4gYnVmZmVyU2l6ZSkge1xuICAgICAgc2V0VGltZW91dChzb2NrZXRXcml0ZUJyb3dzZXIsIGJ1ZmZlclRpbWVvdXQsIGNodW5rLCBlbmMsIG5leHQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY29lcmNlVG9CdWZmZXIgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgJ3V0ZjgnKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzb2NrZXQuc2VuZChjaHVuaylcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgcmV0dXJuIG5leHQoZXJyKVxuICAgIH1cblxuICAgIG5leHQoKVxuICB9XG5cbiAgZnVuY3Rpb24gc29ja2V0RW5kKGRvbmUpIHtcbiAgICBzb2NrZXQuY2xvc2UoKVxuICAgIGRvbmUoKVxuICB9XG5cbiAgZnVuY3Rpb24gb25vcGVuKCkge1xuICAgIHN0cmVhbS5zZXRSZWFkYWJsZShwcm94eSlcbiAgICBzdHJlYW0uc2V0V3JpdGFibGUocHJveHkpXG4gICAgc3RyZWFtLmVtaXQoJ2Nvbm5lY3QnKVxuICB9XG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBzdHJlYW0uZW5kKClcbiAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubWVzc2FnZShldmVudCkge1xuICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKVxuICAgIGVsc2UgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsICd1dGY4JylcbiAgICBwcm94eS5wdXNoKGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHNvY2tldC5jbG9zZSgpXG4gIH1cblxuICAvLyB0aGlzIGlzIHRvIGJlIGVuYWJsZWQgb25seSBpZiBvYmplY3RNb2RlIGlzIGZhbHNlXG4gIGZ1bmN0aW9uIHdyaXRldiAoY2h1bmtzLCBjYikge1xuICAgIHZhciBidWZmZXJzID0gbmV3IEFycmF5KGNodW5rcy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmtzW2ldLmNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWZmZXJzW2ldID0gQnVmZmVyLmZyb20oY2h1bmtzW2ldLCAndXRmOCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJzW2ldID0gY2h1bmtzW2ldLmNodW5rXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fd3JpdGUoQnVmZmVyLmNvbmNhdChidWZmZXJzKSwgJ2JpbmFyeScsIGNiKVxuICB9XG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCJfcHJvY2Vzc1wiOjEwMCxcImR1cGxleGlmeVwiOjE5LFwicmVhZGFibGUtc3RyZWFtXCI6MTE2LFwic2FmZS1idWZmZXJcIjoxMTgsXCJ3c1wiOjEzOH1dLDEzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbnZhciB3cyA9IG51bGxcblxuaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gV2ViU29ja2V0XG59IGVsc2UgaWYgKHR5cGVvZiBNb3pXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gTW96V2ViU29ja2V0XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdzID0gd2luZG93LldlYlNvY2tldCB8fCB3aW5kb3cuTW96V2ViU29ja2V0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3NcblxufSx7fV0sMTM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG59LHt9XSwxNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cblxufSx7fV19LHt9LFs5XSkoOSlcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 15 */
/*!*********************************************************!*\
  !*** ./node_modules/@dcloudio/uni-mp-weixin/dist/mp.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ 1);
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Behavior = Behavior;
exports.Component = Component;
exports.Page = Page;
exports.nextTick = exports.default = void 0;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/defineProperty */ 2));
var _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ 16));
var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 22));
var _PROP_DEFAULT_VALUES;
function parseData(data, vueComponentOptions) {
  if (!data) {
    return;
  }
  vueComponentOptions.mpOptions.data = data;
}
function parseComponents(vueComponentOptions) {
  vueComponentOptions.components = global.__wxVueOptions.components;
}
var _toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isFn(fn) {
  return typeof fn === 'function';
}
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
function noop() {}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
var SOURCE_KEY = '__data__';
var COMPONENT_LIFECYCLE = {
  created: 'onServiceCreated',
  attached: 'onServiceAttached',
  ready: 'mounted',
  moved: 'moved',
  detached: 'destroyed'
};
var COMPONENT_LIFECYCLE_KEYS = Object.keys(COMPONENT_LIFECYCLE);
var PAGE_LIFETIMES = {
  show: 'onPageShow',
  hide: 'onPageHide',
  resize: 'onPageResize'
};
var PAGE_LIFETIMES_KEYS = Object.keys(PAGE_LIFETIMES);
var PAGE_LIFECYCLE = ['onLoad', 'onShow', 'onReady', 'onHide', 'onUnload', 'onPullDownRefresh', 'onReachBottom', 'onShareAppMessage', 'onPageScroll', 'onResize', 'onTabItemTap'];
function parsePageMethods(mpComponentOptions, vueComponentOptions) {
  var methods = Object.create(null);
  Object.keys(mpComponentOptions).forEach(function (key) {
    var value = mpComponentOptions[key];
    if (isFn(value) && PAGE_LIFECYCLE.indexOf(key) === -1) {
      methods[key] = value;
    }
  });
  vueComponentOptions.methods = methods;
}
function parsePageLifecycle(mpComponentOptions, vueComponentOptions) {
  Object.keys(mpComponentOptions).forEach(function (key) {
    if (PAGE_LIFECYCLE.indexOf(key) !== -1) {
      vueComponentOptions[key] = mpComponentOptions[key];
    }
  });
}
function parsePage(mpComponentOptions) {
  var vueComponentOptions = {
    mixins: [],
    mpOptions: {}
  };
  parseComponents(vueComponentOptions);
  parseData(mpComponentOptions.data, vueComponentOptions);
  parsePageMethods(mpComponentOptions, vueComponentOptions);
  parsePageLifecycle(mpComponentOptions, vueComponentOptions);
  return vueComponentOptions;
}
function parseProperties(properties, vueComponentOptions) {
  if (!properties) {
    return;
  }
  vueComponentOptions.mpOptions.properties = properties;
}
function parseOptions(options, vueComponentOptions) {
  if (!options) {
    return;
  }
  vueComponentOptions.mpOptions.options = options;
}
function parseMethods(methods, vueComponentOptions) {
  if (!methods) {
    return;
  }
  if (methods.$emit) {
    console.warn('Method "$emit" conflicts with an existing Vue instance method');
    delete methods.$emit;
  }
  vueComponentOptions.methods = methods;
}
function parseLifecycle(mpComponentOptions, vueComponentOptions) {
  COMPONENT_LIFECYCLE_KEYS.forEach(function (name) {
    if (hasOwn(mpComponentOptions, name)) {
      (vueComponentOptions[COMPONENT_LIFECYCLE[name]] || (vueComponentOptions[COMPONENT_LIFECYCLE[name]] = [])).push(mpComponentOptions[name]);
    }
  });
}
var mpBehaviors = {
  'wx://form-field': {},
  'wx://component-export': {}
};
function callDefinitionFilter(mpComponentOptions) {
  var behaviors = mpComponentOptions.behaviors,
    definitionFilter = mpComponentOptions.definitionFilter;
  var behaviorDefinitionFilters = [];
  if (Array.isArray(behaviors)) {
    behaviors.forEach(function (behavior) {
      behavior = typeof behavior === 'string' ? mpBehaviors[behavior] : behavior;
      if (behavior.definitionFilter) {
        behaviorDefinitionFilters.push(behavior.definitionFilter);
        behavior.definitionFilter.call(null, mpComponentOptions, []);
      }
    });
  }
  if (isFn(definitionFilter)) {
    return function (defFields) {
      definitionFilter(defFields, behaviorDefinitionFilters);
    };
  }
}
function parseDefinitionFilter(mpComponentOptions, vueComponentOptions) {
  callDefinitionFilter(mpComponentOptions);
}
function parseBehavior(behavior) {
  var data = behavior.data,
    methods = behavior.methods,
    behaviors = behavior.behaviors,
    properties = behavior.properties;
  var vueComponentOptions = {
    watch: {},
    mpOptions: {
      mpObservers: []
    }
  };
  parseData(data, vueComponentOptions);
  parseMethods(methods, vueComponentOptions);
  parseBehaviors(behaviors, vueComponentOptions);
  parseProperties(properties, vueComponentOptions);
  parseLifecycle(behavior, vueComponentOptions);
  parseDefinitionFilter(behavior);
  return vueComponentOptions;
}
var BEHAVIORS = {
  'wx://form-field': {
    beforeCreate: function beforeCreate() {
      var mpOptions = this.$options.mpOptions;
      if (!mpOptions.properties) {
        mpOptions.properties = Object.create(null);
      }
      var props = mpOptions.properties;
      // TODO form submit,reset
      if (!hasOwn(props, 'name')) {
        props.name = {
          type: String
        };
      }
      if (!hasOwn(props, 'value')) {
        props.value = {
          type: String // 默认类型调整为 String,否则默认值为 null,导致一些自定义 input 显示不正确
        };
      }
    }
  }
};

function parseBehaviors(behaviors, vueComponentOptions) {
  if (!behaviors) {
    return;
  }
  behaviors.forEach(function (behavior) {
    if (typeof behavior === 'string') {
      BEHAVIORS[behavior] && vueComponentOptions.mixins.push(BEHAVIORS[behavior]);
    } else {
      vueComponentOptions.mixins.push(parseBehavior(behavior));
    }
  });
}
function parseSinglePath(path) {
  return path.split('.');
}
function parseMultiPaths(paths) {
  return paths.split(',').map(function (path) {
    return parseSinglePath(path);
  });
}
function parseObservers(observers, vueComponentOptions) {
  if (!observers) {
    return;
  }
  var mpObservers = vueComponentOptions.mpOptions.mpObservers;
  Object.keys(observers).forEach(function (path) {
    mpObservers.push({
      paths: parseMultiPaths(path),
      observer: observers[path]
    });
  });
}
function relative(from, to) {
  if (to.indexOf('/') === 0) {
    from = '';
  }
  var fromArr = from.split('/');
  var toArr = to.split('/');
  fromArr.pop();
  while (toArr.length) {
    var part = toArr.shift();
    if (part !== '' && part !== '.') {
      if (part !== '..') {
        fromArr.push(part);
      } else {
        fromArr.pop();
      }
    }
  }
  return fromArr.join('/');
}
function parseRelations(relations, vueComponentOptions) {
  if (!relations) {
    return;
  }
  Object.keys(relations).forEach(function (name) {
    var relation = relations[name];
    relation.name = name;
    relation.target = relation.target ? String(relation.target) : relative(global.__wxRoute, name);
  });
  vueComponentOptions.mpOptions.relations = relations;
}
function parseExternalClasses(externalClasses, vueComponentOptions) {
  if (!externalClasses) {
    return;
  }
  if (!Array.isArray(externalClasses)) {
    externalClasses = [externalClasses];
  }
  vueComponentOptions.mpOptions.externalClasses = externalClasses;
  if (!vueComponentOptions.mpOptions.properties) {
    vueComponentOptions.mpOptions.properties = Object.create(null);
  }
  externalClasses.forEach(function (externalClass) {
    vueComponentOptions.mpOptions.properties[camelize(externalClass)] = {
      type: String,
      value: ''
    };
  });
}
function parseLifetimes(lifetimes, vueComponentOptions) {
  if (!lifetimes) {
    return;
  }
  parseLifecycle(lifetimes, vueComponentOptions);
}
function parsePageLifetimes(pageLifetimes, vueComponentOptions) {
  if (!pageLifetimes) {
    return;
  }
  PAGE_LIFETIMES_KEYS.forEach(function (key) {
    var lifetimeFn = pageLifetimes[key];
    isFn(lifetimeFn) && (vueComponentOptions[PAGE_LIFETIMES[key]] = lifetimeFn);
  });
}
function parseComponent(mpComponentOptions) {
  var data = mpComponentOptions.data,
    options = mpComponentOptions.options,
    methods = mpComponentOptions.methods,
    behaviors = mpComponentOptions.behaviors,
    lifetimes = mpComponentOptions.lifetimes,
    observers = mpComponentOptions.observers,
    relations = mpComponentOptions.relations,
    properties = mpComponentOptions.properties,
    pageLifetimes = mpComponentOptions.pageLifetimes,
    externalClasses = mpComponentOptions.externalClasses;
  var vueComponentOptions = {
    mixins: [],
    props: {},
    watch: {},
    mpOptions: {
      mpObservers: []
    }
  };
  parseComponents(vueComponentOptions);
  parseData(data, vueComponentOptions);
  parseOptions(options, vueComponentOptions);
  parseMethods(methods, vueComponentOptions);
  parseBehaviors(behaviors, vueComponentOptions);
  parseLifetimes(lifetimes, vueComponentOptions);
  parseObservers(observers, vueComponentOptions);
  parseRelations(relations, vueComponentOptions);
  parseProperties(properties, vueComponentOptions);
  parsePageLifetimes(pageLifetimes, vueComponentOptions);
  parseExternalClasses(externalClasses, vueComponentOptions);
  parseLifecycle(mpComponentOptions, vueComponentOptions);
  parseDefinitionFilter(mpComponentOptions);
  return vueComponentOptions;
}
function initRelationHandlers(type, handler, target, ctx) {
  if (!handler) {
    return;
  }
  var name = "_$".concat(type, "Handlers");
  (ctx[name] || (ctx[name] = [])).push(function () {
    handler.call(ctx, target);
  });
}
function initLinkedHandlers(relation, target, ctx) {
  var type = 'linked';
  var name = relation.name;
  var relationNodes = ctx._$relationNodes || (ctx._$relationNodes = Object.create(null));
  (relationNodes[name] || (relationNodes[name] = [])).push(target);
  initRelationHandlers(type, relation[type], target, ctx);
}
function initUnlinkedHandlers(relation, target, ctx) {
  var type = 'unlinked';
  initRelationHandlers(type, relation[type], target, ctx);
}
function findParentRelation(parentVm, target, type) {
  var relations = parentVm && parentVm.$options.mpOptions && parentVm.$options.mpOptions.relations;
  if (!relations) {
    return [];
  }
  var name = Object.keys(relations).find(function (name) {
    var relation = relations[name];
    return relation.target === target && relation.type === type;
  });
  if (!name) {
    return [];
  }
  return [relations[name], parentVm];
}
function initParentRelation(vm, childRelation, match) {
  var _match = match(vm, vm.$options.mpOptions.path),
    _match2 = (0, _slicedToArray2.default)(_match, 2),
    parentRelation = _match2[0],
    parentVm = _match2[1];
  if (!parentRelation) {
    return;
  }
  initLinkedHandlers(parentRelation, vm, parentVm);
  initLinkedHandlers(childRelation, parentVm, vm);
  initUnlinkedHandlers(parentRelation, vm, parentVm);
  initUnlinkedHandlers(childRelation, parentVm, vm);
}
function initRelation(relation, vm) {
  var type = relation.type;
  if (type === 'parent') {
    initParentRelation(vm, relation, function matchParent(vm, target) {
      return findParentRelation(vm.$parent, target, 'child');
    });
  } else if (type === 'ancestor') {
    initParentRelation(vm, relation, function matchAncestor(vm, target) {
      var $parent = vm.$parent;
      while ($parent) {
        var ret = findParentRelation($parent, target, 'descendant');
        if (ret.length) {
          return ret;
        }
        $parent = $parent.$parent;
      }
      return [];
    });
  }
}
function initRelations(vm) {
  var _ref = vm.$options.mpOptions || {},
    relations = _ref.relations;
  if (!relations) {
    return;
  }
  Object.keys(relations).forEach(function (name) {
    initRelation(relations[name], vm);
  });
}
function handleRelations(vm, type) {
  // TODO 需要移除 relationNodes
  var handlers = vm["_$".concat(type, "Handlers")];
  if (!handlers) {
    return;
  }
  handlers.forEach(function (handler) {
    return handler();
  });
}
var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};
function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}
function setDataByExprPath(exprPath, value, data) {
  var keys = exprPath.replace(/\[(\d+?)\]/g, '.$1').split('.');
  keys.reduce(function (obj, key, idx) {
    if (idx === keys.length - 1) {
      obj[key] = value;
    } else {
      if (typeof obj[key] === 'undefined') {
        obj[key] = {};
      }
      return obj[key];
    }
  }, data);
  return keys.length === 1;
}
function setData(data, callback) {
  var _this = this;
  if (!isPlainObject(data)) {
    return;
  }
  Object.keys(data).forEach(function (key) {
    if (setDataByExprPath(key, data[key], _this.data)) {
      !hasOwn(_this, key) && proxy(_this, SOURCE_KEY, key);
    }
  });
  this.$forceUpdate();
  isFn(callback) && this.$nextTick(callback);
}

/**
 * https://github.com/swan-team/swan-js/blob/61e2a63f7aa576b5daafbe77fdfa7c65b977060c/src/utils/index.js
 */

var _toString$1 = Object.prototype.toString;
/**
 * 深度assign的函数
 * @param {Object} targetObject 要被拷贝的目标对象
 * @param {Object} originObject 拷贝的源对象
 * @return {Object} merge后的对象
 */
var deepAssign = function deepAssign() {
  var targetObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var originObject = arguments.length > 1 ? arguments[1] : undefined;
  var originType = _toString$1.call(originObject);
  if (originType === '[object Array]') {
    targetObject = originObject.slice(0);
    return targetObject;
  } else if (originType === '[object Object]') {
    for (var key in originObject) {
      targetObject[key] = deepAssign(targetObject[key], originObject[key]);
    }
    return targetObject;
  } else if (originType === '[object Date]') {
    return new Date(originObject.getTime());
  } else if (originType === '[object RegExp]') {
    var target = String(originObject);
    var lastIndex = target.lastIndexOf('/');
    return new RegExp(target.slice(1, lastIndex), target.slice(lastIndex + 1));
  }
  return originObject;
};

/**
 * 深度拷贝逻辑，不同于lodash等库，但是与微信一致
 * @param {*} [originObj] 原对象
 * @return {Object|Array} 拷贝结果
 */
var deepClone = function deepClone(originObj) {
  return deepAssign(_toString$1.call(originObj) === '[object Array]' ? [] : {}, originObj);
};
var PROP_DEFAULT_VALUES = (_PROP_DEFAULT_VALUES = {}, (0, _defineProperty2.default)(_PROP_DEFAULT_VALUES, String, ''), (0, _defineProperty2.default)(_PROP_DEFAULT_VALUES, Number, 0), (0, _defineProperty2.default)(_PROP_DEFAULT_VALUES, Boolean, false), (0, _defineProperty2.default)(_PROP_DEFAULT_VALUES, Object, null), (0, _defineProperty2.default)(_PROP_DEFAULT_VALUES, Array, []), (0, _defineProperty2.default)(_PROP_DEFAULT_VALUES, null, null), _PROP_DEFAULT_VALUES);
function getDefaultVal(propType) {
  return PROP_DEFAULT_VALUES[propType];
}
function getPropertyVal(options) {
  if (isPlainObject(options)) {
    if (hasOwn(options, 'value')) {
      return options.value;
    }
    return getDefaultVal(options.type);
  }
  return getDefaultVal(options);
}
function getType(propOptions) {
  return isPlainObject(propOptions) ? propOptions.type : propOptions;
}
function validateProp(key, propsOptions, propsData, vm) {
  var value = propsData[key];
  if (value !== undefined) {
    var propOptions = propsOptions[key];
    var type = getType(propOptions);
    value = formatVal(value, type);
    var observer = propOptions && propOptions.observer;
    if (observer) {
      // 初始化时,异步触发 observer,否则 observer 中无法访问 methods 或其他
      setTimeout(function () {
        observe(observer, vm, value);
      }, 4);
    }
    return value;
  }
  return getPropertyVal(propsOptions[key]);
}
function formatVal(val, type) {
  if (type === Boolean) {
    return !!val;
  } else if (type === String) {
    return String(val);
  }
  return val;
}
function observe(observer, vm, newVal, oldVal) {
  try {
    if (typeof observer === 'function') {
      observer.call(vm, newVal, oldVal);
    } else if (typeof observer === 'string' && typeof vm[observer] === 'function') {
      vm[observer](newVal, oldVal);
    }
  } catch (err) {
    console.error("execute observer ".concat(observer, " callback fail! err: ").concat(err));
  }
}
function initProperties(vm, instanceData) {
  var properties = vm.$options.mpOptions.properties;
  if (!properties) {
    return;
  }
  var propsData = deepClone(vm.$options.propsData) || {};
  var _loop = function _loop(key) {
    var observer = isPlainObject(properties[key]) ? properties[key].observer : false;
    var value = validateProp(key, properties, propsData, vm);
    Object.defineProperty(instanceData, key, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return value;
      },
      set: function set(newVal) {
        var oldVal = value;
        /* eslint-disable no-self-compare */
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        // TODO 临时方案,clone array
        value = Array.isArray(newVal) ? newVal.slice(0) : newVal;
        if (observer) {
          observe(observer, vm, newVal, oldVal);
        }
        // 触发渲染
        vm.$forceUpdate();
      }
    });
  };
  for (var key in properties) {
    _loop(key);
  }
}
function updateProperties(vm) {
  var properties = vm.$options.mpOptions && vm.$options.mpOptions.properties;
  var propsData = vm.$options.propsData;
  if (propsData && properties) {
    Object.keys(properties).forEach(function (key) {
      if (hasOwn(propsData, key)) {
        vm[key] = formatVal(propsData[key], getType(properties[key]));
      }
    });
  }
}
function initState(vm) {
  var instanceData = JSON.parse(JSON.stringify(vm.$options.mpOptions.data || {}));
  vm[SOURCE_KEY] = instanceData;
  var propertyDefinition = {
    get: function get() {
      return vm[SOURCE_KEY];
    },
    set: function set(value) {
      vm[SOURCE_KEY] = value;
    }
  };
  Object.defineProperties(vm, {
    data: propertyDefinition,
    properties: propertyDefinition
  });
  vm.setData = setData;
  initProperties(vm, instanceData);
  Object.keys(instanceData).forEach(function (key) {
    proxy(vm, SOURCE_KEY, key);
  });
}
function initMethods(vm) {
  var oldEmit = vm.$emit;
  vm.triggerEvent = function (eventName, detail, options) {
    var target = {
      dataset: vm.$el.dataset
    };
    var event = {
      target: target,
      currentTarget: target,
      detail: detail,
      preventDefault: noop,
      stopPropagation: noop
    };
    oldEmit.call(vm, eventName, event);
  };
  // 主要是Vant 自己封装了 $emit,放到 methods 中会触发 Vue 的警告,索性,框架直接重写该方法
  vm.$emit = function () {
    vm.triggerEvent.apply(vm, arguments);
  };
  vm.getRelationNodes = function (relationKey) {
    // 需要过滤已被销毁的vm
    /* eslint-disable  no-mixed-operators */
    return (vm._$relationNodes && vm._$relationNodes[relationKey] || []).filter(function (vm) {
      return !vm._isDestroyed;
    });
  };
  vm._$updateProperties = updateProperties;
}
function handleObservers(vm) {
  var watch = vm.$options.watch;
  if (!watch) {
    return;
  }
  Object.keys(watch).forEach(function (name) {
    var observer = watch[name];
    if (observer.mounted) {
      var val = vm[name];
      var handler = observer.handler;
      if (typeof handler === 'string') {
        handler = vm[handler];
      }
      handler && handler.call(vm, val, val);
    }
  });
}
var polyfill = {
  beforeCreate: function beforeCreate() {
    // 取消 development 时的 Proxy,避免小程序组件模板中使用尚未定义的属性告警
    this._renderProxy = this;
    this._$self = this;
    this._$noop = noop;
  },
  created: function created() {
    // properties 中可能会访问 methods,故需要在 created 中初始化
    initState(this);
    initMethods(this);
    initRelations(this);
  },
  mounted: function mounted() {
    handleObservers(this);
  },
  destroyed: function destroyed() {
    handleRelations(this, 'unlinked');
  }
};
global.__wxRoute = '';
global.__wxComponents = Object.create(null);
global.__wxVueOptions = Object.create(null);
function Page(options) {
  var pageOptions = parsePage(options);
  pageOptions.mixins.unshift(polyfill);
  pageOptions.mpOptions.path = global.__wxRoute;
  global.__wxComponents[global.__wxRoute] = pageOptions;
}
function initRelationsHandler(vueComponentOptions) {
  // linked 需要在当前组件 attached 之后再执行
  if (!vueComponentOptions.onServiceAttached) {
    vueComponentOptions.onServiceAttached = [];
  }
  vueComponentOptions.onServiceAttached.push(function onServiceAttached() {
    handleRelations(this, 'linked');
  });
}
function Component(options) {
  var componentOptions = parseComponent(options);
  componentOptions.mixins.unshift(polyfill);
  componentOptions.mpOptions.path = global.__wxRoute;
  initRelationsHandler(componentOptions);
  global.__wxComponents[global.__wxRoute] = componentOptions;
}
function Behavior(options) {
  return options;
}
var nextTick = _vue.default.nextTick;
exports.nextTick = nextTick;
var index = uni.__$wx__;
var _default = index;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ 14)))

/***/ }),
/* 16 */
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles.js */ 17);
var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit.js */ 18);
var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ 19);
var nonIterableRest = __webpack_require__(/*! ./nonIterableRest.js */ 21);
function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}
module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 17 */
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 18 */
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0) {
        ;
      }
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 19 */
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ 20);
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 20 */
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 21 */
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 22 */
/*!**********************!*\
  !*** external "Vue" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Vue;

/***/ }),
/* 23 */
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles.js */ 24);
var iterableToArray = __webpack_require__(/*! ./iterableToArray.js */ 25);
var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ 19);
var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread.js */ 26);
function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 24 */
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ 20);
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 25 */
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 26 */
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 27 */
/*!*********************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/card.vue ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _card_vue_vue_type_template_id_571f5b9e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./card.vue?vue&type=template&id=571f5b9e& */ 28);\n/* harmony import */ var _card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./card.vue?vue&type=script&lang=js& */ 30);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js */ 32);\n\nvar renderjs\n\n\n\n\n/* normalize component */\n\nvar component = Object(_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _card_vue_vue_type_template_id_571f5b9e___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _card_vue_vue_type_template_id_571f5b9e___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null,\n  false,\n  _card_vue_vue_type_template_id_571f5b9e___WEBPACK_IMPORTED_MODULE_0__[\"components\"],\n  renderjs\n)\n\ncomponent.options.__file = \"card.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBaUg7QUFDakg7QUFDd0Q7QUFDTDs7O0FBR25EO0FBQ3FLO0FBQ3JLLGdCQUFnQiwrS0FBVTtBQUMxQixFQUFFLDBFQUFNO0FBQ1IsRUFBRSwrRUFBTTtBQUNSLEVBQUUsd0ZBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbUZBQVU7QUFDWjtBQUNBOztBQUVBO0FBQ2UsZ0YiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucywgcmVjeWNsYWJsZVJlbmRlciwgY29tcG9uZW50cyB9IGZyb20gXCIuL2NhcmQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTU3MWY1YjllJlwiXG52YXIgcmVuZGVyanNcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vY2FyZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL2NhcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHZ1ZS1sb2FkZXJcXFxcbGliXFxcXHJ1bnRpbWVcXFxcY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGwsXG4gIGZhbHNlLFxuICBjb21wb25lbnRzLFxuICByZW5kZXJqc1xuKVxuXG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcImNhcmQudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/*!****************************************************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/card.vue?vue&type=template&id=571f5b9e& ***!
  \****************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_template_id_571f5b9e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--11-0!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./card.vue?vue&type=template&id=571f5b9e& */ 29);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_template_id_571f5b9e___WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_template_id_571f5b9e___WEBPACK_IMPORTED_MODULE_0__["staticRenderFns"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_template_id_571f5b9e___WEBPACK_IMPORTED_MODULE_0__["recyclableRender"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "components", function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_11_0_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_filter_modules_template_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_page_meta_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_template_id_571f5b9e___WEBPACK_IMPORTED_MODULE_0__["components"]; });



/***/ }),
/* 29 */
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--11-0!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/filter-modules-template.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/page-meta.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!I:/物联网参考demo-APP详细代码/最终APP程序/card.vue?vue&type=template&id=571f5b9e& ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns, recyclableRender, components */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return render; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "staticRenderFns", function() { return staticRenderFns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recyclableRender", function() { return recyclableRender; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "components", function() { return components; });
var components
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _c("p", { staticClass: _vm._$s(1, "sc", "card"), attrs: { _i: 1 } }, [
      _vm._v(_vm._$s(1, "t0-0", _vm._s(_vm.text))),
    ]),
  ])
}
var recyclableRender = false
var staticRenderFns = []
render._withStripped = true



/***/ }),
/* 30 */
/*!**********************************************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/card.vue?vue&type=script&lang=js& ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--7-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./card.vue?vue&type=script&lang=js& */ 31);\n/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_card_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStoQixDQUFnQixra0JBQUcsRUFBQyIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hRjpcXFxcSEJ1aWxkZXJYXFxcXHBsdWdpbnNcXFxcdW5pYXBwLWNsaVxcXFxub2RlX21vZHVsZXNcXFxcYmFiZWwtbG9hZGVyXFxcXGxpYlxcXFxpbmRleC5qcyFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHdlYnBhY2stcHJlcHJvY2Vzcy1sb2FkZXJcXFxcaW5kZXguanM/P3JlZi0tNy0xIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXEBkY2xvdWRpb1xcXFx2dWUtY2xpLXBsdWdpbi11bmlcXFxccGFja2FnZXNcXFxcd2VicGFjay11bmktYXBwLWxvYWRlclxcXFx1c2luZy1jb21wb25lbnRzLmpzIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXEBkY2xvdWRpb1xcXFx2dWUtY2xpLXBsdWdpbi11bmlcXFxccGFja2FnZXNcXFxcdnVlLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2NhcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanMhRjpcXFxcSEJ1aWxkZXJYXFxcXHBsdWdpbnNcXFxcdW5pYXBwLWNsaVxcXFxub2RlX21vZHVsZXNcXFxcQGRjbG91ZGlvXFxcXHZ1ZS1jbGktcGx1Z2luLXVuaVxcXFxwYWNrYWdlc1xcXFx3ZWJwYWNrLXByZXByb2Nlc3MtbG9hZGVyXFxcXGluZGV4LmpzPz9yZWYtLTctMSFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHdlYnBhY2stdW5pLWFwcC1sb2FkZXJcXFxcdXNpbmctY29tcG9uZW50cy5qcyFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHZ1ZS1sb2FkZXJcXFxcbGliXFxcXGluZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9jYXJkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--7-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!I:/物联网参考demo-APP详细代码/最终APP程序/card.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n//\n//\n//\n//\n//\n//\n//\n//\nvar _default = {\n  props: ['text']\n};\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vY2FyZC52dWUiXSwibmFtZXMiOlsicHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O2VBU0E7RUFDQUE7QUFDQTtBQUFBIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxwIGNsYXNzPVwiY2FyZFwiPlxuICAgICAge3t0ZXh0fX1cbiAgICA8L3A+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgcHJvcHM6IFsndGV4dCddXG59XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuLmNhcmQge1xuICBwYWRkaW5nOiAxMHB4O1xufVxuPC9zdHlsZT5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode, /* vue-cli only */
  components, // fixed by xxxxxx auto components
  renderjs // fixed by xxxxxx renderjs
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // fixed by xxxxxx auto components
  if (components) {
    if (!options.components) {
      options.components = {}
    }
    var hasOwn = Object.prototype.hasOwnProperty
    for (var name in components) {
      if (hasOwn.call(components, name) && !hasOwn.call(options.components, name)) {
        options.components[name] = components[name]
      }
    }
  }
  // fixed by xxxxxx renderjs
  if (renderjs) {
    if(typeof renderjs.beforeCreate === 'function'){
			renderjs.beforeCreate = [renderjs.beforeCreate]
		}
    (renderjs.beforeCreate || (renderjs.beforeCreate = [])).unshift(function() {
      this[renderjs.__module] = this
    });
    (options.mixins || (options.mixins = [])).push(renderjs)
  }

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 33 */
/*!*******************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/key.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var crypto = __webpack_require__(/*! crypto */ 38);\nfunction createCommonToken(params) {\n  var access_key = Buffer.from(params.author_key, \"base64\");\n  var version = params.version;\n  var res = 'userid' + '/' + params.user_id;\n  var et = Math.ceil((Date.now() + 365 * 24 * 3600 * 1000) / 1000);\n  var method = 'sha1';\n  var key = et + \"\\n\" + method + \"\\n\" + res + \"\\n\" + version;\n  var sign = crypto.createHmac('sha1', access_key).update(key).digest().toString('base64');\n  res = encodeURIComponent(res);\n  sign = encodeURIComponent(sign);\n  var token = \"version=\".concat(version, \"&res=\").concat(res, \"&et=\").concat(et, \"&method=\").concat(method, \"&sign=\").concat(sign);\n  return token;\n}\nmodule.exports = {\n  createCommonToken: createCommonToken\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/buffer/index.js */ 34).Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8va2V5LmpzIl0sIm5hbWVzIjpbImNyeXB0byIsInJlcXVpcmUiLCJjcmVhdGVDb21tb25Ub2tlbiIsInBhcmFtcyIsImFjY2Vzc19rZXkiLCJCdWZmZXIiLCJmcm9tIiwiYXV0aG9yX2tleSIsInZlcnNpb24iLCJyZXMiLCJ1c2VyX2lkIiwiZXQiLCJNYXRoIiwiY2VpbCIsIkRhdGUiLCJub3ciLCJtZXRob2QiLCJrZXkiLCJzaWduIiwiY3JlYXRlSG1hYyIsInVwZGF0ZSIsImRpZ2VzdCIsInRvU3RyaW5nIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidG9rZW4iLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxrREFBTUEsTUFBTSxHQUFHQyxtQkFBTyxDQUFDLGdCQUFRLENBQUM7QUFFaEMsU0FBU0MsaUJBQWlCLENBQUNDLE1BQU0sRUFBRTtFQUMvQixJQUFNQyxVQUFVLEdBQUdDLE1BQU0sQ0FBQ0MsSUFBSSxDQUFFSCxNQUFNLENBQUNJLFVBQVUsRUFBRSxRQUFRLENBQUM7RUFFNUQsSUFBTUMsT0FBTyxHQUFHTCxNQUFNLENBQUNLLE9BQU87RUFDOUIsSUFBSUMsR0FBRyxHQUFHLFFBQVEsR0FBRyxHQUFHLEdBQUdOLE1BQU0sQ0FBQ08sT0FBTztFQUN6QyxJQUFNQyxFQUFFLEdBQUdDLElBQUksQ0FBQ0MsSUFBSSxDQUFDLENBQUNDLElBQUksQ0FBQ0MsR0FBRyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksQ0FBQztFQUNsRSxJQUFNQyxNQUFNLEdBQUcsTUFBTTtFQUVyQixJQUFNQyxHQUFHLEdBQUdOLEVBQUUsR0FBRyxJQUFJLEdBQUdLLE1BQU0sR0FBRyxJQUFJLEdBQUdQLEdBQUcsR0FBRyxJQUFJLEdBQUdELE9BQU87RUFFNUQsSUFBSVUsSUFBSSxHQUFHbEIsTUFBTSxDQUFDbUIsVUFBVSxDQUFDLE1BQU0sRUFBRWYsVUFBVSxDQUFDLENBQUNnQixNQUFNLENBQUNILEdBQUcsQ0FBQyxDQUFDSSxNQUFNLEVBQUUsQ0FBQ0MsUUFBUSxDQUFDLFFBQVEsQ0FBQztFQUV4RmIsR0FBRyxHQUFHYyxrQkFBa0IsQ0FBQ2QsR0FBRyxDQUFDO0VBQzdCUyxJQUFJLEdBQUdLLGtCQUFrQixDQUFDTCxJQUFJLENBQUM7RUFDL0IsSUFBTU0sS0FBSyxxQkFBY2hCLE9BQU8sa0JBQVFDLEdBQUcsaUJBQU9FLEVBQUUscUJBQVdLLE1BQU0sbUJBQVNFLElBQUksQ0FBRTtFQUVwRixPQUFPTSxLQUFLO0FBQ2hCO0FBRUFDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHO0VBQ2Z4QixpQkFBaUIsRUFBakJBO0FBQ0YsQ0FBQyxDIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uVG9rZW4ocGFyYW1zKSB7XG4gICAgY29uc3QgYWNjZXNzX2tleSA9IEJ1ZmZlci5mcm9tKCBwYXJhbXMuYXV0aG9yX2tleSwgXCJiYXNlNjRcIilcblxuICAgIGNvbnN0IHZlcnNpb24gPSBwYXJhbXMudmVyc2lvblxuICAgIGxldCByZXMgPSAndXNlcmlkJyArICcvJyArIHBhcmFtcy51c2VyX2lkXG4gICAgY29uc3QgZXQgPSBNYXRoLmNlaWwoKERhdGUubm93KCkgKyAzNjUgKiAyNCAqIDM2MDAgKiAxMDAwKSAvIDEwMDApICAgXG4gICAgY29uc3QgbWV0aG9kID0gJ3NoYTEnXG5cbiAgICBjb25zdCBrZXkgPSBldCArIFwiXFxuXCIgKyBtZXRob2QgKyBcIlxcblwiICsgcmVzICsgXCJcXG5cIiArIHZlcnNpb25cbiAgICBcbiAgICBsZXQgc2lnbiA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGExJywgYWNjZXNzX2tleSkudXBkYXRlKGtleSkuZGlnZXN0KCkudG9TdHJpbmcoJ2Jhc2U2NCcpXG5cbiAgICByZXMgPSBlbmNvZGVVUklDb21wb25lbnQocmVzKVxuICAgIHNpZ24gPSBlbmNvZGVVUklDb21wb25lbnQoc2lnbilcbiAgICBjb25zdCB0b2tlbiA9IGB2ZXJzaW9uPSR7dmVyc2lvbn0mcmVzPSR7cmVzfSZldD0ke2V0fSZtZXRob2Q9JHttZXRob2R9JnNpZ249JHtzaWdufWBcblxuICAgIHJldHVybiB0b2tlblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlQ29tbW9uVG9rZW5cbn07XG5cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ 35)
var ieee754 = __webpack_require__(/*! ieee754 */ 36)
var isArray = __webpack_require__(/*! isarray */ 37)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ 14)))

/***/ }),
/* 35 */
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 36 */
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 37 */
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 38 */
/*!*************************************************!*\
  !*** ./node_modules/crypto-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(/*! randombytes */ 39)
exports.createHash = exports.Hash = __webpack_require__(/*! create-hash */ 44)
exports.createHmac = exports.Hmac = __webpack_require__(/*! create-hmac */ 79)

var algos = __webpack_require__(/*! browserify-sign/algos */ 82)
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(/*! pbkdf2 */ 84)
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(/*! browserify-cipher */ 90)

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = __webpack_require__(/*! diffie-hellman */ 119)

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = __webpack_require__(/*! browserify-sign */ 129)

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = __webpack_require__(/*! create-ecdh */ 184)

var publicEncrypt = __webpack_require__(/*! public-encrypt */ 185)

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = __webpack_require__(/*! randomfill */ 191)

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}


/***/ }),
/* 39 */
/*!*********************************************!*\
  !*** ./node_modules/randombytes/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_provided_global_dot_crypto, global, process) {

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var crypto = __webpack_provided_global_dot_crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/crypto.js */ 40)["default"], __webpack_require__(/*! ./../webpack/buildin/global.js */ 14), __webpack_require__(/*! ./../node-libs-browser/mock/process.js */ 41)))

/***/ }),
/* 40 */
/*!*****************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/crypto.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var lookup = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 62, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
  0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
  21, 22, 23, 24, 25, 0, 0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
  40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
]

function base64Decode (source, target) {
  var sourceLength = source.length
  var paddingLength = (source[sourceLength - 2] === '=' ? 2 : (source[sourceLength - 1] === '=' ? 1
    : 0))

  var tmp
  var byteIndex = 0
  var baseLength = (sourceLength - paddingLength) & 0xfffffffc

  for (var i = 0; i < baseLength; i += 4) {
    tmp = (lookup[source.charCodeAt(i)] << 18) |
      (lookup[source.charCodeAt(i + 1)] << 12) |
      (lookup[source.charCodeAt(i + 2)] << 6) |
      (lookup[source.charCodeAt(i + 3)])

    target[byteIndex++] = (tmp >> 16) & 0xFF
    target[byteIndex++] = (tmp >> 8) & 0xFF
    target[byteIndex++] = (tmp) & 0xFF
  }

  if (paddingLength === 1) {
    tmp = (lookup[source.charCodeAt(i)] << 10) |
      (lookup[source.charCodeAt(i + 1)] << 4) |
      (lookup[source.charCodeAt(i + 2)] >> 2)

    target[byteIndex++] = (tmp >> 8) & 0xFF
    target[byteIndex++] = tmp & 0xFF
  }

  if (paddingLength === 2) {
    tmp = (lookup[source.charCodeAt(i)] << 2) | (lookup[source.charCodeAt(i + 1)] >> 4)

    target[byteIndex++] = tmp & 0xFF
  }
}

/* harmony default export */ __webpack_exports__["default"] = ({
  getRandomValues (arr) {
    if (!(
      arr instanceof Int8Array ||
        arr instanceof Uint8Array ||
        arr instanceof Int16Array ||
        arr instanceof Uint16Array ||
        arr instanceof Int32Array ||
        arr instanceof Uint32Array ||
        arr instanceof Uint8ClampedArray
    )) {
      throw new Error('Expected an integer array')
    }
    if (arr.byteLength > 65536) {
      throw new Error('Can only request a maximum of 65536 bytes')
    }
    var crypto = uni.requireNativePlugin('DCloud-Crypto')
    base64Decode(crypto.getRandomValues(arr.byteLength), new Uint8Array(arr.buffer, arr.byteOffset,
      arr.byteLength))
    return arr
  }
});


/***/ }),
/* 41 */
/*!********************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/process.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.nextTick = function nextTick(fn) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    setTimeout(function () {
        fn.apply(null, args);
    }, 0);
};

exports.platform = exports.arch = 
exports.execPath = exports.title = 'browser';
exports.pid = 1;
exports.browser = true;
exports.env = {};
exports.argv = [];

exports.binding = function (name) {
	throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    exports.cwd = function () { return cwd };
    exports.chdir = function (dir) {
        if (!path) path = __webpack_require__(/*! path */ 42);
        cwd = path.resolve(dir, cwd);
    };
})();

exports.exit = exports.kill = 
exports.umask = exports.dlopen = 
exports.uptime = exports.memoryUsage = 
exports.uvCounters = function() {};
exports.features = {};


/***/ }),
/* 42 */
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/mock/process.js */ 41)))

/***/ }),
/* 43 */
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ 34)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 44 */
/*!*********************************************!*\
  !*** ./node_modules/create-hash/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ 45)
var MD5 = __webpack_require__(/*! md5.js */ 46)
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ 64)
var sha = __webpack_require__(/*! sha.js */ 65)
var Base = __webpack_require__(/*! cipher-base */ 73)

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}


/***/ }),
/* 45 */
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),
/* 46 */
/*!**************************************!*\
  !*** ./node_modules/md5.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ 45)
var HashBase = __webpack_require__(/*! hash-base */ 47)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5


/***/ }),
/* 47 */
/*!*****************************************!*\
  !*** ./node_modules/hash-base/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var Transform = __webpack_require__(/*! readable-stream */ 48).Transform
var inherits = __webpack_require__(/*! inherits */ 45)

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase


/***/ }),
/* 48 */
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ 49);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ 59);
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ 58);
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ 62);
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ 63);


/***/ }),
/* 49 */
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ 50);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ 37);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ 51).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ 52);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ 53));
util.inherits = __webpack_require__(/*! inherits */ 45);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 54);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ 55);
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ 57);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ 58);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ 61).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ 58);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ 61).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ 14), __webpack_require__(/*! ./../../node-libs-browser/mock/process.js */ 41)))

/***/ }),
/* 50 */
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/mock/process.js */ 41)))

/***/ }),
/* 51 */
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),
/* 52 */
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ 51).EventEmitter;


/***/ }),
/* 53 */
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! buffer */ 34).Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


/***/ }),
/* 54 */
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 55 */
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer;
var util = __webpack_require__(/*! util */ 56);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 56 */
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 57 */
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ 50);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 58 */
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ 50);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ 53));
util.inherits = __webpack_require__(/*! inherits */ 45);
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ 49);
var Writable = __webpack_require__(/*! ./_stream_writable */ 59);

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),
/* 59 */
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ 50);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ 53));
util.inherits = __webpack_require__(/*! inherits */ 45);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ 60)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ 52);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ 57);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ 58);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ 58);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/mock/process.js */ 41), __webpack_require__(/*! ./../../webpack/buildin/global.js */ 14)))

/***/ }),
/* 60 */
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ 14)))

/***/ }),
/* 61 */
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 62 */
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ 58);

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ 53));
util.inherits = __webpack_require__(/*! inherits */ 45);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 63 */
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ 62);

/*<replacement>*/
var util = Object.create(__webpack_require__(/*! core-util-is */ 53));
util.inherits = __webpack_require__(/*! inherits */ 45);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 64 */
/*!*****************************************!*\
  !*** ./node_modules/ripemd160/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(/*! buffer */ 34).Buffer
var inherits = __webpack_require__(/*! inherits */ 45)
var HashBase = __webpack_require__(/*! hash-base */ 47)

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160


/***/ }),
/* 65 */
/*!**************************************!*\
  !*** ./node_modules/sha.js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(/*! ./sha */ 66)
exports.sha1 = __webpack_require__(/*! ./sha1 */ 68)
exports.sha224 = __webpack_require__(/*! ./sha224 */ 69)
exports.sha256 = __webpack_require__(/*! ./sha256 */ 70)
exports.sha384 = __webpack_require__(/*! ./sha384 */ 71)
exports.sha512 = __webpack_require__(/*! ./sha512 */ 72)


/***/ }),
/* 66 */
/*!************************************!*\
  !*** ./node_modules/sha.js/sha.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(/*! inherits */ 45)
var Hash = __webpack_require__(/*! ./hash */ 67)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


/***/ }),
/* 67 */
/*!*************************************!*\
  !*** ./node_modules/sha.js/hash.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),
/* 68 */
/*!*************************************!*\
  !*** ./node_modules/sha.js/sha1.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ 45)
var Hash = __webpack_require__(/*! ./hash */ 67)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),
/* 69 */
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha224.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ 45)
var Sha256 = __webpack_require__(/*! ./sha256 */ 70)
var Hash = __webpack_require__(/*! ./hash */ 67)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224


/***/ }),
/* 70 */
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha256.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(/*! inherits */ 45)
var Hash = __webpack_require__(/*! ./hash */ 67)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),
/* 71 */
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha384.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ 45)
var SHA512 = __webpack_require__(/*! ./sha512 */ 72)
var Hash = __webpack_require__(/*! ./hash */ 67)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384


/***/ }),
/* 72 */
/*!***************************************!*\
  !*** ./node_modules/sha.js/sha512.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(/*! inherits */ 45)
var Hash = __webpack_require__(/*! ./hash */ 67)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512


/***/ }),
/* 73 */
/*!*******************************************!*\
  !*** ./node_modules/cipher-base/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var Transform = __webpack_require__(/*! stream */ 74).Transform
var StringDecoder = __webpack_require__(/*! string_decoder */ 61).StringDecoder
var inherits = __webpack_require__(/*! inherits */ 45)

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase


/***/ }),
/* 74 */
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(/*! events */ 51).EventEmitter;
var inherits = __webpack_require__(/*! inherits */ 45);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(/*! readable-stream/readable.js */ 48);
Stream.Writable = __webpack_require__(/*! readable-stream/writable.js */ 75);
Stream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ 76);
Stream.Transform = __webpack_require__(/*! readable-stream/transform.js */ 77);
Stream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ 78);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),
/* 75 */
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ 59);


/***/ }),
/* 76 */
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ 58);


/***/ }),
/* 77 */
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ 48).Transform


/***/ }),
/* 78 */
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./readable */ 48).PassThrough


/***/ }),
/* 79 */
/*!*********************************************!*\
  !*** ./node_modules/create-hmac/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ 45)
var Legacy = __webpack_require__(/*! ./legacy */ 80)
var Base = __webpack_require__(/*! cipher-base */ 73)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var md5 = __webpack_require__(/*! create-hash/md5 */ 81)
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ 64)

var sha = __webpack_require__(/*! sha.js */ 65)

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}


/***/ }),
/* 80 */
/*!********************************************!*\
  !*** ./node_modules/create-hmac/legacy.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(/*! inherits */ 45)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var Base = __webpack_require__(/*! cipher-base */ 73)

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac


/***/ }),
/* 81 */
/*!*****************************************!*\
  !*** ./node_modules/create-hash/md5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MD5 = __webpack_require__(/*! md5.js */ 46)

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}


/***/ }),
/* 82 */
/*!***********************************************!*\
  !*** ./node_modules/browserify-sign/algos.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./browser/algorithms.json */ 83)


/***/ }),
/* 83 */
/*!**************************************************************!*\
  !*** ./node_modules/browserify-sign/browser/algorithms.json ***!
  \**************************************************************/
/*! exports provided: sha224WithRSAEncryption, RSA-SHA224, sha256WithRSAEncryption, RSA-SHA256, sha384WithRSAEncryption, RSA-SHA384, sha512WithRSAEncryption, RSA-SHA512, RSA-SHA1, ecdsa-with-SHA1, sha256, sha224, sha384, sha512, DSA-SHA, DSA-SHA1, DSA, DSA-WITH-SHA224, DSA-SHA224, DSA-WITH-SHA256, DSA-SHA256, DSA-WITH-SHA384, DSA-SHA384, DSA-WITH-SHA512, DSA-SHA512, DSA-RIPEMD160, ripemd160WithRSA, RSA-RIPEMD160, md5WithRSAEncryption, RSA-MD5, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"sha224WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha224\",\"id\":\"302d300d06096086480165030402040500041c\"},\"RSA-SHA224\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha224\",\"id\":\"302d300d06096086480165030402040500041c\"},\"sha256WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha256\",\"id\":\"3031300d060960864801650304020105000420\"},\"RSA-SHA256\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha256\",\"id\":\"3031300d060960864801650304020105000420\"},\"sha384WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha384\",\"id\":\"3041300d060960864801650304020205000430\"},\"RSA-SHA384\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha384\",\"id\":\"3041300d060960864801650304020205000430\"},\"sha512WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"sha512\",\"id\":\"3051300d060960864801650304020305000440\"},\"RSA-SHA512\":{\"sign\":\"ecdsa/rsa\",\"hash\":\"sha512\",\"id\":\"3051300d060960864801650304020305000440\"},\"RSA-SHA1\":{\"sign\":\"rsa\",\"hash\":\"sha1\",\"id\":\"3021300906052b0e03021a05000414\"},\"ecdsa-with-SHA1\":{\"sign\":\"ecdsa\",\"hash\":\"sha1\",\"id\":\"\"},\"sha256\":{\"sign\":\"ecdsa\",\"hash\":\"sha256\",\"id\":\"\"},\"sha224\":{\"sign\":\"ecdsa\",\"hash\":\"sha224\",\"id\":\"\"},\"sha384\":{\"sign\":\"ecdsa\",\"hash\":\"sha384\",\"id\":\"\"},\"sha512\":{\"sign\":\"ecdsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-SHA\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA-SHA1\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA\":{\"sign\":\"dsa\",\"hash\":\"sha1\",\"id\":\"\"},\"DSA-WITH-SHA224\":{\"sign\":\"dsa\",\"hash\":\"sha224\",\"id\":\"\"},\"DSA-SHA224\":{\"sign\":\"dsa\",\"hash\":\"sha224\",\"id\":\"\"},\"DSA-WITH-SHA256\":{\"sign\":\"dsa\",\"hash\":\"sha256\",\"id\":\"\"},\"DSA-SHA256\":{\"sign\":\"dsa\",\"hash\":\"sha256\",\"id\":\"\"},\"DSA-WITH-SHA384\":{\"sign\":\"dsa\",\"hash\":\"sha384\",\"id\":\"\"},\"DSA-SHA384\":{\"sign\":\"dsa\",\"hash\":\"sha384\",\"id\":\"\"},\"DSA-WITH-SHA512\":{\"sign\":\"dsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-SHA512\":{\"sign\":\"dsa\",\"hash\":\"sha512\",\"id\":\"\"},\"DSA-RIPEMD160\":{\"sign\":\"dsa\",\"hash\":\"rmd160\",\"id\":\"\"},\"ripemd160WithRSA\":{\"sign\":\"rsa\",\"hash\":\"rmd160\",\"id\":\"3021300906052b2403020105000414\"},\"RSA-RIPEMD160\":{\"sign\":\"rsa\",\"hash\":\"rmd160\",\"id\":\"3021300906052b2403020105000414\"},\"md5WithRSAEncryption\":{\"sign\":\"rsa\",\"hash\":\"md5\",\"id\":\"3020300c06082a864886f70d020505000410\"},\"RSA-MD5\":{\"sign\":\"rsa\",\"hash\":\"md5\",\"id\":\"3020300c06082a864886f70d020505000410\"}}");

/***/ }),
/* 84 */
/*!****************************************!*\
  !*** ./node_modules/pbkdf2/browser.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.pbkdf2 = __webpack_require__(/*! ./lib/async */ 85)
exports.pbkdf2Sync = __webpack_require__(/*! ./lib/sync */ 88)


/***/ }),
/* 85 */
/*!******************************************!*\
  !*** ./node_modules/pbkdf2/lib/async.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__webpack_provided_global_dot_crypto, global) {var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var checkParameters = __webpack_require__(/*! ./precondition */ 86)
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ 87)
var sync = __webpack_require__(/*! ./sync */ 88)
var toBuffer = __webpack_require__(/*! ./to-buffer */ 89)

var ZERO_BUF
var subtle = __webpack_provided_global_dot_crypto && __webpack_provided_global_dot_crypto.subtle
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}
var nextTick
function getNextTick () {
  if (nextTick) {
    return nextTick
  }
  if (global.process && global.process.nextTick) {
    nextTick = global.process.nextTick
  } else if (global.queueMicrotask) {
    nextTick = global.queueMicrotask
  } else if (global.setImmediate) {
    nextTick = global.setImmediate
  } else {
    nextTick = global.setTimeout
  }
  return nextTick
}
function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out)
    })
  }, function (e) {
    getNextTick()(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    getNextTick()(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
    return
  }

  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/crypto.js */ 40)["default"], __webpack_require__(/*! ./../../webpack/buildin/global.js */ 14)))

/***/ }),
/* 86 */
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/precondition.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}


/***/ }),
/* 87 */
/*!*****************************************************!*\
  !*** ./node_modules/pbkdf2/lib/default-encoding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {var defaultEncoding
/* istanbul ignore next */
if (global.process && global.process.browser) {
  defaultEncoding = 'utf-8'
} else if (global.process && global.process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
} else {
  defaultEncoding = 'utf-8'
}
module.exports = defaultEncoding

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ 14), __webpack_require__(/*! ./../../node-libs-browser/mock/process.js */ 41)))

/***/ }),
/* 88 */
/*!*************************************************!*\
  !*** ./node_modules/pbkdf2/lib/sync-browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var md5 = __webpack_require__(/*! create-hash/md5 */ 81)
var RIPEMD160 = __webpack_require__(/*! ripemd160 */ 64)
var sha = __webpack_require__(/*! sha.js */ 65)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var checkParameters = __webpack_require__(/*! ./precondition */ 86)
var defaultEncoding = __webpack_require__(/*! ./default-encoding */ 87)
var toBuffer = __webpack_require__(/*! ./to-buffer */ 89)

var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),
/* 89 */
/*!**********************************************!*\
  !*** ./node_modules/pbkdf2/lib/to-buffer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding)
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer)
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
  }
}


/***/ }),
/* 90 */
/*!***************************************************!*\
  !*** ./node_modules/browserify-cipher/browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DES = __webpack_require__(/*! browserify-des */ 91)
var aes = __webpack_require__(/*! browserify-aes/browser */ 99)
var aesModes = __webpack_require__(/*! browserify-aes/modes */ 101)
var desModes = __webpack_require__(/*! browserify-des/modes */ 118)
var ebtk = __webpack_require__(/*! evp_bytestokey */ 116)

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 91 */
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var CipherBase = __webpack_require__(/*! cipher-base */ 73)
var des = __webpack_require__(/*! des.js */ 92)
var inherits = __webpack_require__(/*! inherits */ 45)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}


/***/ }),
/* 92 */
/*!****************************************!*\
  !*** ./node_modules/des.js/lib/des.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(/*! ./des/utils */ 93);
exports.Cipher = __webpack_require__(/*! ./des/cipher */ 94);
exports.DES = __webpack_require__(/*! ./des/des */ 96);
exports.CBC = __webpack_require__(/*! ./des/cbc */ 97);
exports.EDE = __webpack_require__(/*! ./des/ede */ 98);


/***/ }),
/* 93 */
/*!**********************************************!*\
  !*** ./node_modules/des.js/lib/des/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),
/* 94 */
/*!***********************************************!*\
  !*** ./node_modules/des.js/lib/des/cipher.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ 95);

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),
/* 95 */
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),
/* 96 */
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/des.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ 95);
var inherits = __webpack_require__(/*! inherits */ 45);

var utils = __webpack_require__(/*! ./utils */ 93);
var Cipher = __webpack_require__(/*! ./cipher */ 94);

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),
/* 97 */
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/cbc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ 95);
var inherits = __webpack_require__(/*! inherits */ 45);

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),
/* 98 */
/*!********************************************!*\
  !*** ./node_modules/des.js/lib/des/ede.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ 95);
var inherits = __webpack_require__(/*! inherits */ 45);

var Cipher = __webpack_require__(/*! ./cipher */ 94);
var DES = __webpack_require__(/*! ./des */ 96);

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),
/* 99 */
/*!************************************************!*\
  !*** ./node_modules/browserify-aes/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(/*! ./encrypter */ 100)
var deciphers = __webpack_require__(/*! ./decrypter */ 117)
var modes = __webpack_require__(/*! ./modes/list.json */ 111)

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 100 */
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/encrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MODES = __webpack_require__(/*! ./modes */ 101)
var AuthCipher = __webpack_require__(/*! ./authCipher */ 112)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var StreamCipher = __webpack_require__(/*! ./streamCipher */ 115)
var Transform = __webpack_require__(/*! cipher-base */ 73)
var aes = __webpack_require__(/*! ./aes */ 113)
var ebtk = __webpack_require__(/*! evp_bytestokey */ 116)
var inherits = __webpack_require__(/*! inherits */ 45)

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher


/***/ }),
/* 101 */
/*!****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var modeModules = {
  ECB: __webpack_require__(/*! ./ecb */ 102),
  CBC: __webpack_require__(/*! ./cbc */ 103),
  CFB: __webpack_require__(/*! ./cfb */ 105),
  CFB8: __webpack_require__(/*! ./cfb8 */ 106),
  CFB1: __webpack_require__(/*! ./cfb1 */ 107),
  OFB: __webpack_require__(/*! ./ofb */ 108),
  CTR: __webpack_require__(/*! ./ctr */ 109),
  GCM: __webpack_require__(/*! ./ctr */ 109)
}

var modes = __webpack_require__(/*! ./list.json */ 111)

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes


/***/ }),
/* 102 */
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ecb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),
/* 103 */
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cbc.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ 104)

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),
/* 104 */
/*!******************************************!*\
  !*** ./node_modules/buffer-xor/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ 34).Buffer))

/***/ }),
/* 105 */
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var xor = __webpack_require__(/*! buffer-xor */ 104)

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}


/***/ }),
/* 106 */
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),
/* 107 */
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/modes/cfb1.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}


/***/ }),
/* 108 */
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ofb.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(/*! buffer-xor */ 104)

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ 34).Buffer))

/***/ }),
/* 109 */
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/modes/ctr.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(/*! buffer-xor */ 104)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var incr32 = __webpack_require__(/*! ../incr32 */ 110)

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}


/***/ }),
/* 110 */
/*!***********************************************!*\
  !*** ./node_modules/browserify-aes/incr32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32


/***/ }),
/* 111 */
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/modes/list.json ***!
  \*****************************************************/
/*! exports provided: aes-128-ecb, aes-192-ecb, aes-256-ecb, aes-128-cbc, aes-192-cbc, aes-256-cbc, aes128, aes192, aes256, aes-128-cfb, aes-192-cfb, aes-256-cfb, aes-128-cfb8, aes-192-cfb8, aes-256-cfb8, aes-128-cfb1, aes-192-cfb1, aes-256-cfb1, aes-128-ofb, aes-192-ofb, aes-256-ofb, aes-128-ctr, aes-192-ctr, aes-256-ctr, aes-128-gcm, aes-192-gcm, aes-256-gcm, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"aes-128-ecb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-192-ecb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-256-ecb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":0,\"mode\":\"ECB\",\"type\":\"block\"},\"aes-128-cbc\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-192-cbc\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-256-cbc\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes128\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes192\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes256\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CBC\",\"type\":\"block\"},\"aes-128-cfb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-192-cfb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-256-cfb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB\",\"type\":\"stream\"},\"aes-128-cfb8\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-192-cfb8\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-256-cfb8\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB8\",\"type\":\"stream\"},\"aes-128-cfb1\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-192-cfb1\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-256-cfb1\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CFB1\",\"type\":\"stream\"},\"aes-128-ofb\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-192-ofb\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-256-ofb\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"OFB\",\"type\":\"stream\"},\"aes-128-ctr\":{\"cipher\":\"AES\",\"key\":128,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-192-ctr\":{\"cipher\":\"AES\",\"key\":192,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-256-ctr\":{\"cipher\":\"AES\",\"key\":256,\"iv\":16,\"mode\":\"CTR\",\"type\":\"stream\"},\"aes-128-gcm\":{\"cipher\":\"AES\",\"key\":128,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"},\"aes-192-gcm\":{\"cipher\":\"AES\",\"key\":192,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"},\"aes-256-gcm\":{\"cipher\":\"AES\",\"key\":256,\"iv\":12,\"mode\":\"GCM\",\"type\":\"auth\"}}");

/***/ }),
/* 112 */
/*!***************************************************!*\
  !*** ./node_modules/browserify-aes/authCipher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ 113)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var Transform = __webpack_require__(/*! cipher-base */ 73)
var inherits = __webpack_require__(/*! inherits */ 45)
var GHASH = __webpack_require__(/*! ./ghash */ 114)
var xor = __webpack_require__(/*! buffer-xor */ 104)
var incr32 = __webpack_require__(/*! ./incr32 */ 110)

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher


/***/ }),
/* 113 */
/*!********************************************!*\
  !*** ./node_modules/browserify-aes/aes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES


/***/ }),
/* 114 */
/*!**********************************************!*\
  !*** ./node_modules/browserify-aes/ghash.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH


/***/ }),
/* 115 */
/*!*****************************************************!*\
  !*** ./node_modules/browserify-aes/streamCipher.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aes = __webpack_require__(/*! ./aes */ 113)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var Transform = __webpack_require__(/*! cipher-base */ 73)
var inherits = __webpack_require__(/*! inherits */ 45)

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher


/***/ }),
/* 116 */
/*!**********************************************!*\
  !*** ./node_modules/evp_bytestokey/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var MD5 = __webpack_require__(/*! md5.js */ 46)

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey


/***/ }),
/* 117 */
/*!**************************************************!*\
  !*** ./node_modules/browserify-aes/decrypter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var AuthCipher = __webpack_require__(/*! ./authCipher */ 112)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var MODES = __webpack_require__(/*! ./modes */ 101)
var StreamCipher = __webpack_require__(/*! ./streamCipher */ 115)
var Transform = __webpack_require__(/*! cipher-base */ 73)
var aes = __webpack_require__(/*! ./aes */ 113)
var ebtk = __webpack_require__(/*! evp_bytestokey */ 116)
var inherits = __webpack_require__(/*! inherits */ 45)

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv


/***/ }),
/* 118 */
/*!**********************************************!*\
  !*** ./node_modules/browserify-des/modes.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}


/***/ }),
/* 119 */
/*!************************************************!*\
  !*** ./node_modules/diffie-hellman/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(/*! ./lib/generatePrime */ 120)
var primes = __webpack_require__(/*! ./lib/primes.json */ 127)

var DH = __webpack_require__(/*! ./lib/dh */ 128)

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ 34).Buffer))

/***/ }),
/* 120 */
/*!**********************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/generatePrime.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(/*! randombytes */ 39);
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(/*! bn.js */ 121);
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(/*! miller-rabin */ 124);
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),
/* 121 */
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = __webpack_require__(/*! buffer */ 123).Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ 122)(module)))

/***/ }),
/* 122 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 123 */
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 124 */
/*!*********************************************!*\
  !*** ./node_modules/miller-rabin/lib/mr.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(/*! bn.js */ 121);
var brorand = __webpack_require__(/*! brorand */ 125);

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),
/* 125 */
/*!***************************************!*\
  !*** ./node_modules/brorand/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(/*! crypto */ 126);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),
/* 126 */
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 127 */
/*!*****************************************************!*\
  !*** ./node_modules/diffie-hellman/lib/primes.json ***!
  \*****************************************************/
/*! exports provided: modp1, modp2, modp5, modp14, modp15, modp16, modp17, modp18, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"modp1\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff\"},\"modp2\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff\"},\"modp5\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff\"},\"modp14\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff\"},\"modp15\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff\"},\"modp16\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff\"},\"modp17\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff\"},\"modp18\":{\"gen\":\"02\",\"prime\":\"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff\"}}");

/***/ }),
/* 128 */
/*!***********************************************!*\
  !*** ./node_modules/diffie-hellman/lib/dh.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(/*! bn.js */ 121);
var MillerRabin = __webpack_require__(/*! miller-rabin */ 124);
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(/*! ./generatePrime */ 120);
var randomBytes = __webpack_require__(/*! randombytes */ 39);
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ 34).Buffer))

/***/ }),
/* 129 */
/*!*******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var createHash = __webpack_require__(/*! create-hash */ 44)
var stream = __webpack_require__(/*! readable-stream */ 48)
var inherits = __webpack_require__(/*! inherits */ 45)
var sign = __webpack_require__(/*! ./sign */ 130)
var verify = __webpack_require__(/*! ./verify */ 183)

var algorithms = __webpack_require__(/*! ./algorithms.json */ 83)
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = Buffer.from(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}


/***/ }),
/* 130 */
/*!******************************************************!*\
  !*** ./node_modules/browserify-sign/browser/sign.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var createHmac = __webpack_require__(/*! create-hmac */ 79)
var crt = __webpack_require__(/*! browserify-rsa */ 131)
var EC = __webpack_require__(/*! elliptic */ 132).ec
var BN = __webpack_require__(/*! bn.js */ 121)
var parseKeys = __webpack_require__(/*! parse-asn1 */ 162)
var curves = __webpack_require__(/*! ./curves.json */ 182)

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [0, 1]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return Buffer.from(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [0].concat(r)
  if (s[0] & 0x80) s = [0].concat(s)

  var total = r.length + s.length + 4
  var res = [0x30, total, 0x02, r.length]
  res = res.concat(r, [0x02, s.length], s)
  return Buffer.from(res)
}

function getKey (x, q, hash, algo) {
  x = Buffer.from(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length)
    x = Buffer.concat([zeros, x])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = Buffer.alloc(hlen)
  v.fill(1)
  var k = Buffer.alloc(hlen)
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = Buffer.from(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length)
    out = Buffer.concat([zeros, out])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = Buffer.alloc(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([t, kv.v])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey


/***/ }),
/* 131 */
/*!**********************************************!*\
  !*** ./node_modules/browserify-rsa/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(/*! bn.js */ 121)
var randomBytes = __webpack_require__(/*! randombytes */ 39)

function blind (priv) {
  var r = getr(priv)
  var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed()
  return { blinder: blinder, unblinder: r.invm(priv.modulus) }
}

function getr (priv) {
  var len = priv.modulus.byteLength()
  var r
  do {
    r = new BN(randomBytes(len))
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
  return r
}

function crt (msg, priv) {
  var blinds = blind(priv)
  var len = priv.modulus.byteLength()
  var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus)
  var c1 = blinded.toRed(BN.mont(priv.prime1))
  var c2 = blinded.toRed(BN.mont(priv.prime2))
  var qinv = priv.coefficient
  var p = priv.prime1
  var q = priv.prime2
  var m1 = c1.redPow(priv.exponent1).fromRed()
  var m2 = c2.redPow(priv.exponent2).fromRed()
  var h = m1.isub(m2).imul(qinv).umod(p).imul(q)
  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len)
}
crt.getr = getr

module.exports = crt

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ 34).Buffer))

/***/ }),
/* 132 */
/*!***********************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(/*! ../package.json */ 133).version;
elliptic.utils = __webpack_require__(/*! ./elliptic/utils */ 134);
elliptic.rand = __webpack_require__(/*! brorand */ 125);
elliptic.curve = __webpack_require__(/*! ./elliptic/curve */ 136);
elliptic.curves = __webpack_require__(/*! ./elliptic/curves */ 141);

// Protocols
elliptic.ec = __webpack_require__(/*! ./elliptic/ec */ 155);
elliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ 159);


/***/ }),
/* 133 */
/*!********************************************!*\
  !*** ./node_modules/elliptic/package.json ***!
  \********************************************/
/*! exports provided: name, version, description, main, files, scripts, repository, keywords, author, license, bugs, homepage, devDependencies, dependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"elliptic\",\"version\":\"6.5.4\",\"description\":\"EC cryptography\",\"main\":\"lib/elliptic.js\",\"files\":[\"lib\"],\"scripts\":{\"lint\":\"eslint lib test\",\"lint:fix\":\"npm run lint -- --fix\",\"unit\":\"istanbul test _mocha --reporter=spec test/index.js\",\"test\":\"npm run lint && npm run unit\",\"version\":\"grunt dist && git add dist/\"},\"repository\":{\"type\":\"git\",\"url\":\"git@github.com:indutny/elliptic\"},\"keywords\":[\"EC\",\"Elliptic\",\"curve\",\"Cryptography\"],\"author\":\"Fedor Indutny <fedor@indutny.com>\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/indutny/elliptic/issues\"},\"homepage\":\"https://github.com/indutny/elliptic\",\"devDependencies\":{\"brfs\":\"^2.0.2\",\"coveralls\":\"^3.1.0\",\"eslint\":\"^7.6.0\",\"grunt\":\"^1.2.1\",\"grunt-browserify\":\"^5.3.0\",\"grunt-cli\":\"^1.3.2\",\"grunt-contrib-connect\":\"^3.0.0\",\"grunt-contrib-copy\":\"^1.0.0\",\"grunt-contrib-uglify\":\"^5.0.0\",\"grunt-mocha-istanbul\":\"^5.0.2\",\"grunt-saucelabs\":\"^9.0.1\",\"istanbul\":\"^0.4.5\",\"mocha\":\"^8.0.1\"},\"dependencies\":{\"bn.js\":\"^4.11.9\",\"brorand\":\"^1.1.0\",\"hash.js\":\"^1.0.0\",\"hmac-drbg\":\"^1.0.1\",\"inherits\":\"^2.0.4\",\"minimalistic-assert\":\"^1.0.1\",\"minimalistic-crypto-utils\":\"^1.0.1\"}}");

/***/ }),
/* 134 */
/*!*****************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(/*! bn.js */ 121);
var minAssert = __webpack_require__(/*! minimalistic-assert */ 95);
var minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ 135);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),
/* 135 */
/*!*************************************************************!*\
  !*** ./node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),
/* 136 */
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(/*! ./base */ 137);
curve.short = __webpack_require__(/*! ./short */ 138);
curve.mont = __webpack_require__(/*! ./mont */ 139);
curve.edwards = __webpack_require__(/*! ./edwards */ 140);


/***/ }),
/* 137 */
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ 121);
var utils = __webpack_require__(/*! ../utils */ 134);
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),
/* 138 */
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 134);
var BN = __webpack_require__(/*! bn.js */ 121);
var inherits = __webpack_require__(/*! inherits */ 45);
var Base = __webpack_require__(/*! ./base */ 137);

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),
/* 139 */
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ 121);
var inherits = __webpack_require__(/*! inherits */ 45);
var Base = __webpack_require__(/*! ./base */ 137);

var utils = __webpack_require__(/*! ../utils */ 134);

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),
/* 140 */
/*!*************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 134);
var BN = __webpack_require__(/*! bn.js */ 121);
var inherits = __webpack_require__(/*! inherits */ 45);
var Base = __webpack_require__(/*! ./base */ 137);

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),
/* 141 */
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curves.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(/*! hash.js */ 142);
var curve = __webpack_require__(/*! ./curve */ 136);
var utils = __webpack_require__(/*! ./utils */ 134);

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ 154);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});


/***/ }),
/* 142 */
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(/*! ./hash/utils */ 143);
hash.common = __webpack_require__(/*! ./hash/common */ 144);
hash.sha = __webpack_require__(/*! ./hash/sha */ 145);
hash.ripemd = __webpack_require__(/*! ./hash/ripemd */ 152);
hash.hmac = __webpack_require__(/*! ./hash/hmac */ 153);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),
/* 143 */
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ 95);
var inherits = __webpack_require__(/*! inherits */ 45);

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),
/* 144 */
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ 143);
var assert = __webpack_require__(/*! minimalistic-assert */ 95);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),
/* 145 */
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(/*! ./sha/1 */ 146);
exports.sha224 = __webpack_require__(/*! ./sha/224 */ 148);
exports.sha256 = __webpack_require__(/*! ./sha/256 */ 149);
exports.sha384 = __webpack_require__(/*! ./sha/384 */ 150);
exports.sha512 = __webpack_require__(/*! ./sha/512 */ 151);


/***/ }),
/* 146 */
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 143);
var common = __webpack_require__(/*! ../common */ 144);
var shaCommon = __webpack_require__(/*! ./common */ 147);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 147 */
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 143);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),
/* 148 */
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 143);
var SHA256 = __webpack_require__(/*! ./256 */ 149);

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),
/* 149 */
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 143);
var common = __webpack_require__(/*! ../common */ 144);
var shaCommon = __webpack_require__(/*! ./common */ 147);
var assert = __webpack_require__(/*! minimalistic-assert */ 95);

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 150 */
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 143);

var SHA512 = __webpack_require__(/*! ./512 */ 151);

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),
/* 151 */
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 143);
var common = __webpack_require__(/*! ../common */ 144);
var assert = __webpack_require__(/*! minimalistic-assert */ 95);

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),
/* 152 */
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ 143);
var common = __webpack_require__(/*! ./common */ 144);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),
/* 153 */
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ 143);
var assert = __webpack_require__(/*! minimalistic-assert */ 95);

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),
/* 154 */
/*!*********************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};


/***/ }),
/* 155 */
/*!********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ 121);
var HmacDRBG = __webpack_require__(/*! hmac-drbg */ 156);
var utils = __webpack_require__(/*! ../utils */ 134);
var curves = __webpack_require__(/*! ../curves */ 141);
var rand = __webpack_require__(/*! brorand */ 125);
var assert = utils.assert;

var KeyPair = __webpack_require__(/*! ./key */ 157);
var Signature = __webpack_require__(/*! ./signature */ 158);

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),
/* 156 */
/*!*************************************************!*\
  !*** ./node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ 142);
var utils = __webpack_require__(/*! minimalistic-crypto-utils */ 135);
var assert = __webpack_require__(/*! minimalistic-assert */ 95);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),
/* 157 */
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ 121);
var utils = __webpack_require__(/*! ../utils */ 134);
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),
/* 158 */
/*!************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ 121);

var utils = __webpack_require__(/*! ../utils */ 134);
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),
/* 159 */
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(/*! hash.js */ 142);
var curves = __webpack_require__(/*! ../curves */ 141);
var utils = __webpack_require__(/*! ../utils */ 134);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(/*! ./key */ 160);
var Signature = __webpack_require__(/*! ./signature */ 161);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),
/* 160 */
/*!*********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ 134);
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),
/* 161 */
/*!***************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(/*! bn.js */ 121);
var utils = __webpack_require__(/*! ../utils */ 134);
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),
/* 162 */
/*!******************************************!*\
  !*** ./node_modules/parse-asn1/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(/*! ./asn1 */ 163)
var aesid = __webpack_require__(/*! ./aesid.json */ 180)
var fixProc = __webpack_require__(/*! ./fixProc */ 181)
var ciphers = __webpack_require__(/*! browserify-aes */ 99)
var compat = __webpack_require__(/*! pbkdf2 */ 84)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}


/***/ }),
/* 163 */
/*!*****************************************!*\
  !*** ./node_modules/parse-asn1/asn1.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(/*! asn1.js */ 164)

exports.certificate = __webpack_require__(/*! ./certificate */ 179)

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),
/* 164 */
/*!******************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const asn1 = exports;

asn1.bignum = __webpack_require__(/*! bn.js */ 121);

asn1.define = __webpack_require__(/*! ./asn1/api */ 165).define;
asn1.base = __webpack_require__(/*! ./asn1/base */ 177);
asn1.constants = __webpack_require__(/*! ./asn1/constants */ 178);
asn1.decoders = __webpack_require__(/*! ./asn1/decoders */ 174);
asn1.encoders = __webpack_require__(/*! ./asn1/encoders */ 166);


/***/ }),
/* 165 */
/*!**********************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/api.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const encoders = __webpack_require__(/*! ./encoders */ 166);
const decoders = __webpack_require__(/*! ./decoders */ 174);
const inherits = __webpack_require__(/*! inherits */ 45);

const api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
}

Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;

  function Generated(entity) {
    this._initNamed(entity, name);
  }
  inherits(Generated, Base);
  Generated.prototype._initNamed = function _initNamed(entity, name) {
    Base.call(this, entity, name);
  };

  return new Generated(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),
/* 166 */
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const encoders = exports;

encoders.der = __webpack_require__(/*! ./der */ 167);
encoders.pem = __webpack_require__(/*! ./pem */ 173);


/***/ }),
/* 167 */
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(/*! inherits */ 45);
const Buffer = __webpack_require__(/*! safer-buffer */ 168).Buffer;
const Node = __webpack_require__(/*! ../base/node */ 169);

// Import DER constants
const der = __webpack_require__(/*! ../constants/der */ 172);

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
  primitive,
  cls,
  content) {
  const encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    const header = Buffer.alloc(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  let lenOctets = 1;
  for (let i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  const header = Buffer.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    const buf = Buffer.alloc(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s.]+/g);
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  let size = 0;
  for (let i = 0; i < id.length; i++) {
    let ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  const objid = Buffer.alloc(size);
  let offset = objid.length - 1;
  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  let str;
  const date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = Buffer.from(numArray);
  }

  if (Buffer.isBuffer(num)) {
    let size = num.length;
    if (num.length === 0)
      size++;

    const out = Buffer.alloc(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0;
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  let size = 1;
  for (let i = num; i >= 0x100; i >>= 8)
    size++;

  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(Buffer.from(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state['default'] === null)
    return false;

  const data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  let res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),
/* 168 */
/*!********************************************!*\
  !*** ./node_modules/safer-buffer/safer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* eslint-disable node/no-deprecated-api */



var buffer = __webpack_require__(/*! buffer */ 34)
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/mock/process.js */ 41)))

/***/ }),
/* 169 */
/*!****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/node.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Reporter = __webpack_require__(/*! ../base/reporter */ 170).Reporter;
const EncoderBuffer = __webpack_require__(/*! ../base/buffer */ 171).EncoderBuffer;
const DecoderBuffer = __webpack_require__(/*! ../base/buffer */ 171).DecoderBuffer;
const assert = __webpack_require__(/*! minimalistic-assert */ 95);

// Supported tags
const tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
const methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
const overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;

  state.name = name;
  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

const stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  const state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;

  // Filter children and args
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      const res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        const value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  const state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  const state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  const state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  const state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  const state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  const state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  let result = state['default'];
  let present = true;

  let prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    let tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      const save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  let prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      const explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    const start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      let save;
      if (state.any)
        save = input.save();
      const body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any) {
      // no-op
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
        ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  const state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
      ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  const state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;

  Object.keys(state.choice).some(function(key) {
    const save = input.save();
    const node = state.choice[key];
    try {
      const value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  const state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  const result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  let result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default'];
    else
      return;
  }

  // Encode children first
  let content = null;
  let primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      const prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      const res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        const state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  if (!state.any && state.choice === null) {
    const tag = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;

  const node = state.choice[data.type];
  if (!node) {
    assert(
      false,
      data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  const state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};


/***/ }),
/* 170 */
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/reporter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(/*! inherits */ 45);

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  const state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  const state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;

  const prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;

  const now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;

  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),
/* 171 */
/*!******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(/*! inherits */ 45);
const Reporter = __webpack_require__(/*! ../base/reporter */ 170).Reporter;
const Buffer = __webpack_require__(/*! safer-buffer */ 168).Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    Buffer.isBuffer(data.base) &&
    data.constructor.name === 'DecoderBuffer' &&
    typeof data.offset === 'number' &&
    typeof data.length === 'number' &&
    typeof data.save === 'function' &&
    typeof data.restore === 'function' &&
    typeof data.isEmpty === 'function' &&
    typeof data.readUInt8 === 'function' &&
    typeof data.skip === 'function' &&
    typeof data.raw === 'function';

  return isCompatible;
};

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  const res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
};

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  const res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
};

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer.isEncoderBuffer(item))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    data.constructor.name === 'EncoderBuffer' &&
    typeof data.length === 'number' &&
    typeof data.join === 'function';

  return isCompatible;
};

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = Buffer.alloc(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),
/* 172 */
/*!********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/der.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Helper
function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
}

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = reverse(exports.tag);


/***/ }),
/* 173 */
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/encoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(/*! inherits */ 45);

const DEREncoder = __webpack_require__(/*! ./der */ 167);

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);

  const p = buf.toString('base64');
  const out = [ '-----BEGIN ' + options.label + '-----' ];
  for (let i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),
/* 174 */
/*!*********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const decoders = exports;

decoders.der = __webpack_require__(/*! ./der */ 175);
decoders.pem = __webpack_require__(/*! ./pem */ 176);


/***/ }),
/* 175 */
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/der.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(/*! inherits */ 45);

const bignum = __webpack_require__(/*! bn.js */ 121);
const DecoderBuffer = __webpack_require__(/*! ../base/buffer */ 171).DecoderBuffer;
const Node = __webpack_require__(/*! ../base/node */ 169);

// Import DER constants
const der = __webpack_require__(/*! ../constants/der */ 172);

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  const decodedTag = derDecodeTag(buffer,
    'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  let len = derDecodeLen(buffer,
    decodedTag.primitive,
    'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  const state = buffer.save();
  const res = this._skipUntilEnd(
    buffer,
    'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  for (;;) {
    const tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    const len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    let res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len);
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
  options) {
  const result = [];
  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    const res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    const raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    let str = '';
    for (let i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    const numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    const printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  const first = (identifiers[0] / 40) | 0;
  const second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    let tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  const str = buffer.raw().toString();

  let year;
  let mon;
  let day;
  let hour;
  let min;
  let sec;
  if (tag === 'gentime') {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull() {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  const raw = buffer.raw();
  let res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  let tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  const cls = der.tagClass[tag >> 6];
  const primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    let oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  const tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  let len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  const num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),
/* 176 */
/*!*******************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/decoders/pem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const inherits = __webpack_require__(/*! inherits */ 45);
const Buffer = __webpack_require__(/*! safer-buffer */ 168).Buffer;

const DERDecoder = __webpack_require__(/*! ./der */ 175);

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);

  const label = options.label.toUpperCase();

  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  const base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9+/=]+/gi, '');

  const input = Buffer.from(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),
/* 177 */
/*!*****************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/base/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const base = exports;

base.Reporter = __webpack_require__(/*! ./reporter */ 170).Reporter;
base.DecoderBuffer = __webpack_require__(/*! ./buffer */ 171).DecoderBuffer;
base.EncoderBuffer = __webpack_require__(/*! ./buffer */ 171).EncoderBuffer;
base.Node = __webpack_require__(/*! ./node */ 169);


/***/ }),
/* 178 */
/*!**********************************************************!*\
  !*** ./node_modules/asn1.js/lib/asn1/constants/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const constants = exports;

// Helper
constants._reverse = function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(/*! ./der */ 172);


/***/ }),
/* 179 */
/*!************************************************!*\
  !*** ./node_modules/parse-asn1/certificate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(/*! asn1.js */ 164)

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),
/* 180 */
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/aesid.json ***!
  \********************************************/
/*! exports provided: 2.16.840.1.101.3.4.1.1, 2.16.840.1.101.3.4.1.2, 2.16.840.1.101.3.4.1.3, 2.16.840.1.101.3.4.1.4, 2.16.840.1.101.3.4.1.21, 2.16.840.1.101.3.4.1.22, 2.16.840.1.101.3.4.1.23, 2.16.840.1.101.3.4.1.24, 2.16.840.1.101.3.4.1.41, 2.16.840.1.101.3.4.1.42, 2.16.840.1.101.3.4.1.43, 2.16.840.1.101.3.4.1.44, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"2.16.840.1.101.3.4.1.1\":\"aes-128-ecb\",\"2.16.840.1.101.3.4.1.2\":\"aes-128-cbc\",\"2.16.840.1.101.3.4.1.3\":\"aes-128-ofb\",\"2.16.840.1.101.3.4.1.4\":\"aes-128-cfb\",\"2.16.840.1.101.3.4.1.21\":\"aes-192-ecb\",\"2.16.840.1.101.3.4.1.22\":\"aes-192-cbc\",\"2.16.840.1.101.3.4.1.23\":\"aes-192-ofb\",\"2.16.840.1.101.3.4.1.24\":\"aes-192-cfb\",\"2.16.840.1.101.3.4.1.41\":\"aes-256-ecb\",\"2.16.840.1.101.3.4.1.42\":\"aes-256-cbc\",\"2.16.840.1.101.3.4.1.43\":\"aes-256-ofb\",\"2.16.840.1.101.3.4.1.44\":\"aes-256-cfb\"}");

/***/ }),
/* 181 */
/*!********************************************!*\
  !*** ./node_modules/parse-asn1/fixProc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m
var evp = __webpack_require__(/*! evp_bytestokey */ 116)
var ciphers = __webpack_require__(/*! browserify-aes */ 99)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}


/***/ }),
/* 182 */
/*!**********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/curves.json ***!
  \**********************************************************/
/*! exports provided: 1.3.132.0.10, 1.3.132.0.33, 1.2.840.10045.3.1.1, 1.2.840.10045.3.1.7, 1.3.132.0.34, 1.3.132.0.35, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"1.3.132.0.10\":\"secp256k1\",\"1.3.132.0.33\":\"p224\",\"1.2.840.10045.3.1.1\":\"p192\",\"1.2.840.10045.3.1.7\":\"p256\",\"1.3.132.0.34\":\"p384\",\"1.3.132.0.35\":\"p521\"}");

/***/ }),
/* 183 */
/*!********************************************************!*\
  !*** ./node_modules/browserify-sign/browser/verify.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer
var BN = __webpack_require__(/*! bn.js */ 121)
var EC = __webpack_require__(/*! elliptic */ 132).ec
var parseKeys = __webpack_require__(/*! parse-asn1 */ 162)
var curves = __webpack_require__(/*! ./curves.json */ 182)

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [1]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = Buffer.from(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = Buffer.from(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify


/***/ }),
/* 184 */
/*!*********************************************!*\
  !*** ./node_modules/create-ecdh/browser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(/*! elliptic */ 132)
var BN = __webpack_require__(/*! bn.js */ 121)

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ 34).Buffer))

/***/ }),
/* 185 */
/*!************************************************!*\
  !*** ./node_modules/public-encrypt/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(/*! ./publicEncrypt */ 186)
exports.privateDecrypt = __webpack_require__(/*! ./privateDecrypt */ 190)

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}


/***/ }),
/* 186 */
/*!******************************************************!*\
  !*** ./node_modules/public-encrypt/publicEncrypt.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ 162)
var randomBytes = __webpack_require__(/*! randombytes */ 39)
var createHash = __webpack_require__(/*! create-hash */ 44)
var mgf = __webpack_require__(/*! ./mgf */ 187)
var xor = __webpack_require__(/*! ./xor */ 188)
var BN = __webpack_require__(/*! bn.js */ 121)
var withPublic = __webpack_require__(/*! ./withPublic */ 189)
var crt = __webpack_require__(/*! browserify-rsa */ 131)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}


/***/ }),
/* 187 */
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/mgf.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createHash = __webpack_require__(/*! create-hash */ 44)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}


/***/ }),
/* 188 */
/*!********************************************!*\
  !*** ./node_modules/public-encrypt/xor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}


/***/ }),
/* 189 */
/*!***************************************************!*\
  !*** ./node_modules/public-encrypt/withPublic.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var BN = __webpack_require__(/*! bn.js */ 121)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic


/***/ }),
/* 190 */
/*!*******************************************************!*\
  !*** ./node_modules/public-encrypt/privateDecrypt.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var parseKeys = __webpack_require__(/*! parse-asn1 */ 162)
var mgf = __webpack_require__(/*! ./mgf */ 187)
var xor = __webpack_require__(/*! ./xor */ 188)
var BN = __webpack_require__(/*! bn.js */ 121)
var crt = __webpack_require__(/*! browserify-rsa */ 131)
var createHash = __webpack_require__(/*! create-hash */ 44)
var withPublic = __webpack_require__(/*! ./withPublic */ 189)
var Buffer = __webpack_require__(/*! safe-buffer */ 43).Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}


/***/ }),
/* 191 */
/*!********************************************!*\
  !*** ./node_modules/randomfill/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_provided_global_dot_crypto, global, process) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = __webpack_require__(/*! safe-buffer */ 43)
var randombytes = __webpack_require__(/*! randombytes */ 39)
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = __webpack_provided_global_dot_crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/crypto.js */ 40)["default"], __webpack_require__(/*! ./../webpack/buildin/global.js */ 14), __webpack_require__(/*! ./../node-libs-browser/mock/process.js */ 41)))

/***/ }),
/* 192 */
/*!********************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/App.vue ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=js& */ 193);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/runtime/componentNormalizer.js */ 32);\nvar render, staticRenderFns, recyclableRender, components\nvar renderjs\n\n\n\n\n/* normalize component */\n\nvar component = Object(_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n  _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null,\n  false,\n  components,\n  renderjs\n)\n\ncomponent.options.__file = \"App.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUN1RDtBQUNMOzs7QUFHbEQ7QUFDcUs7QUFDckssZ0JBQWdCLCtLQUFVO0FBQzFCLEVBQUUseUVBQU07QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNlLGdGIiwiZmlsZSI6IjE5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIsIHN0YXRpY1JlbmRlckZucywgcmVjeWNsYWJsZVJlbmRlciwgY29tcG9uZW50c1xudmFyIHJlbmRlcmpzXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXEBkY2xvdWRpb1xcXFx2dWUtY2xpLXBsdWdpbi11bmlcXFxccGFja2FnZXNcXFxcdnVlLWxvYWRlclxcXFxsaWJcXFxccnVudGltZVxcXFxjb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgZmFsc2UsXG4gIGNvbXBvbmVudHMsXG4gIHJlbmRlcmpzXG4pXG5cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiQXBwLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///192\n");

/***/ }),
/* 193 */
/*!*********************************************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/App.vue?vue&type=script&lang=js& ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--7-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!./App.vue?vue&type=script&lang=js& */ 194);\n/* harmony import */ var _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if([\"default\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_F_HBuilderX_plugins_uniapp_cli_node_modules_babel_loader_lib_index_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_preprocess_loader_index_js_ref_7_1_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_webpack_uni_app_loader_using_components_js_F_HBuilderX_plugins_uniapp_cli_node_modules_dcloudio_vue_cli_plugin_uni_packages_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbbnVsbF0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQThoQixDQUFnQixpa0JBQUcsRUFBQyIsImZpbGUiOiIxOTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanMhRjpcXFxcSEJ1aWxkZXJYXFxcXHBsdWdpbnNcXFxcdW5pYXBwLWNsaVxcXFxub2RlX21vZHVsZXNcXFxcQGRjbG91ZGlvXFxcXHZ1ZS1jbGktcGx1Z2luLXVuaVxcXFxwYWNrYWdlc1xcXFx3ZWJwYWNrLXByZXByb2Nlc3MtbG9hZGVyXFxcXGluZGV4LmpzPz9yZWYtLTctMSFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHdlYnBhY2stdW5pLWFwcC1sb2FkZXJcXFxcdXNpbmctY29tcG9uZW50cy5qcyFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHZ1ZS1sb2FkZXJcXFxcbGliXFxcXGluZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIUY6XFxcXEhCdWlsZGVyWFxcXFxwbHVnaW5zXFxcXHVuaWFwcC1jbGlcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanMhRjpcXFxcSEJ1aWxkZXJYXFxcXHBsdWdpbnNcXFxcdW5pYXBwLWNsaVxcXFxub2RlX21vZHVsZXNcXFxcQGRjbG91ZGlvXFxcXHZ1ZS1jbGktcGx1Z2luLXVuaVxcXFxwYWNrYWdlc1xcXFx3ZWJwYWNrLXByZXByb2Nlc3MtbG9hZGVyXFxcXGluZGV4LmpzPz9yZWYtLTctMSFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHdlYnBhY2stdW5pLWFwcC1sb2FkZXJcXFxcdXNpbmctY29tcG9uZW50cy5qcyFGOlxcXFxIQnVpbGRlclhcXFxccGx1Z2luc1xcXFx1bmlhcHAtY2xpXFxcXG5vZGVfbW9kdWxlc1xcXFxAZGNsb3VkaW9cXFxcdnVlLWNsaS1wbHVnaW4tdW5pXFxcXHBhY2thZ2VzXFxcXHZ1ZS1sb2FkZXJcXFxcbGliXFxcXGluZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///193\n");

/***/ }),
/* 194 */
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-preprocess-loader??ref--7-1!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/webpack-uni-app-loader/using-components.js!./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib??vue-loader-options!I:/物联网参考demo-APP详细代码/最终APP程序/App.vue?vue&type=script&lang=js& ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(__f__) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  onLaunch: function onLaunch() {\n    __f__(\"log\", 'App Launch', \" at App.vue:4\");\n  },\n  onShow: function onShow() {\n    __f__(\"log\", 'App Show', \" at App.vue:7\");\n  },\n  onHide: function onHide() {\n    __f__(\"log\", 'App Hide', \" at App.vue:10\");\n  }\n};\nexports.default = _default;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/vue-cli-plugin-uni/lib/format-log.js */ 12)[\"default\"]))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vQXBwLnZ1ZSJdLCJuYW1lcyI6WyJvbkxhdW5jaCIsIm9uU2hvdyIsIm9uSGlkZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O2VBQ2U7RUFDZEEsUUFBUSxFQUFFLG9CQUFXO0lBQ3BCLGFBQVksWUFBWTtFQUN6QixDQUFDO0VBQ0RDLE1BQU0sRUFBRSxrQkFBVztJQUNsQixhQUFZLFVBQVU7RUFDdkIsQ0FBQztFQUNEQyxNQUFNLEVBQUUsa0JBQVc7SUFDbEIsYUFBWSxVQUFVO0VBQ3ZCO0FBQ0QsQ0FBQztBQUFBLDJCIiwiZmlsZSI6IjE5NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IGRlZmF1bHQge1xuXHRvbkxhdW5jaDogZnVuY3Rpb24oKSB7XG5cdFx0Y29uc29sZS5sb2coJ0FwcCBMYXVuY2gnKVxuXHR9LFxuXHRvblNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnNvbGUubG9nKCdBcHAgU2hvdycpXG5cdH0sXG5cdG9uSGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0Y29uc29sZS5sb2coJ0FwcCBIaWRlJylcblx0fVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///194\n");

/***/ }),
/* 195 */
/*!*************************************************************!*\
  !*** I:/物联网参考demo-APP详细代码/最终APP程序/uni.promisify.adaptor.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ 4);\nuni.addInterceptor({\n  returnValue: function returnValue(res) {\n    if (!(!!res && (_typeof(res) === \"object\" || typeof res === \"function\") && typeof res.then === \"function\")) {\n      return res;\n    }\n    return new Promise(function (resolve, reject) {\n      res.then(function (res) {\n        return res[0] ? reject(res[0]) : resolve(res[1]);\n      });\n    });\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVuaS1hcHA6Ly8vdW5pLnByb21pc2lmeS5hZGFwdG9yLmpzIl0sIm5hbWVzIjpbInVuaSIsImFkZEludGVyY2VwdG9yIiwicmV0dXJuVmFsdWUiLCJyZXMiLCJ0aGVuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiXSwibWFwcGluZ3MiOiI7QUFBQUEsR0FBRyxDQUFDQyxjQUFjLENBQUM7RUFDakJDLFdBQVcsdUJBQUVDLEdBQUcsRUFBRTtJQUNoQixJQUFJLEVBQUUsQ0FBQyxDQUFDQSxHQUFHLEtBQUssUUFBT0EsR0FBRyxNQUFLLFFBQVEsSUFBSSxPQUFPQSxHQUFHLEtBQUssVUFBVSxDQUFDLElBQUksT0FBT0EsR0FBRyxDQUFDQyxJQUFJLEtBQUssVUFBVSxDQUFDLEVBQUU7TUFDeEcsT0FBT0QsR0FBRztJQUNaO0lBQ0EsT0FBTyxJQUFJRSxPQUFPLENBQUMsVUFBQ0MsT0FBTyxFQUFFQyxNQUFNLEVBQUs7TUFDdENKLEdBQUcsQ0FBQ0MsSUFBSSxDQUFDLFVBQUNELEdBQUc7UUFBQSxPQUFLQSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUdJLE1BQU0sQ0FBQ0osR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUdHLE9BQU8sQ0FBQ0gsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQUEsRUFBQztJQUM5RCxDQUFDLENBQUM7RUFDSjtBQUNGLENBQUMsQ0FBQyIsImZpbGUiOiIxOTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ1bmkuYWRkSW50ZXJjZXB0b3Ioe1xuICByZXR1cm5WYWx1ZSAocmVzKSB7XG4gICAgaWYgKCEoISFyZXMgJiYgKHR5cGVvZiByZXMgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHJlcyA9PT0gXCJmdW5jdGlvblwiKSAmJiB0eXBlb2YgcmVzLnRoZW4gPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXMudGhlbigocmVzKSA9PiByZXNbMF0gPyByZWplY3QocmVzWzBdKSA6IHJlc29sdmUocmVzWzFdKSk7XG4gICAgfSk7XG4gIH0sXG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///195\n");

/***/ })
],[[0,"app-config"]]]);